diff -ruN lammps-stable_2Aug2023/src/domain_omp.cpp ../lammps-stable_2Aug2023/src/domain_omp.cpp
--- lammps-stable_2Aug2023/src/domain_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/domain_omp.cpp	2023-09-26 15:27:26.467626000 -0400
@@ -0,0 +1,200 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author : Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "accelerator_omp.h"
+#include "atom.h"
+#include "error.h"
+#include "omp_compat.h"
+
+#include <cmath>
+
+using namespace LAMMPS_NS;
+
+typedef struct {
+  double x, y, z;
+} dbl3_t;
+
+/* ----------------------------------------------------------------------
+   enforce PBC and modify box image flags for each atom
+   called every reneighboring and by other commands that change atoms
+   resulting coord must satisfy lo <= coord < hi
+   MAX is important since coord - prd < lo can happen when coord = hi
+   if fix deform, remap velocity of fix group atoms by box edge velocities
+   for triclinic, atoms must be in lamda coords (0-1) before pbc is called
+   image = 10 bits for each dimension
+   increment/decrement in wrap-around fashion
+------------------------------------------------------------------------- */
+
+void DomainOMP::pbc()
+{
+  const int nlocal = atom->nlocal;
+  if (!nlocal) return;
+
+  // verify owned atoms have valid numerical coords
+  // may not if computed pairwise force between 2 atoms at same location
+
+  const double *_noalias const coord = atom->x[0];    // NOLINT
+  const int n3 = 3 * nlocal;
+  int flag = 0;
+#if defined(_OPENMP)    // clang-format off
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static) reduction(+:flag)
+#endif    // clang-format on
+  for (int i = 0; i < n3; i++)
+    if (!std::isfinite(coord[i])) flag = 1;
+  if (flag) error->one(FLERR, "Non-numeric atom coords - simulation unstable");
+
+  auto *_noalias const x = (dbl3_t *) atom->x[0];
+  auto *_noalias const v = (dbl3_t *) atom->v[0];
+  const double *_noalias const lo = (triclinic == 0) ? boxlo : boxlo_lamda;
+  const double *_noalias const hi = (triclinic == 0) ? boxhi : boxhi_lamda;
+  const double *_noalias const period = (triclinic == 0) ? prd : prd_lamda;
+  const int *_noalias const mask = atom->mask;
+  imageint *_noalias const image = atom->image;
+
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+  for (int i = 0; i < nlocal; i++) {
+    imageint idim, otherdims;
+
+    if (xperiodic) {
+      if (x[i].x < lo[0]) {
+        x[i].x += period[0];
+        if (deform_vremap && mask[i] & deform_groupbit) v[i].x += h_rate[0];
+        idim = image[i] & IMGMASK;
+        otherdims = image[i] ^ idim;
+        idim--;
+        idim &= IMGMASK;
+        image[i] = otherdims | idim;
+      }
+      if (x[i].x >= hi[0]) {
+        x[i].x -= period[0];
+        x[i].x = MAX(x[i].x, lo[0]);
+        if (deform_vremap && mask[i] & deform_groupbit) v[i].x -= h_rate[0];
+        idim = image[i] & IMGMASK;
+        otherdims = image[i] ^ idim;
+        idim++;
+        idim &= IMGMASK;
+        image[i] = otherdims | idim;
+      }
+    }
+
+    if (yperiodic) {
+      if (x[i].y < lo[1]) {
+        x[i].y += period[1];
+        if (deform_vremap && mask[i] & deform_groupbit) {
+          v[i].x += h_rate[5];
+          v[i].y += h_rate[1];
+        }
+        idim = (image[i] >> IMGBITS) & IMGMASK;
+        otherdims = image[i] ^ (idim << IMGBITS);
+        idim--;
+        idim &= IMGMASK;
+        image[i] = otherdims | (idim << IMGBITS);
+      }
+      if (x[i].y >= hi[1]) {
+        x[i].y -= period[1];
+        x[i].y = MAX(x[i].y, lo[1]);
+        if (deform_vremap && mask[i] & deform_groupbit) {
+          v[i].x -= h_rate[5];
+          v[i].y -= h_rate[1];
+        }
+        idim = (image[i] >> IMGBITS) & IMGMASK;
+        otherdims = image[i] ^ (idim << IMGBITS);
+        idim++;
+        idim &= IMGMASK;
+        image[i] = otherdims | (idim << IMGBITS);
+      }
+    }
+
+    if (zperiodic) {
+      if (x[i].z < lo[2]) {
+        x[i].z += period[2];
+        if (deform_vremap && mask[i] & deform_groupbit) {
+          v[i].x += h_rate[4];
+          v[i].y += h_rate[3];
+          v[i].z += h_rate[2];
+        }
+        idim = image[i] >> IMG2BITS;
+        otherdims = image[i] ^ (idim << IMG2BITS);
+        idim--;
+        idim &= IMGMASK;
+        image[i] = otherdims | (idim << IMG2BITS);
+      }
+      if (x[i].z >= hi[2]) {
+        x[i].z -= period[2];
+        x[i].z = MAX(x[i].z, lo[2]);
+        if (deform_vremap && mask[i] & deform_groupbit) {
+          v[i].x -= h_rate[4];
+          v[i].y -= h_rate[3];
+          v[i].z -= h_rate[2];
+        }
+        idim = image[i] >> IMG2BITS;
+        otherdims = image[i] ^ (idim << IMG2BITS);
+        idim++;
+        idim &= IMGMASK;
+        image[i] = otherdims | (idim << IMG2BITS);
+      }
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   convert triclinic 0-1 lamda coords to box coords for all N atoms
+   x = H lamda + x0;
+------------------------------------------------------------------------- */
+
+void DomainOMP::lamda2x(int n)
+{
+  const int num = n;
+  if (!n) return;
+  auto *_noalias const x = (dbl3_t *) atom->x[0];
+
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+  for (int i = 0; i < num; i++) {
+    x[i].x = h[0] * x[i].x + h[5] * x[i].y + h[4] * x[i].z + boxlo[0];
+    x[i].y = h[1] * x[i].y + h[3] * x[i].z + boxlo[1];
+    x[i].z = h[2] * x[i].z + boxlo[2];
+  }
+}
+
+/* ----------------------------------------------------------------------
+   convert box coords to triclinic 0-1 lamda coords for all N atoms
+   lamda = H^-1 (x - x0)
+------------------------------------------------------------------------- */
+
+void DomainOMP::x2lamda(int n)
+{
+  const int num = n;
+  if (!n) return;
+  auto *_noalias const x = (dbl3_t *) atom->x[0];
+
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+  for (int i = 0; i < num; i++) {
+    double delta0 = x[i].x - boxlo[0];
+    double delta1 = x[i].y - boxlo[1];
+    double delta2 = x[i].z - boxlo[2];
+
+    x[i].x = h_inv[0] * delta0 + h_inv[5] * delta1 + h_inv[4] * delta2;
+    x[i].y = h_inv[1] * delta1 + h_inv[3] * delta2;
+    x[i].z = h_inv[2] * delta2;
+  }
+}
diff -ruN lammps-stable_2Aug2023/src/fix_gravity_omp.cpp ../lammps-stable_2Aug2023/src/fix_gravity_omp.cpp
--- lammps-stable_2Aug2023/src/fix_gravity_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_gravity_omp.cpp	2023-09-26 15:27:26.474447000 -0400
@@ -0,0 +1,106 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "fix_gravity_omp.h"
+
+#include "atom.h"
+#include "update.h"
+#include "input.h"
+#include "modify.h"
+#include "variable.h"
+
+#include "omp_compat.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+enum{CHUTE,SPHERICAL,GRADIENT,VECTOR};
+
+/* ---------------------------------------------------------------------- */
+
+FixGravityOMP::FixGravityOMP(LAMMPS *lmp, int narg, char **arg) :
+  FixGravity(lmp, narg, arg) { }
+
+/* ---------------------------------------------------------------------- */
+
+void FixGravityOMP::post_force(int /* vflag */)
+{
+  // update gravity due to variables
+
+  if (varflag != CONSTANT) {
+    modify->clearstep_compute();
+    if (mstyle == EQUAL) magnitude = input->variable->compute_equal(mvar);
+    if (vstyle == EQUAL) magnitude = input->variable->compute_equal(vvar);
+    if (pstyle == EQUAL) magnitude = input->variable->compute_equal(pvar);
+    if (tstyle == EQUAL) magnitude = input->variable->compute_equal(tvar);
+    if (xstyle == EQUAL) magnitude = input->variable->compute_equal(xvar);
+    if (ystyle == EQUAL) magnitude = input->variable->compute_equal(yvar);
+    if (zstyle == EQUAL) magnitude = input->variable->compute_equal(zvar);
+    modify->addstep_compute(update->ntimestep + 1);
+
+    set_acceleration();
+  }
+
+  const double * const * const x = atom->x;
+  double * const * const f = atom->f;
+  double * const rmass = atom->rmass;
+  double * const mass = atom->mass;
+  int * const mask = atom->mask;
+  int * const type = atom->type;
+  const int nlocal = atom->nlocal;
+  const double xacc_thr = xacc;
+  const double yacc_thr = yacc;
+  const double zacc_thr = zacc;
+
+  eflag = 0;
+  double grav = 0.0;
+
+  if (rmass) {
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE reduction(-:grav)
+#endif
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) {
+        const double massone = rmass[i];
+        f[i][0] += massone*xacc_thr;
+        f[i][1] += massone*yacc_thr;
+        f[i][2] += massone*zacc_thr;
+        grav -= massone * (xacc_thr*x[i][0] + yacc_thr*x[i][1] + zacc_thr*x[i][2]);
+      }
+  } else {
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE reduction(-:grav)
+#endif
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) {
+        const double massone = mass[type[i]];
+        f[i][0] += massone*xacc_thr;
+        f[i][1] += massone*yacc_thr;
+        f[i][2] += massone*zacc_thr;
+        grav -= massone * (xacc_thr*x[i][0] + yacc_thr*x[i][1] + zacc_thr*x[i][2]);
+      }
+  }
+  egrav = grav;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixGravityOMP::post_force_respa(int vflag, int ilevel, int /* iloop */)
+{
+  if (ilevel == ilevel_respa) post_force(vflag);
+}
diff -ruN lammps-stable_2Aug2023/src/fix_gravity_omp.h ../lammps-stable_2Aug2023/src/fix_gravity_omp.h
--- lammps-stable_2Aug2023/src/fix_gravity_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_gravity_omp.h	2023-09-26 15:27:28.338496000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+// clang-format off
+FixStyle(gravity/omp,FixGravityOMP);
+// clang-format on
+#else
+
+#ifndef LMP_FIX_GRAVITY_OMP_H
+#define LMP_FIX_GRAVITY_OMP_H
+
+#include "fix_gravity.h"
+
+namespace LAMMPS_NS {
+
+class FixGravityOMP : public FixGravity {
+
+ public:
+  FixGravityOMP(class LAMMPS *, int, char **);
+  void post_force(int) override;
+  void post_force_respa(int, int, int) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/fix_neigh_history_omp.cpp ../lammps-stable_2Aug2023/src/fix_neigh_history_omp.cpp
--- lammps-stable_2Aug2023/src/fix_neigh_history_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_neigh_history_omp.cpp	2023-09-26 15:27:26.495041000 -0400
@@ -0,0 +1,597 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "fix_neigh_history_omp.h"
+
+#include "atom.h"
+#include "comm.h"
+#include "error.h"
+#include "memory.h"
+#include "my_page.h"
+#include "neigh_list.h"
+#include "pair.h"
+
+#if defined(_OPENMP)
+#include <omp.h>
+#endif
+
+#include <cstring>
+
+#include "omp_compat.h"
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+FixNeighHistoryOMP::FixNeighHistoryOMP(class LAMMPS *lmp, int narg, char **argv) :
+    FixNeighHistory(lmp, narg, argv)
+{
+}
+
+/* ----------------------------------------------------------------------
+   copy partner info from neighbor data structs (NDS) to atom arrays
+   should be called whenever NDS store current history info
+     and need to transfer the info to owned atoms
+   e.g. when atoms migrate to new procs, new neigh list built, or between runs
+     when atoms may be added or deleted (NDS becomes out-of-date)
+   the next post_neighbor() will put this info back into new NDS
+   called during run before atom exchanges, including for restart files
+   called at end of run via post_run()
+   do not call during setup of run (setup_pre_exchange)
+     b/c there is no guarantee of a current NDS (even on continued run)
+   if run command does a 2nd run with pre = no, then no neigh list
+     will be built, but old neigh list will still have the info
+   onesided and newton on and newton off versions
+------------------------------------------------------------------------- */
+// below is the pre_exchange() function from the parent class
+// void FixNeighHistory::pre_exchange()
+// {
+//  if (onesided) pre_exchange_onesided();
+//  else if (newton_pair) pre_exchange_newton();
+//  else pre_exchange_no_newton();
+//}
+
+/* ----------------------------------------------------------------------
+   onesided version for sphere contact with line/tri particles
+   neighbor list has I = sphere, J = line/tri
+   only store history info with spheres
+------------------------------------------------------------------------- */
+
+void FixNeighHistoryOMP::pre_exchange_onesided()
+{
+  const int nthreads = comm->nthreads;
+  const int nlocal = atom->nlocal;
+  maxpartner = 0;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE
+#endif
+  {
+
+#if defined(_OPENMP)
+    const int tid = omp_get_thread_num();
+#else
+    const int tid = 0;
+#endif
+
+    int i, j, ii, jj, m, n, inum, jnum;
+    int *ilist, *jlist, *numneigh, **firstneigh;
+    int *allflags;
+    double *allvalues, *onevalues;
+
+    // NOTE: all operations until very end are with:
+    //   nlocal_neigh <= current nlocal
+    // b/c previous neigh list was built with nlocal_neigh
+    // nlocal can be larger if other fixes added atoms at this pre_exchange()
+
+    // clear per-thread paged data structures
+
+    MyPage<tagint> &ipg = ipage_atom[tid];
+    MyPage<double> &dpg = dpage_atom[tid];
+    ipg.reset();
+    dpg.reset();
+
+    // each thread works on a fixed chunk of local and ghost atoms.
+    const int ldelta = 1 + nlocal_neigh / nthreads;
+    const int lfrom = tid * ldelta;
+    const int lmax = lfrom + ldelta;
+    const int lto = (lmax > nlocal_neigh) ? nlocal_neigh : lmax;
+
+    // 1st loop over neighbor list, I = sphere, J = tri
+    // only calculate npartner for each owned spheres
+
+    for (i = lfrom; i < lto; i++) npartner[i] = 0;
+
+    tagint *tag = atom->tag;
+    NeighList *list = pair->list;
+    inum = list->inum;
+    ilist = list->ilist;
+    numneigh = list->numneigh;
+    firstneigh = list->firstneigh;
+
+    for (ii = 0; ii < inum; ii++) {
+      i = ilist[ii];
+      jlist = firstneigh[i];
+      jnum = numneigh[i];
+      allflags = firstflag[i];
+
+      for (jj = 0; jj < jnum; jj++)
+        if (allflags[jj])
+          if ((i >= lfrom) && (i < lto)) npartner[i]++;
+    }
+
+    // get page chunks to store atom IDs and shear history for my atoms
+
+    for (ii = 0; ii < inum; ii++) {
+      i = ilist[ii];
+      if ((i >= lfrom) && (i < lto)) {
+        n = npartner[i];
+        partner[i] = ipg.get(n);
+        valuepartner[i] = dpg.get(dnum * n);
+        if (partner[i] == nullptr || valuepartner[i] == nullptr)
+          error->one(FLERR, "Neighbor history overflow, boost neigh_modify one");
+      }
+    }
+
+    // 2nd loop over neighbor list
+    // store partner IDs and values for owned+ghost atoms
+    // re-zero npartner to use as counter
+
+    for (i = lfrom; i < lto; i++) npartner[i] = 0;
+
+    for (ii = 0; ii < inum; ii++) {
+      i = ilist[ii];
+      jlist = firstneigh[i];
+      jnum = numneigh[i];
+      allflags = firstflag[i];
+      allvalues = firstvalue[i];
+
+      for (jj = 0; jj < jnum; jj++) {
+        if (allflags[jj]) {
+          onevalues = &allvalues[dnum * jj];
+          j = jlist[jj];
+          j &= NEIGHMASK;
+
+          if ((i >= lfrom) && (i < lto)) {
+            m = npartner[i]++;
+            partner[i][m] = tag[j];
+            memcpy(&valuepartner[i][dnum * m], onevalues, dnumbytes);
+          }
+        }
+      }
+    }
+
+    // set maxpartner = max # of partners of any owned atom
+    // maxexchange = max # of values for any Comm::exchange() atom
+
+    maxpartner = m = 0;
+    for (i = lfrom; i < lto; i++) m = MAX(m, npartner[i]);
+
+#if defined(_OPENMP)
+#pragma omp critical
+#endif
+    {
+      maxpartner = MAX(m, maxpartner);
+      maxexchange = (dnum + 1) * maxpartner + 1;
+    }
+  }
+
+  // zero npartner values from previous nlocal_neigh to current nlocal
+  for (int i = nlocal_neigh; i < nlocal; ++i) npartner[i] = 0;
+}
+
+/* -------------------------------------------------------------------- */
+
+void FixNeighHistoryOMP::pre_exchange_newton()
+{
+  const int nthreads = comm->nthreads;
+  maxpartner = 0;
+  for (int i = 0; i < nall_neigh; i++) npartner[i] = 0;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE
+#endif
+  {
+
+#if defined(_OPENMP)
+    const int tid = omp_get_thread_num();
+#else
+    const int tid = 0;
+#endif
+
+    int i, j, ii, jj, m, n, inum, jnum;
+    int *ilist, *jlist, *numneigh, **firstneigh;
+    int *allflags;
+    double *allvalues, *onevalues, *jvalues;
+
+    MyPage<tagint> &ipg = ipage_atom[tid];
+    MyPage<double> &dpg = dpage_atom[tid];
+    ipg.reset();
+    dpg.reset();
+
+    // 1st loop over neighbor list
+    // calculate npartner for each owned+ghost atom
+
+    tagint *tag = atom->tag;
+
+    NeighList *list = pair->list;
+    inum = list->inum;
+    ilist = list->ilist;
+    numneigh = list->numneigh;
+    firstneigh = list->firstneigh;
+
+    // each thread works on a fixed chunk of local and ghost atoms.
+    const int ldelta = 1 + nlocal_neigh / nthreads;
+    const int lfrom = tid * ldelta;
+    const int lmax = lfrom + ldelta;
+    const int lto = (lmax > nlocal_neigh) ? nlocal_neigh : lmax;
+
+    for (ii = 0; ii < inum; ii++) {
+      i = ilist[ii];
+      jlist = firstneigh[i];
+      jnum = numneigh[i];
+      allflags = firstflag[i];
+
+      for (jj = 0; jj < jnum; jj++) {
+        if (allflags[jj]) {
+          if ((i >= lfrom) && (i < lto)) npartner[i]++;
+
+          j = jlist[jj];
+          j &= NEIGHMASK;
+          if ((j >= lfrom) && (j < lto)) npartner[j]++;
+        }
+      }
+    }
+#if defined(_OPENMP)
+#pragma omp barrier
+    {
+      ;
+    }
+
+    // perform reverse comm to augment owned npartner counts with ghost counts
+
+#pragma omp master
+#endif
+    {
+      commflag = NPARTNER;
+      comm->reverse_comm(this, 0);
+    }
+
+    // get page chunks to store atom IDs and shear history for my atoms
+
+    for (ii = 0; ii < inum; ii++) {
+      i = ilist[ii];
+      if ((i >= lfrom) && (i < lto)) {
+        n = npartner[i];
+        partner[i] = ipg.get(n);
+        valuepartner[i] = dpg.get(dnum * n);
+        if (partner[i] == nullptr || valuepartner[i] == nullptr)
+          error->one(FLERR, "Neighbor history overflow, boost neigh_modify one");
+      }
+    }
+
+#if defined(_OPENMP)
+#pragma omp master
+#endif
+    {
+      for (i = nlocal_neigh; i < nall_neigh; i++) {
+        n = npartner[i];
+        partner[i] = ipg.get(n);
+        valuepartner[i] = dpg.get(dnum * n);
+        if (partner[i] == nullptr || valuepartner[i] == nullptr) {
+          error->one(FLERR, "Neighbor history overflow, boost neigh_modify one");
+        }
+      }
+    }
+
+    // 2nd loop over neighbor list
+    // store partner IDs and values for owned+ghost atoms
+    // re-zero npartner to use as counter
+
+    for (i = lfrom; i < lto; i++) npartner[i] = 0;
+
+    for (ii = 0; ii < inum; ii++) {
+      i = ilist[ii];
+      jlist = firstneigh[i];
+      jnum = numneigh[i];
+      allflags = firstflag[i];
+      allvalues = firstvalue[i];
+
+      for (jj = 0; jj < jnum; jj++) {
+        if (allflags[jj]) {
+          onevalues = &allvalues[dnum * jj];
+          j = jlist[jj];
+          j &= NEIGHMASK;
+
+          if ((i >= lfrom) && (i < lto)) {
+            m = npartner[i]++;
+            partner[i][m] = tag[j];
+            memcpy(&valuepartner[i][dnum * m], onevalues, dnumbytes);
+          }
+
+          if ((j >= lfrom) && (j < lto)) {
+            m = npartner[j]++;
+            partner[j][m] = tag[i];
+            jvalues = &valuepartner[j][dnum * m];
+            for (n = 0; n < dnum; n++) jvalues[n] = -onevalues[n];
+          }
+        }
+      }
+    }
+#if defined(_OPENMP)
+#pragma omp barrier
+    {
+      ;
+    }
+
+#pragma omp master
+#endif
+    {
+      // perform reverse comm to augment
+      // owned atom partner/valuepartner with ghost info
+      // use variable variant b/c size of packed data can be arbitrarily large
+      //   if many touching neighbors for large particle
+
+      commflag = PERPARTNER;
+      comm->reverse_comm_variable(this);
+    }
+
+    // set maxpartner = max # of partners of any owned atom
+    // maxexchange = max # of values for any Comm::exchange() atom
+    m = 0;
+    for (i = lfrom; i < lto; i++) m = MAX(m, npartner[i]);
+
+#if defined(_OPENMP)
+#pragma omp critical
+#endif
+    {
+      maxpartner = MAX(m, maxpartner);
+      maxexchange = (dnum + 1) * maxpartner + 1;
+    }
+  }
+
+  // zero npartner values from previous nlocal_neigh to current nlocal
+
+  int nlocal = atom->nlocal;
+  for (int i = nlocal_neigh; i < nlocal; i++) npartner[i] = 0;
+}
+
+/* -------------------------------------------------------------------- */
+
+void FixNeighHistoryOMP::pre_exchange_no_newton()
+{
+  const int nthreads = comm->nthreads;
+  maxpartner = 0;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE
+#endif
+  {
+
+#if defined(_OPENMP)
+    const int tid = omp_get_thread_num();
+#else
+    const int tid = 0;
+#endif
+
+    int i, j, ii, jj, m, n, inum, jnum;
+    int *ilist, *jlist, *numneigh, **firstneigh;
+    int *allflags;
+    double *allvalues, *onevalues, *jvalues;
+
+    MyPage<tagint> &ipg = ipage_atom[tid];
+    MyPage<double> &dpg = dpage_atom[tid];
+    ipg.reset();
+    dpg.reset();
+
+    // 1st loop over neighbor list
+    // calculate npartner for each owned atom
+
+    tagint *tag = atom->tag;
+
+    NeighList *list = pair->list;
+    inum = list->inum;
+    ilist = list->ilist;
+    numneigh = list->numneigh;
+    firstneigh = list->firstneigh;
+
+    // each thread works on a fixed chunk of local and ghost atoms.
+    const int ldelta = 1 + nlocal_neigh / nthreads;
+    const int lfrom = tid * ldelta;
+    const int lmax = lfrom + ldelta;
+    const int lto = (lmax > nlocal_neigh) ? nlocal_neigh : lmax;
+
+    // zero npartners for all current atoms and
+    // clear page data structures for this thread
+
+    for (i = lfrom; i < lto; i++) npartner[i] = 0;
+
+    for (ii = 0; ii < inum; ii++) {
+      i = ilist[ii];
+      jlist = firstneigh[i];
+      jnum = numneigh[i];
+      allflags = firstflag[i];
+
+      for (jj = 0; jj < jnum; jj++) {
+        if (allflags[jj]) {
+          if ((i >= lfrom) && (i < lto)) npartner[i]++;
+
+          j = jlist[jj];
+          j &= NEIGHMASK;
+          if ((j >= lfrom) && (j < lto)) npartner[j]++;
+        }
+      }
+    }
+
+    // get page chunks to store atom IDs and shear history for my atoms
+
+    for (ii = 0; ii < inum; ii++) {
+      i = ilist[ii];
+      if ((i >= lfrom) && (i < lto)) {
+        n = npartner[i];
+        partner[i] = ipg.get(n);
+        valuepartner[i] = dpg.get(dnum * n);
+        if (partner[i] == nullptr || valuepartner[i] == nullptr)
+          error->one(FLERR, "Neighbor history overflow, boost neigh_modify one");
+      }
+    }
+
+    // 2nd loop over neighbor list
+    // store partner IDs and values for owned+ghost atoms
+    // re-zero npartner to use as counter
+
+    for (i = lfrom; i < lto; i++) npartner[i] = 0;
+
+    for (ii = 0; ii < inum; ii++) {
+      i = ilist[ii];
+      jlist = firstneigh[i];
+      jnum = numneigh[i];
+      allflags = firstflag[i];
+      allvalues = firstvalue[i];
+
+      for (jj = 0; jj < jnum; jj++) {
+        if (allflags[jj]) {
+          onevalues = &allvalues[dnum * jj];
+          j = jlist[jj];
+          j &= NEIGHMASK;
+
+          if ((i >= lfrom) && (i < lto)) {
+            m = npartner[i]++;
+            partner[i][m] = tag[j];
+            memcpy(&valuepartner[i][dnum * m], onevalues, dnumbytes);
+          }
+
+          if ((j >= lfrom) && (j < lto)) {
+            m = npartner[j]++;
+            partner[j][m] = tag[i];
+            jvalues = &valuepartner[j][dnum * m];
+            for (n = 0; n < dnum; n++) jvalues[n] = -onevalues[n];
+          }
+        }
+      }
+    }
+
+    // set maxpartner = max # of partners of any owned atom
+    // maxexchange = max # of values for any Comm::exchange() atom
+
+    m = 0;
+    for (i = lfrom; i < lto; i++) m = MAX(m, npartner[i]);
+
+#if defined(_OPENMP)
+#pragma omp critical
+#endif
+    {
+      maxpartner = MAX(m, maxpartner);
+      maxexchange = (dnum + 1) * maxpartner + 1;
+    }
+  }
+}
+
+/* -------------------------------------------------------------------- */
+
+void FixNeighHistoryOMP::post_neighbor()
+{
+  const int nthreads = comm->nthreads;
+  maxpartner = 0;
+  const int nlocal = atom->nlocal;
+  const int nall = nlocal + atom->nghost;
+  nlocal_neigh = nlocal;
+  nall_neigh = nall;
+
+  // realloc firstflag and firstvalue if needed
+
+  if (maxatom < nlocal) {
+    memory->sfree(firstflag);
+    memory->sfree(firstvalue);
+    maxatom = nall;
+    firstflag = (int **) memory->smalloc(maxatom * sizeof(int *), "neighbor_history:firstflag");
+    firstvalue =
+        (double **) memory->smalloc(maxatom * sizeof(double *), "neighbor_history:firstvalue");
+  }
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE
+#endif
+  {
+
+#if defined(_OPENMP)
+    const int tid = omp_get_thread_num();
+#else
+    const int tid = 0;
+#endif
+
+    int i, j, ii, jj, m, nn, np, inum, jnum, rflag;
+    tagint jtag;
+    int *ilist, *jlist, *numneigh, **firstneigh;
+    int *allflags;
+    double *allvalues;
+
+    MyPage<int> &ipg = ipage_neigh[tid];
+    MyPage<double> &dpg = dpage_neigh[tid];
+    ipg.reset();
+    dpg.reset();
+
+    // 1st loop over neighbor list
+    // calculate npartner for each owned atom
+
+    tagint *tag = atom->tag;
+
+    NeighList *list = pair->list;
+    inum = list->inum;
+    ilist = list->ilist;
+    numneigh = list->numneigh;
+    firstneigh = list->firstneigh;
+
+    // each thread works on a fixed chunk of local and ghost atoms.
+    const int ldelta = 1 + inum / nthreads;
+    const int lfrom = tid * ldelta;
+    const int lmax = lfrom + ldelta;
+    const int lto = (lmax > inum) ? inum : lmax;
+
+    for (ii = lfrom; ii < lto; ii++) {
+      i = ilist[ii];
+      jlist = firstneigh[i];
+      jnum = numneigh[i];
+      firstflag[i] = allflags = ipg.get(jnum);
+      firstvalue[i] = allvalues = dpg.get(jnum * dnum);
+      np = npartner[i];
+      nn = 0;
+
+      for (jj = 0; jj < jnum; jj++) {
+        j = jlist[jj];
+        rflag = histmask(j);
+        j &= NEIGHMASK;
+        jlist[jj] = j;
+
+        // rflag = 1 if r < radsum in npair_size() method
+        // preserve neigh history info if tag[j] is in old-neigh partner list
+        // this test could be more geometrically precise for two sphere/line/tri
+
+        if (rflag) {
+          jtag = tag[j];
+          for (m = 0; m < np; m++)
+            if (partner[i][m] == jtag) break;
+          if (m < np) {
+            allflags[jj] = 1;
+            memcpy(&allvalues[nn], &valuepartner[i][dnum * m], dnumbytes);
+          } else {
+            allflags[jj] = 0;
+            memcpy(&allvalues[nn], zeroes, dnumbytes);
+          }
+        } else {
+          allflags[jj] = 0;
+          memcpy(&allvalues[nn], zeroes, dnumbytes);
+        }
+        nn += dnum;
+      }
+    }
+  }
+}
diff -ruN lammps-stable_2Aug2023/src/fix_neigh_history_omp.h ../lammps-stable_2Aug2023/src/fix_neigh_history_omp.h
--- lammps-stable_2Aug2023/src/fix_neigh_history_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_neigh_history_omp.h	2023-09-26 15:27:28.344141000 -0400
@@ -0,0 +1,40 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+// clang-format off
+FixStyle(NEIGH_HISTORY/omp,FixNeighHistoryOMP);
+// clang-format on
+#else
+
+#ifndef LMP_FIX_NEIGH_HISTORY_OMP_H
+#define LMP_FIX_NEIGH_HISTORY_OMP_H
+
+#include "fix_neigh_history.h"
+
+namespace LAMMPS_NS {
+
+class FixNeighHistoryOMP : public FixNeighHistory {
+
+ public:
+  FixNeighHistoryOMP(class LAMMPS *lmp, int narg, char **argv);
+  void pre_exchange_onesided() override;
+  void pre_exchange_newton() override;
+  void pre_exchange_no_newton() override;
+  void post_neighbor() override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/fix_nh_omp.cpp ../lammps-stable_2Aug2023/src/fix_nh_omp.cpp
--- lammps-stable_2Aug2023/src/fix_nh_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nh_omp.cpp	2023-09-26 15:27:26.517633000 -0400
@@ -0,0 +1,384 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing authors: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "fix_nh_omp.h"
+
+#include "atom.h"
+#include "compute.h"
+#include "domain.h"
+#include "error.h"
+#include "modify.h"
+
+#include <cmath>
+
+#include "omp_compat.h"
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+enum{NOBIAS,BIAS};
+enum{ISO,ANISO,TRICLINIC};
+
+#define TILTMAX 1.5
+
+typedef struct { double x,y,z; } dbl3_t;
+
+/* ----------------------------------------------------------------------
+   change box size
+   remap all atoms or dilate group atoms depending on allremap flag
+   if rigid bodies exist, scale rigid body centers-of-mass
+------------------------------------------------------------------------- */
+
+void FixNHOMP::remap()
+{
+  double oldlo,oldhi,expfac;
+
+  double * const * _noalias const x = atom->x;
+  const int * _noalias const mask = atom->mask;
+  const int nlocal = atom->nlocal;
+  double * _noalias const h = domain->h;
+
+  // omega is not used, except for book-keeping
+
+  for (int i = 0; i < 6; i++) omega[i] += dto*omega_dot[i];
+
+  // convert pertinent atoms and rigid bodies to lamda coords
+
+  if (allremap) domain->x2lamda(nlocal);
+  else {
+#if defined (_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & dilate_group_bit)
+        domain->x2lamda(x[i],x[i]);
+  }
+
+  if (nrigid)
+    for (int i = 0; i < nrigid; i++)
+      modify->fix[rfix[i]]->deform(0);
+
+  // reset global and local box to new size/shape
+
+  // this operation corresponds to applying the
+  // translate and scale operations
+  // corresponding to the solution of the following ODE:
+  //
+  // h_dot = omega_dot * h
+  //
+  // where h_dot, omega_dot and h are all upper-triangular
+  // 3x3 tensors. In Voigt notation, the elements of the
+  // RHS product tensor are:
+  // h_dot = [0*0, 1*1, 2*2, 1*3+3*2, 0*4+5*3+4*2, 0*5+5*1]
+  //
+  // Ordering of operations preserves time symmetry.
+
+  const double dto2 = dto/2.0;
+  const double dto4 = dto/4.0;
+  const double dto8 = dto/8.0;
+
+  // off-diagonal components, first half
+
+  if (pstyle == TRICLINIC) {
+
+    if (p_flag[4]) {
+      expfac = exp(dto8*omega_dot[0]);
+      h[4] *= expfac;
+      h[4] += dto4*(omega_dot[5]*h[3]+omega_dot[4]*h[2]);
+      h[4] *= expfac;
+    }
+
+    if (p_flag[3]) {
+      expfac = exp(dto4*omega_dot[1]);
+      h[3] *= expfac;
+      h[3] += dto2*(omega_dot[3]*h[2]);
+      h[3] *= expfac;
+    }
+
+    if (p_flag[5]) {
+      expfac = exp(dto4*omega_dot[0]);
+      h[5] *= expfac;
+      h[5] += dto2*(omega_dot[5]*h[1]);
+      h[5] *= expfac;
+    }
+
+    if (p_flag[4]) {
+      expfac = exp(dto8*omega_dot[0]);
+      h[4] *= expfac;
+      h[4] += dto4*(omega_dot[5]*h[3]+omega_dot[4]*h[2]);
+      h[4] *= expfac;
+    }
+  }
+
+  // scale diagonal components
+  // scale tilt factors with cell, if set
+
+  if (p_flag[0]) {
+    oldlo = domain->boxlo[0];
+    oldhi = domain->boxhi[0];
+    expfac = exp(dto*omega_dot[0]);
+    domain->boxlo[0] = (oldlo-fixedpoint[0])*expfac + fixedpoint[0];
+    domain->boxhi[0] = (oldhi-fixedpoint[0])*expfac + fixedpoint[0];
+  }
+
+  if (p_flag[1]) {
+    oldlo = domain->boxlo[1];
+    oldhi = domain->boxhi[1];
+    expfac = exp(dto*omega_dot[1]);
+    domain->boxlo[1] = (oldlo-fixedpoint[1])*expfac + fixedpoint[1];
+    domain->boxhi[1] = (oldhi-fixedpoint[1])*expfac + fixedpoint[1];
+    if (scalexy) h[5] *= expfac;
+  }
+
+  if (p_flag[2]) {
+    oldlo = domain->boxlo[2];
+    oldhi = domain->boxhi[2];
+    expfac = exp(dto*omega_dot[2]);
+    domain->boxlo[2] = (oldlo-fixedpoint[2])*expfac + fixedpoint[2];
+    domain->boxhi[2] = (oldhi-fixedpoint[2])*expfac + fixedpoint[2];
+    if (scalexz) h[4] *= expfac;
+    if (scaleyz) h[3] *= expfac;
+  }
+
+  // off-diagonal components, second half
+
+  if (pstyle == TRICLINIC) {
+
+    if (p_flag[4]) {
+      expfac = exp(dto8*omega_dot[0]);
+      h[4] *= expfac;
+      h[4] += dto4*(omega_dot[5]*h[3]+omega_dot[4]*h[2]);
+      h[4] *= expfac;
+    }
+
+    if (p_flag[3]) {
+      expfac = exp(dto4*omega_dot[1]);
+      h[3] *= expfac;
+      h[3] += dto2*(omega_dot[3]*h[2]);
+      h[3] *= expfac;
+    }
+
+    if (p_flag[5]) {
+      expfac = exp(dto4*omega_dot[0]);
+      h[5] *= expfac;
+      h[5] += dto2*(omega_dot[5]*h[1]);
+      h[5] *= expfac;
+    }
+
+    if (p_flag[4]) {
+      expfac = exp(dto8*omega_dot[0]);
+      h[4] *= expfac;
+      h[4] += dto4*(omega_dot[5]*h[3]+omega_dot[4]*h[2]);
+      h[4] *= expfac;
+    }
+
+  }
+
+  domain->yz = h[3];
+  domain->xz = h[4];
+  domain->xy = h[5];
+
+  // tilt factor to cell length ratio can not exceed TILTMAX in one step
+
+  if (domain->yz < -TILTMAX*domain->yprd ||
+      domain->yz > TILTMAX*domain->yprd ||
+      domain->xz < -TILTMAX*domain->xprd ||
+      domain->xz > TILTMAX*domain->xprd ||
+      domain->xy < -TILTMAX*domain->xprd ||
+      domain->xy > TILTMAX*domain->xprd)
+    error->all(FLERR,"Fix npt/nph has tilted box too far in one step - "
+               "periodic cell is too far from equilibrium state");
+
+  domain->set_global_box();
+  domain->set_local_box();
+
+  // convert pertinent atoms and rigid bodies back to box coords
+
+  if (allremap) domain->lamda2x(nlocal);
+  else {
+#if defined (_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & dilate_group_bit)
+        domain->lamda2x(x[i],x[i]);
+  }
+
+  if (nrigid)
+    for (int i = 0; i < nrigid; i++)
+      modify->fix[rfix[i]]->deform(1);
+}
+
+
+/* ----------------------------------------------------------------------
+   perform half-step barostat scaling of velocities
+-----------------------------------------------------------------------*/
+
+void FixNHOMP::nh_v_press()
+{
+  const double factor0 = exp(-dt4*(omega_dot[0]+mtk_term2));
+  const double factor1 = exp(-dt4*(omega_dot[1]+mtk_term2));
+  const double factor2 = exp(-dt4*(omega_dot[2]+mtk_term2));
+  auto * _noalias const v = (dbl3_t *) atom->v[0];
+  const int * _noalias const mask = atom->mask;
+  const int nlocal = (igroup == atom->firstgroup) ? atom->nfirst : atom->nlocal;
+
+  if (which == NOBIAS) {
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+    for (int i = 0; i < nlocal; i++) {
+      if (mask[i] & groupbit) {
+        v[i].x *= factor0;
+        v[i].y *= factor1;
+        v[i].z *= factor2;
+        if (pstyle == TRICLINIC) {
+          v[i].x += -dthalf*(v[i].y*omega_dot[5] + v[i].z*omega_dot[4]);
+          v[i].y += -dthalf*v[i].z*omega_dot[3];
+        }
+        v[i].x *= factor0;
+        v[i].y *= factor1;
+        v[i].z *= factor2;
+      }
+    }
+  } else if (which == BIAS) {
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+    for (int i = 0; i < nlocal; i++) {
+      double buf[3];
+      if (mask[i] & groupbit) {
+        temperature->remove_bias_thr(i,&v[i].x,buf);
+        v[i].x *= factor0;
+        v[i].y *= factor1;
+        v[i].z *= factor2;
+        if (pstyle == TRICLINIC) {
+          v[i].x += -dthalf*(v[i].y*omega_dot[5] + v[i].z*omega_dot[4]);
+          v[i].y += -dthalf*v[i].z*omega_dot[3];
+        }
+        v[i].x *= factor0;
+        v[i].y *= factor1;
+        v[i].z *= factor2;
+        temperature->restore_bias_thr(i,&v[i].x,buf);
+      }
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   perform half-step update of velocities
+-----------------------------------------------------------------------*/
+
+void FixNHOMP::nve_v()
+{
+  auto * _noalias const v = (dbl3_t *) atom->v[0];
+  const auto * _noalias const f = (dbl3_t *) atom->f[0];
+  const int * _noalias const mask = atom->mask;
+  const int nlocal = (igroup == atom->firstgroup) ? atom->nfirst : atom->nlocal;
+
+  if (atom->rmass) {
+    const double * _noalias const rmass = atom->rmass;
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+    for (int i = 0; i < nlocal; i++) {
+      if (mask[i] & groupbit) {
+        const double dtfm = dtf / rmass[i];
+        v[i].x += dtfm*f[i].x;
+        v[i].y += dtfm*f[i].y;
+        v[i].z += dtfm*f[i].z;
+      }
+    }
+  } else {
+    const double *_noalias const mass = atom->mass;
+    const int * _noalias const type = atom->type;
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+    for (int i = 0; i < nlocal; i++) {
+      if (mask[i] & groupbit) {
+        const double dtfm = dtf / mass[type[i]];
+        v[i].x += dtfm*f[i].x;
+        v[i].y += dtfm*f[i].y;
+        v[i].z += dtfm*f[i].z;
+      }
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   perform full-step update of positions
+-----------------------------------------------------------------------*/
+
+void FixNHOMP::nve_x()
+{
+  auto * _noalias const x = (dbl3_t *) atom->x[0];
+  const auto * _noalias const v = (dbl3_t *) atom->v[0];
+  const int * _noalias const mask = atom->mask;
+  const int nlocal = (igroup == atom->firstgroup) ? atom->nfirst : atom->nlocal;
+
+  // x update by full step only for atoms in group
+
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+  for (int i = 0; i < nlocal; i++) {
+    if (mask[i] & groupbit) {
+      x[i].x += dtv * v[i].x;
+      x[i].y += dtv * v[i].y;
+      x[i].z += dtv * v[i].z;
+    }
+  }
+}
+/* ----------------------------------------------------------------------
+   perform half-step thermostat scaling of velocities
+-----------------------------------------------------------------------*/
+
+void FixNHOMP::nh_v_temp()
+{
+  auto * _noalias const v = (dbl3_t *) atom->v[0];
+  const int * _noalias const mask = atom->mask;
+  const int nlocal = (igroup == atom->firstgroup) ? atom->nfirst : atom->nlocal;
+
+  if (which == NOBIAS) {
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+    for (int i = 0; i < nlocal; i++) {
+      if (mask[i] & groupbit) {
+        v[i].x *= factor_eta;
+        v[i].y *= factor_eta;
+        v[i].z *= factor_eta;
+      }
+    }
+  } else if (which == BIAS) {
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+    for (int i = 0; i < nlocal; i++) {
+      double buf[3];
+      if (mask[i] & groupbit) {
+        temperature->remove_bias_thr(i,&v[i].x,buf);
+        v[i].x *= factor_eta;
+        v[i].y *= factor_eta;
+        v[i].z *= factor_eta;
+        temperature->restore_bias_thr(i,&v[i].x,buf);
+      }
+    }
+  }
+}
+
diff -ruN lammps-stable_2Aug2023/src/fix_nh_omp.h ../lammps-stable_2Aug2023/src/fix_nh_omp.h
--- lammps-stable_2Aug2023/src/fix_nh_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nh_omp.h	2023-09-26 15:27:28.371911000 -0400
@@ -0,0 +1,35 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifndef LMP_FIX_NH_OMP_H
+#define LMP_FIX_NH_OMP_H
+
+#include "fix_nh.h"
+
+namespace LAMMPS_NS {
+
+class FixNHOMP : public FixNH {
+ public:
+  FixNHOMP(class LAMMPS *lmp, int narg, char **args) : FixNH(lmp, narg, args){};
+
+ protected:
+  void remap() override;
+  void nh_v_press() override;
+  void nh_v_temp() override;
+  void nve_v() override;
+  void nve_x() override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
diff -ruN lammps-stable_2Aug2023/src/fix_nh_sphere_omp.cpp ../lammps-stable_2Aug2023/src/fix_nh_sphere_omp.cpp
--- lammps-stable_2Aug2023/src/fix_nh_sphere_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nh_sphere_omp.cpp	2023-09-26 15:27:26.539451000 -0400
@@ -0,0 +1,151 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "fix_nh_sphere_omp.h"
+
+#include "atom.h"
+#include "compute.h"
+#include "error.h"
+
+#include "omp_compat.h"
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+enum{NOBIAS,BIAS};
+
+#define INERTIA 0.4          // moment of inertia prefactor for sphere
+
+typedef struct { double x,y,z; } dbl3_t;
+
+/* ---------------------------------------------------------------------- */
+
+FixNHSphereOMP::FixNHSphereOMP(LAMMPS *lmp, int narg, char **arg) :
+  FixNHOMP(lmp, narg, arg)
+{
+  if (!atom->sphere_flag)
+    error->all(FLERR,"Fix nvt/nph/npt sphere requires atom style sphere");
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixNHSphereOMP::init()
+{
+  // check that all particles are finite-size
+  // no point particles allowed
+
+  double *radius = atom->radius;
+  int *mask = atom->mask;
+  int nlocal = atom->nlocal;
+
+  for (int i = 0; i < nlocal; i++)
+    if (mask[i] & groupbit)
+      if (radius[i] == 0.0)
+        error->one(FLERR,"Fix nvt/npt/nph/sphere/omp require extended particles");
+
+  FixNHOMP::init();
+}
+
+/* ----------------------------------------------------------------------
+   perform half-step update of rotational and COM velocities
+-----------------------------------------------------------------------*/
+
+void FixNHSphereOMP::nve_v()
+{
+  auto * _noalias const v = (dbl3_t *) atom->v[0];
+  auto * _noalias const omega = (dbl3_t *) atom->omega[0];
+  const auto * _noalias const f = (dbl3_t *) atom->f[0];
+  const auto * _noalias const torque = (dbl3_t *) atom->torque[0];
+  const double * _noalias const radius = atom->radius;
+  const double * _noalias const rmass = atom->rmass;
+  const int * _noalias const mask = atom->mask;
+
+  // set timestep here since dt may have changed or come via rRESPA
+
+  const double dtfrotate = dtf / INERTIA;
+
+  const int nlocal = (igroup == atom->firstgroup) ? atom->nfirst : atom->nlocal;
+
+  // standard nve_v velocity update. for efficiency the loop is
+  // merged with FixNHOMP instead of calling it for the COM update.
+
+  // update omega for all particles
+  // d_omega/dt = torque / inertia
+  // 4 cases depending on radius vs shape and rmass vs mass
+
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+  for (int i = 0; i < nlocal; i++) {
+    if (mask[i] & groupbit) {
+      const double dtfm = dtf / rmass[i];
+      v[i].x += dtfm*f[i].x;
+      v[i].y += dtfm*f[i].y;
+      v[i].z += dtfm*f[i].z;
+
+      const double dtirotate = dtfrotate / (radius[i]*radius[i]*rmass[i]);
+      omega[i].x += dtirotate*torque[i].x;
+      omega[i].y += dtirotate*torque[i].y;
+      omega[i].z += dtirotate*torque[i].z;
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   perform half-step scaling of rotatonal velocities
+-----------------------------------------------------------------------*/
+
+void FixNHSphereOMP::nh_v_temp()
+{
+  auto * _noalias const v = (dbl3_t *) atom->v[0];
+  auto * _noalias const omega = (dbl3_t *) atom->omega[0];
+  const int * _noalias const mask = atom->mask;
+  const int nlocal = (igroup == atom->firstgroup) ? atom->nfirst : atom->nlocal;
+
+  if (which == NOBIAS) {
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+    for (int i = 0; i < nlocal; i++) {
+      if (mask[i] & groupbit) {
+        v[i].x *= factor_eta;
+        v[i].y *= factor_eta;
+        v[i].z *= factor_eta;
+        omega[i].x *= factor_eta;
+        omega[i].y *= factor_eta;
+        omega[i].z *= factor_eta;
+      }
+    }
+  } else if (which == BIAS) {
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+    for (int i = 0; i < nlocal; i++) {
+      double buf[3];
+      if (mask[i] & groupbit) {
+        temperature->remove_bias_thr(i,&v[i].x,buf);
+        v[i].x *= factor_eta;
+        v[i].y *= factor_eta;
+        v[i].z *= factor_eta;
+        temperature->restore_bias_thr(i,&v[i].x,buf);
+        omega[i].x *= factor_eta;
+        omega[i].y *= factor_eta;
+        omega[i].z *= factor_eta;
+      }
+    }
+  }
+}
diff -ruN lammps-stable_2Aug2023/src/fix_nh_sphere_omp.h ../lammps-stable_2Aug2023/src/fix_nh_sphere_omp.h
--- lammps-stable_2Aug2023/src/fix_nh_sphere_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nh_sphere_omp.h	2023-09-26 15:27:28.376315000 -0400
@@ -0,0 +1,34 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifndef LMP_FIX_NH_SPHERE_OMP_H
+#define LMP_FIX_NH_SPHERE_OMP_H
+
+#include "fix_nh_omp.h"
+
+namespace LAMMPS_NS {
+
+class FixNHSphereOMP : public FixNHOMP {
+ public:
+  FixNHSphereOMP(class LAMMPS *, int, char **);
+
+  void init() override;
+
+ protected:
+  void nve_v() override;
+  void nh_v_temp() override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
diff -ruN lammps-stable_2Aug2023/src/fix_nph_omp.cpp ../lammps-stable_2Aug2023/src/fix_nph_omp.cpp
--- lammps-stable_2Aug2023/src/fix_nph_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nph_omp.cpp	2023-09-26 15:27:26.546651000 -0400
@@ -0,0 +1,49 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "fix_nph_omp.h"
+
+#include "error.h"
+#include "modify.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+/* ---------------------------------------------------------------------- */
+
+FixNPHOMP::FixNPHOMP(LAMMPS *lmp, int narg, char **arg) :
+  FixNHOMP(lmp, narg, arg)
+{
+  if (tstat_flag)
+    error->all(FLERR,"Temperature control can not be used with fix nph/omp");
+  if (!pstat_flag)
+    error->all(FLERR,"Pressure control must be used with fix nph/omp");
+
+  // create a new compute temp style
+  // id = fix-ID + temp
+  // compute group = all since pressure is always global (group all)
+  // and thus its KE/temperature contribution should use group all
+
+  id_temp = utils::strdup(std::string(id) + "_temp");
+  modify->add_compute(fmt::format("{} all temp",id_temp));
+  tcomputeflag = 1;
+
+  // create a new compute pressure style
+  // id = fix-ID + press, compute group = all
+  // pass id_temp as 4th arg to pressure constructor
+
+  id_press = utils::strdup(std::string(id) + "_press");
+  modify->add_compute(fmt::format("{} all pressure {}",id_press, id_temp));
+  pcomputeflag = 1;
+}
diff -ruN lammps-stable_2Aug2023/src/fix_nph_omp.h ../lammps-stable_2Aug2023/src/fix_nph_omp.h
--- lammps-stable_2Aug2023/src/fix_nph_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nph_omp.h	2023-09-26 15:27:28.382823000 -0400
@@ -0,0 +1,35 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+// clang-format off
+FixStyle(nph/omp,FixNPHOMP);
+// clang-format on
+#else
+
+#ifndef LMP_FIX_NPH_OMP_H
+#define LMP_FIX_NPH_OMP_H
+
+#include "fix_nh_omp.h"
+
+namespace LAMMPS_NS {
+
+class FixNPHOMP : public FixNHOMP {
+ public:
+  FixNPHOMP(class LAMMPS *, int, char **);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/fix_nph_sphere_omp.cpp ../lammps-stable_2Aug2023/src/fix_nph_sphere_omp.cpp
--- lammps-stable_2Aug2023/src/fix_nph_sphere_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nph_sphere_omp.cpp	2023-09-26 15:27:26.551053000 -0400
@@ -0,0 +1,49 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "fix_nph_sphere_omp.h"
+
+#include "error.h"
+#include "modify.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+/* ---------------------------------------------------------------------- */
+
+FixNPHSphereOMP::FixNPHSphereOMP(LAMMPS *lmp, int narg, char **arg) :
+  FixNHSphereOMP(lmp, narg, arg)
+{
+  if (tstat_flag)
+    error->all(FLERR,"Temperature control can not be used with fix nph/sphere/omp");
+  if (!pstat_flag)
+    error->all(FLERR,"Pressure control must be used with fix nph/sphere/omp");
+
+  // create a new compute temp style
+  // id = fix-ID + temp
+  // compute group = all since pressure is always global (group all)
+  // and thus its KE/temperature contribution should use group all
+
+  id_temp = utils::strdup(std::string(id) + "_temp");
+  modify->add_compute(fmt::format("{} all temp/sphere",id_temp));
+  tcomputeflag = 1;
+
+  // create a new compute pressure style
+  // id = fix-ID + press, compute group = all
+  // pass id_temp as 4th arg to pressure constructor
+
+  id_press = utils::strdup(std::string(id) + "_press");
+  modify->add_compute(fmt::format("{} all pressure {}",id_press, id_temp));
+  pcomputeflag = 1;
+}
diff -ruN lammps-stable_2Aug2023/src/fix_nph_sphere_omp.h ../lammps-stable_2Aug2023/src/fix_nph_sphere_omp.h
--- lammps-stable_2Aug2023/src/fix_nph_sphere_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nph_sphere_omp.h	2023-09-26 15:27:28.387079000 -0400
@@ -0,0 +1,35 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+// clang-format off
+FixStyle(nph/sphere/omp,FixNPHSphereOMP);
+// clang-format on
+#else
+
+#ifndef LMP_FIX_NPH_SPHERE_OMP_H
+#define LMP_FIX_NPH_SPHERE_OMP_H
+
+#include "fix_nh_sphere_omp.h"
+
+namespace LAMMPS_NS {
+
+class FixNPHSphereOMP : public FixNHSphereOMP {
+ public:
+  FixNPHSphereOMP(class LAMMPS *, int, char **);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/fix_npt_omp.cpp ../lammps-stable_2Aug2023/src/fix_npt_omp.cpp
--- lammps-stable_2Aug2023/src/fix_npt_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_npt_omp.cpp	2023-09-26 15:27:26.557708000 -0400
@@ -0,0 +1,49 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "fix_npt_omp.h"
+
+#include "error.h"
+#include "modify.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+/* ---------------------------------------------------------------------- */
+
+FixNPTOMP::FixNPTOMP(LAMMPS *lmp, int narg, char **arg) :
+  FixNHOMP(lmp, narg, arg)
+{
+  if (!tstat_flag)
+    error->all(FLERR,"Temperature control must be used with fix npt/omp");
+  if (!pstat_flag)
+    error->all(FLERR,"Pressure control must be used with fix npt/omp");
+
+  // create a new compute temp style
+  // id = fix-ID + temp
+  // compute group = all since pressure is always global (group all)
+  // and thus its KE/temperature contribution should use group all
+
+  id_temp = utils::strdup(std::string(id) + "_temp");
+  modify->add_compute(fmt::format("{} all temp",id_temp));
+  tcomputeflag = 1;
+
+  // create a new compute pressure style
+  // id = fix-ID + press, compute group = all
+  // pass id_temp as 4th arg to pressure constructor
+
+  id_press = utils::strdup(std::string(id) + "_press");
+  modify->add_compute(fmt::format("{} all pressure {}",id_press, id_temp));
+  pcomputeflag = 1;
+}
diff -ruN lammps-stable_2Aug2023/src/fix_npt_omp.h ../lammps-stable_2Aug2023/src/fix_npt_omp.h
--- lammps-stable_2Aug2023/src/fix_npt_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_npt_omp.h	2023-09-26 15:27:28.401834000 -0400
@@ -0,0 +1,35 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+// clang-format off
+FixStyle(npt/omp,FixNPTOMP);
+// clang-format on
+#else
+
+#ifndef LMP_FIX_NPT_OMP_H
+#define LMP_FIX_NPT_OMP_H
+
+#include "fix_nh_omp.h"
+
+namespace LAMMPS_NS {
+
+class FixNPTOMP : public FixNHOMP {
+ public:
+  FixNPTOMP(class LAMMPS *, int, char **);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/fix_npt_sphere_omp.cpp ../lammps-stable_2Aug2023/src/fix_npt_sphere_omp.cpp
--- lammps-stable_2Aug2023/src/fix_npt_sphere_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_npt_sphere_omp.cpp	2023-09-26 15:27:26.561976000 -0400
@@ -0,0 +1,49 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "fix_npt_sphere_omp.h"
+
+#include "error.h"
+#include "modify.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+/* ---------------------------------------------------------------------- */
+
+FixNPTSphereOMP::FixNPTSphereOMP(LAMMPS *lmp, int narg, char **arg) :
+  FixNHSphereOMP(lmp, narg, arg)
+{
+  if (!tstat_flag)
+    error->all(FLERR,"Temperature control must be used with fix npt/sphere/omp");
+  if (!pstat_flag)
+    error->all(FLERR,"Pressure control must be used with fix npt/sphere/omp");
+
+  // create a new compute temp style
+  // id = fix-ID + temp
+  // compute group = all since pressure is always global (group all)
+  // and thus its KE/temperature contribution should use group all
+
+  id_temp = utils::strdup(std::string(id) + "_temp");
+  modify->add_compute(fmt::format("{} all temp/sphere",id_temp));
+  tcomputeflag = 1;
+
+  // create a new compute pressure style
+  // id = fix-ID + press, compute group = all
+  // pass id_temp as 4th arg to pressure constructor
+
+  id_press = utils::strdup(std::string(id) + "_press");
+  modify->add_compute(fmt::format("{} all pressure {}",id_press, id_temp));
+  pcomputeflag = 1;
+}
diff -ruN lammps-stable_2Aug2023/src/fix_npt_sphere_omp.h ../lammps-stable_2Aug2023/src/fix_npt_sphere_omp.h
--- lammps-stable_2Aug2023/src/fix_npt_sphere_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_npt_sphere_omp.h	2023-09-26 15:27:28.406205000 -0400
@@ -0,0 +1,35 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+// clang-format off
+FixStyle(npt/sphere/omp,FixNPTSphereOMP);
+// clang-format on
+#else
+
+#ifndef LMP_FIX_NPT_SPHERE_OMP_H
+#define LMP_FIX_NPT_SPHERE_OMP_H
+
+#include "fix_nh_sphere_omp.h"
+
+namespace LAMMPS_NS {
+
+class FixNPTSphereOMP : public FixNHSphereOMP {
+ public:
+  FixNPTSphereOMP(class LAMMPS *, int, char **);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/fix_nve_omp.cpp ../lammps-stable_2Aug2023/src/fix_nve_omp.cpp
--- lammps-stable_2Aug2023/src/fix_nve_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nve_omp.cpp	2023-09-26 15:27:26.566397000 -0400
@@ -0,0 +1,117 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "fix_nve_omp.h"
+#include "atom.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+typedef struct { double x,y,z; } dbl3_t;
+
+/* ---------------------------------------------------------------------- */
+
+FixNVEOMP::FixNVEOMP(LAMMPS *lmp, int narg, char **arg) :
+  FixNVE(lmp, narg, arg) { }
+
+/* ----------------------------------------------------------------------
+   allow for both per-type and per-atom mass
+------------------------------------------------------------------------- */
+
+void FixNVEOMP::initial_integrate(int /* vflag */)
+{
+  // update v and x of atoms in group
+
+  auto * _noalias const x = (dbl3_t *) atom->x[0];
+  auto * _noalias const v = (dbl3_t *) atom->v[0];
+  const auto * _noalias const f = (dbl3_t *) atom->f[0];
+  const int * const mask = atom->mask;
+  const int nlocal = (igroup == atom->firstgroup) ? atom->nfirst : atom->nlocal;
+
+  if (atom->rmass) {
+    const double * const rmass = atom->rmass;
+#if defined (_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) {
+        const double dtfm = dtf / rmass[i];
+        v[i].x += dtfm * f[i].x;
+        v[i].y += dtfm * f[i].y;
+        v[i].z += dtfm * f[i].z;
+        x[i].x += dtv * v[i].x;
+        x[i].y += dtv * v[i].y;
+        x[i].z += dtv * v[i].z;
+      }
+
+  } else {
+    const double * const mass = atom->mass;
+    const int * const type = atom->type;
+#if defined (_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) {
+        const double dtfm = dtf / mass[type[i]];
+        v[i].x += dtfm * f[i].x;
+        v[i].y += dtfm * f[i].y;
+        v[i].z += dtfm * f[i].z;
+        x[i].x += dtv * v[i].x;
+        x[i].y += dtv * v[i].y;
+        x[i].z += dtv * v[i].z;
+      }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixNVEOMP::final_integrate()
+{
+  // update v of atoms in group
+
+  auto * _noalias const v = (dbl3_t *) atom->v[0];
+  const auto * _noalias const f = (dbl3_t *) atom->f[0];
+  const int * const mask = atom->mask;
+  const int nlocal = (igroup == atom->firstgroup) ? atom->nfirst : atom->nlocal;
+
+  if (atom->rmass) {
+    const double * const rmass = atom->rmass;
+#if defined (_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) {
+        const double dtfm = dtf / rmass[i];
+        v[i].x += dtfm * f[i].x;
+        v[i].y += dtfm * f[i].y;
+        v[i].z += dtfm * f[i].z;
+      }
+
+  } else {
+    const double * const mass = atom->mass;
+    const int * const type = atom->type;
+#if defined (_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE schedule(static)
+#endif
+    for (int i = 0; i < nlocal; i++)
+      if (mask[i] & groupbit) {
+        const double dtfm = dtf / mass[type[i]];
+        v[i].x += dtfm * f[i].x;
+        v[i].y += dtfm * f[i].y;
+        v[i].z += dtfm * f[i].z;
+      }
+  }
+}
+
diff -ruN lammps-stable_2Aug2023/src/fix_nve_omp.h ../lammps-stable_2Aug2023/src/fix_nve_omp.h
--- lammps-stable_2Aug2023/src/fix_nve_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nve_omp.h	2023-09-26 15:27:28.410409000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+// clang-format off
+FixStyle(nve/omp,FixNVEOMP);
+// clang-format on
+#else
+
+#ifndef LMP_FIX_NVE_OMP_H
+#define LMP_FIX_NVE_OMP_H
+
+#include "fix_nve.h"
+
+namespace LAMMPS_NS {
+
+class FixNVEOMP : public FixNVE {
+ public:
+  FixNVEOMP(class LAMMPS *, int, char **);
+
+  void initial_integrate(int) override;
+  void final_integrate() override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/fix_nve_sphere_omp.cpp ../lammps-stable_2Aug2023/src/fix_nve_sphere_omp.cpp
--- lammps-stable_2Aug2023/src/fix_nve_sphere_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nve_sphere_omp.cpp	2023-10-05 00:57:57.881607910 -0400
@@ -0,0 +1,245 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "fix_nve_sphere_omp.h"
+
+#include "atom.h"
+#include "force.h"
+#include "math_extra.h"
+
+#include <cmath>
+
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+using namespace MathExtra;
+
+#define INERTIA 0.4          // moment of inertia prefactor for sphere
+
+enum{NONE,DIPOLE};
+enum{NODLM,DLM};
+
+/* ---------------------------------------------------------------------- */
+
+/* ---------------------------------------------------------------------- */
+
+void FixNVESphereOMP::initial_integrate(int /* vflag */)
+{
+  double * const * const x = atom->x;
+  double * const * const v = atom->v;
+  const double * const * const f = atom->f;
+  double * const * const omega = atom->omega;
+  const double * const * const torque = atom->torque;
+  const double * const radius = atom->radius;
+  const double * const rmass = atom->rmass;
+  const int * const mask = atom->mask;
+  const int nlocal = (igroup == atom->firstgroup) ? atom->nfirst : atom->nlocal;
+
+  // set timestep here since dt may have changed or come via rRESPA
+  const double dtfrotate = dtf / INERTIA;
+
+  // update v,x,omega for all particles
+  // d_omega/dt = torque / inertia
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE
+#endif
+  for (int i = 0; i < nlocal; i++) {
+    if (mask[i] & groupbit) {
+      const double dtfm = dtf / rmass[i];
+      v[i][0] += dtfm * f[i][0];
+      v[i][1] += dtfm * f[i][1];
+      v[i][2] += dtfm * f[i][2];
+      x[i][0] += dtv * v[i][0];
+      x[i][1] += dtv * v[i][1];
+      x[i][2] += dtv * v[i][2];
+
+      const double dtirotate = dtfrotate / (radius[i]*radius[i]*rmass[i]);
+      omega[i][0] += dtirotate * torque[i][0];
+      omega[i][1] += dtirotate * torque[i][1];
+      omega[i][2] += dtirotate * torque[i][2];
+    }
+  }
+
+  // update mu for dipoles
+  // d_mu/dt = omega cross mu
+  // renormalize mu to dipole length
+
+  if (extra == DIPOLE) {
+    double * const * const mu = atom->mu;
+    if (dlm == NODLM) {
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE
+#endif
+      for (int i = 0; i < nlocal; i++) {
+        double g0,g1,g2,msq,scale;
+        if (mask[i] & groupbit) {
+          if (mu[i][3] > 0.0) {
+            g0 = mu[i][0] + dtv * (omega[i][1]*mu[i][2]-omega[i][2]*mu[i][1]);
+            g1 = mu[i][1] + dtv * (omega[i][2]*mu[i][0]-omega[i][0]*mu[i][2]);
+            g2 = mu[i][2] + dtv * (omega[i][0]*mu[i][1]-omega[i][1]*mu[i][0]);
+            msq = g0*g0 + g1*g1 + g2*g2;
+            scale = mu[i][3]/sqrt(msq);
+            mu[i][0] = g0*scale;
+            mu[i][1] = g1*scale;
+            mu[i][2] = g2*scale;
+          }
+        }
+      }
+
+    } else {
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE
+#endif
+      // Integrate orientation following Dullweber-Leimkuhler-Maclachlan scheme
+      for (int i = 0; i < nlocal; i++) {
+        double w[3], w_temp[3], a[3];
+        double Q[3][3], Q_temp[3][3], R[3][3];
+
+        if (mask[i] & groupbit && mu[i][3] > 0.0) {
+
+          // Construct Q from dipole:
+          // Q is the rotation matrix from space frame to body frame
+          // i.e. v_b = Q.v_s
+
+          // Define mu to lie along the z axis in the body frame
+          // We take the unit dipole to avoid getting a scaling matrix
+          const double inv_len_mu = 1.0/mu[i][3];
+          a[0] = mu[i][0]*inv_len_mu;
+          a[1] = mu[i][1]*inv_len_mu;
+          a[2] = mu[i][2]*inv_len_mu;
+
+          // v = a x [0 0 1] - cross product of mu in space and body frames
+          // s = |v|
+          // c = a.[0 0 1] = a[2]
+          // vx = [ 0    -v[2]  v[1]
+          //        v[2]  0    -v[0]
+          //       -v[1]  v[0]  0    ]
+          // then
+          // Q = I + vx + vx^2 * (1-c)/s^2
+
+          const double s2 = a[0]*a[0] + a[1]*a[1];
+          if (s2 != 0.0) { // i.e. the vectors are not parallel
+            const double scale = (1.0 - a[2])/s2;
+
+            Q[0][0] = 1.0 - scale*a[0]*a[0]; Q[0][1] = -scale*a[0]*a[1];      Q[0][2] = -a[0];
+            Q[1][0] = -scale*a[0]*a[1];      Q[1][1] = 1.0 - scale*a[1]*a[1]; Q[1][2] = -a[1];
+            Q[2][0] = a[0];                  Q[2][1] = a[1];                  Q[2][2] = 1.0 - scale*(a[0]*a[0] + a[1]*a[1]);
+          } else { // if parallel then we just have I or -I
+            Q[0][0] = 1.0/a[2];  Q[0][1] = 0.0;       Q[0][2] = 0.0;
+            Q[1][0] = 0.0;       Q[1][1] = 1.0/a[2];  Q[1][2] = 0.0;
+            Q[2][0] = 0.0;       Q[2][1] = 0.0;       Q[2][2] = 1.0/a[2];
+          }
+
+          // Local copy of this particle's angular velocity (in space frame)
+          w[0] = omega[i][0]; w[1] = omega[i][1]; w[2] = omega[i][2];
+
+          // Transform omega into body frame: w_temp= Q.w
+          matvec(Q,w,w_temp);
+
+          // Construct rotation R1
+          BuildRxMatrix(R, dtf/force->ftm2v*w_temp[0]);
+
+          // Apply R1 to w: w = R.w_temp
+          matvec(R,w_temp,w);
+
+          // Apply R1 to Q: Q_temp = R^T.Q
+          transpose_times3(R,Q,Q_temp);
+
+          // Construct rotation R2
+          BuildRyMatrix(R, dtf/force->ftm2v*w[1]);
+
+          // Apply R2 to w: w_temp = R.w
+          matvec(R,w,w_temp);
+
+          // Apply R2 to Q: Q = R^T.Q_temp
+          transpose_times3(R,Q_temp,Q);
+
+          // Construct rotation R3
+          BuildRzMatrix(R, 2.0*dtf/force->ftm2v*w_temp[2]);
+
+          // Apply R3 to w: w = R.w_temp
+          matvec(R,w_temp,w);
+
+          // Apply R3 to Q: Q_temp = R^T.Q
+          transpose_times3(R,Q,Q_temp);
+
+          // Construct rotation R4
+          BuildRyMatrix(R, dtf/force->ftm2v*w[1]);
+
+          // Apply R4 to w: w_temp = R.w
+          matvec(R,w,w_temp);
+
+          // Apply R4 to Q: Q = R^T.Q_temp
+          transpose_times3(R,Q_temp,Q);
+
+          // Construct rotation R5
+          BuildRxMatrix(R, dtf/force->ftm2v*w_temp[0]);
+
+          // Apply R5 to w: w = R.w_temp
+          matvec(R,w_temp,w);
+
+          // Apply R5 to Q: Q_temp = R^T.Q
+          transpose_times3(R,Q,Q_temp);
+
+          // Transform w back into space frame w_temp = Q^T.w
+          transpose_matvec(Q_temp,w,w_temp);
+          omega[i][0] = w_temp[0]; omega[i][1] = w_temp[1]; omega[i][2] = w_temp[2];
+
+          // Set dipole according to updated Q: mu = Q^T.[0 0 1] * |mu|
+          mu[i][0] = Q_temp[2][0] * mu[i][3];
+          mu[i][1] = Q_temp[2][1] * mu[i][3];
+          mu[i][2] = Q_temp[2][2] * mu[i][3];
+        }
+      }
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixNVESphereOMP::final_integrate()
+{
+  double * const * const v = atom->v;
+  const double * const * const f = atom->f;
+  double * const * const omega = atom->omega;
+  const double * const * const torque = atom->torque;
+  const double * const rmass = atom->rmass;
+  const double * const radius = atom->radius;
+  const int * const mask = atom->mask;
+  const int nlocal = (igroup == atom->firstgroup) ? atom->nfirst : atom->nlocal;
+
+  // set timestep here since dt may have changed or come via rRESPA
+
+  const double dtfrotate = dtf / INERTIA;
+
+  // update v,omega for all particles
+  // d_omega/dt = torque / inertia
+
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE
+#endif
+  for (int i = 0; i < nlocal; i++)
+    if (mask[i] & groupbit) {
+      const double dtfm = dtf / rmass[i];
+      v[i][0] += dtfm * f[i][0];
+      v[i][1] += dtfm * f[i][1];
+      v[i][2] += dtfm * f[i][2];
+
+      const double dtirotate = dtfrotate / (radius[i]*radius[i]*rmass[i]);
+      omega[i][0] += dtirotate * torque[i][0];
+      omega[i][1] += dtirotate * torque[i][1];
+      omega[i][2] += dtirotate * torque[i][2];
+    }
+}
diff -ruN lammps-stable_2Aug2023/src/fix_nve_sphere_omp.h ../lammps-stable_2Aug2023/src/fix_nve_sphere_omp.h
--- lammps-stable_2Aug2023/src/fix_nve_sphere_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nve_sphere_omp.h	2023-09-26 15:27:28.414625000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+// clang-format off
+FixStyle(nve/sphere/omp,FixNVESphereOMP);
+// clang-format on
+#else
+
+#ifndef LMP_FIX_NVE_SPHERE_OMP_H
+#define LMP_FIX_NVE_SPHERE_OMP_H
+
+#include "fix_nve_sphere.h"
+
+namespace LAMMPS_NS {
+
+class FixNVESphereOMP : public FixNVESphere {
+ public:
+  FixNVESphereOMP(class LAMMPS *lmp, int narg, char **arg) : FixNVESphere(lmp, narg, arg){};
+
+  void initial_integrate(int) override;
+  void final_integrate() override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/fix_nvt_omp.cpp ../lammps-stable_2Aug2023/src/fix_nvt_omp.cpp
--- lammps-stable_2Aug2023/src/fix_nvt_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nvt_omp.cpp	2023-09-26 15:27:26.590478000 -0400
@@ -0,0 +1,40 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "fix_nvt_omp.h"
+
+#include "error.h"
+#include "group.h"
+#include "modify.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+/* ---------------------------------------------------------------------- */
+
+FixNVTOMP::FixNVTOMP(LAMMPS *lmp, int narg, char **arg) :
+  FixNHOMP(lmp, narg, arg)
+{
+  if (!tstat_flag)
+    error->all(FLERR,"Temperature control must be used with fix nvt/omp");
+  if (pstat_flag)
+    error->all(FLERR,"Pressure control can not be used with fix nvt/omp");
+
+  // create a new compute temp style
+  // id = fix-ID + temp
+
+  id_temp = utils::strdup(std::string(id)+"_temp");
+  modify->add_compute(fmt::format("{} {} temp",id_temp,group->names[igroup]));
+  tcomputeflag = 1;
+}
diff -ruN lammps-stable_2Aug2023/src/fix_nvt_omp.h ../lammps-stable_2Aug2023/src/fix_nvt_omp.h
--- lammps-stable_2Aug2023/src/fix_nvt_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nvt_omp.h	2023-09-26 15:27:28.421263000 -0400
@@ -0,0 +1,35 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+// clang-format off
+FixStyle(nvt/omp,FixNVTOMP);
+// clang-format on
+#else
+
+#ifndef LMP_FIX_NVT_OMP_H
+#define LMP_FIX_NVT_OMP_H
+
+#include "fix_nh_omp.h"
+
+namespace LAMMPS_NS {
+
+class FixNVTOMP : public FixNHOMP {
+ public:
+  FixNVTOMP(class LAMMPS *, int, char **);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/fix_nvt_sllod_omp.cpp ../lammps-stable_2Aug2023/src/fix_nvt_sllod_omp.cpp
--- lammps-stable_2Aug2023/src/fix_nvt_sllod_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nvt_sllod_omp.cpp	2023-09-26 15:27:26.601130000 -0400
@@ -0,0 +1,139 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/
+   LAMMPS development team: developers@lammps.org, Sandia National Laboratories
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "fix_nvt_sllod_omp.h"
+
+#include "atom.h"
+#include "compute.h"
+#include "domain.h"
+#include "error.h"
+#include "fix.h"
+#include "fix_deform.h"
+#include "group.h"
+#include "math_extra.h"
+#include "modify.h"
+
+#include <cstring>
+
+#include "omp_compat.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+typedef struct { double x,y,z; } dbl3_t;
+
+/* ---------------------------------------------------------------------- */
+
+FixNVTSllodOMP::FixNVTSllodOMP(LAMMPS *lmp, int narg, char **arg) :
+  FixNHOMP(lmp, narg, arg)
+{
+  if (!tstat_flag)
+    error->all(FLERR,"Temperature control must be used with fix nvt/sllod/omp");
+  if (pstat_flag)
+    error->all(FLERR,"Pressure control can not be used with fix nvt/sllod/omp");
+
+  // default values
+
+  psllod_flag = 0;
+  if (mtchain_default_flag) mtchain = 1;
+
+  // select SLLOD/p-SLLOD/g-SLLOD variant
+
+  int iarg = 3;
+
+  while (iarg < narg) {
+    if (strcmp(arg[iarg],"psllod") == 0) {
+      if (iarg+2 > narg) utils::missing_cmd_args(FLERR, "fix nvt/sllod/omp psllod", error);
+      psllod_flag = utils::logical(FLERR,arg[iarg+1],false,lmp);
+      iarg += 2;
+    } else iarg++;
+  }
+
+  // create a new compute temp style
+  // id = fix-ID + temp
+
+  id_temp = utils::strdup(std::string(id) + "_temp");
+  modify->add_compute(fmt::format("{} {} temp/deform",id_temp,group->names[igroup]));
+  tcomputeflag = 1;
+  nondeformbias = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixNVTSllodOMP::init()
+{
+  FixNHOMP::init();
+
+  if (!temperature->tempbias)
+    error->all(FLERR,"Temperature for fix nvt/sllod/omp does not have a bias");
+
+  nondeformbias = 0;
+  if (strcmp(temperature->style,"temp/deform") != 0) nondeformbias = 1;
+
+  // check fix deform remap settings
+
+  auto deform = modify->get_fix_by_style("^deform");
+  if (deform.size() < 1) error->all(FLERR,"Using fix nvt/sllod/omp with no fix deform defined");
+
+  for (auto ifix : deform) {
+    auto f = dynamic_cast<FixDeform *>(ifix);
+    if (f && (f->remapflag != Domain::V_REMAP))
+      error->all(FLERR,"Using fix nvt/sllod/omp with inconsistent fix deform remap option");
+  }
+}
+
+/* ----------------------------------------------------------------------
+   perform half-step scaling of velocities
+-----------------------------------------------------------------------*/
+
+void FixNVTSllodOMP::nh_v_temp()
+{
+  // remove and restore bias = streaming velocity = Hrate*lamda + Hratelo
+  // thermostat thermal velocity only
+  // vdelu = SLLOD correction = Hrate*Hinv*vthermal
+  // for non temp/deform BIAS:
+  //   calculate temperature since some computes require temp
+  //   computed on current nlocal atoms to remove bias
+
+  auto * _noalias const v = (dbl3_t *) atom->v[0];
+  const int * _noalias const mask = atom->mask;
+  const int nlocal = (igroup == atom->firstgroup) ? atom->nfirst : atom->nlocal;
+
+  if (nondeformbias) temperature->compute_scalar();
+
+  double h_two[6];
+  MathExtra::multiply_shape_shape(domain->h_rate,domain->h_inv,h_two);
+
+#if defined(_OPENMP)
+#pragma omp parallel for LMP_DEFAULT_NONE LMP_SHARED(h_two) schedule(static)
+#endif
+  for (int i = 0; i < nlocal; i++) {
+    double vdelu0,vdelu1,vdelu2,buf[3];
+    if (mask[i] & groupbit) {
+      if (!psllod_flag) temperature->remove_bias_thr(i,&v[i].x,buf);
+      vdelu0 = h_two[0]*v[i].x + h_two[5]*v[i].y + h_two[4]*v[i].z;
+      vdelu1 = h_two[1]*v[i].y + h_two[3]*v[i].z;
+      vdelu2 = h_two[2]*v[i].z;
+      if (psllod_flag) temperature->remove_bias_thr(i,&v[i].x,buf);
+      v[i].x = v[i].x*factor_eta - dthalf*vdelu0;
+      v[i].y = v[i].y*factor_eta - dthalf*vdelu1;
+      v[i].z = v[i].z*factor_eta - dthalf*vdelu2;
+      temperature->restore_bias_thr(i,&v[i].x,buf);
+    }
+  }
+}
diff -ruN lammps-stable_2Aug2023/src/fix_nvt_sllod_omp.h ../lammps-stable_2Aug2023/src/fix_nvt_sllod_omp.h
--- lammps-stable_2Aug2023/src/fix_nvt_sllod_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nvt_sllod_omp.h	2023-09-26 15:27:28.425484000 -0400
@@ -0,0 +1,42 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+// clang-format off
+FixStyle(nvt/sllod/omp,FixNVTSllodOMP);
+// clang-format on
+#else
+
+#ifndef LMP_FIX_NVT_SLLOD_OMP_H
+#define LMP_FIX_NVT_SLLOD_OMP_H
+
+#include "fix_nh_omp.h"
+
+namespace LAMMPS_NS {
+
+class FixNVTSllodOMP : public FixNHOMP {
+ public:
+  FixNVTSllodOMP(class LAMMPS *, int, char **);
+  void init() override;
+
+ private:
+  int nondeformbias;
+  int psllod_flag;     // 0 for SLLOD, 1 for p-SLLOD
+
+  void nh_v_temp() override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/fix_nvt_sphere_omp.cpp ../lammps-stable_2Aug2023/src/fix_nvt_sphere_omp.cpp
--- lammps-stable_2Aug2023/src/fix_nvt_sphere_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nvt_sphere_omp.cpp	2023-09-26 15:27:26.605633000 -0400
@@ -0,0 +1,41 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "fix_nvt_sphere_omp.h"
+
+#include "error.h"
+#include "group.h"
+#include "modify.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+/* ---------------------------------------------------------------------- */
+
+FixNVTSphereOMP::FixNVTSphereOMP(LAMMPS *lmp, int narg, char **arg) :
+  FixNHSphereOMP(lmp, narg, arg)
+{
+  if (!tstat_flag)
+    error->all(FLERR,"Temperature control must be used with fix nvt/sphere/omp");
+  if (pstat_flag)
+    error->all(FLERR,"Pressure control can not be used with fix nvt/sphere/omp");
+
+  // create a new compute temp style
+  // id = fix-ID + temp
+
+  id_temp = utils::strdup(std::string(id) + "_temp");
+  modify->add_compute(fmt::format("{} {} temp/sphere",
+                                  id_temp,group->names[igroup]));
+  tcomputeflag = 1;
+}
diff -ruN lammps-stable_2Aug2023/src/fix_nvt_sphere_omp.h ../lammps-stable_2Aug2023/src/fix_nvt_sphere_omp.h
--- lammps-stable_2Aug2023/src/fix_nvt_sphere_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_nvt_sphere_omp.h	2023-09-26 15:27:28.429769000 -0400
@@ -0,0 +1,35 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+// clang-format off
+FixStyle(nvt/sphere/omp,FixNVTSphereOMP);
+// clang-format on
+#else
+
+#ifndef LMP_FIX_NVT_SPHERE_OMP_H
+#define LMP_FIX_NVT_SPHERE_OMP_H
+
+#include "fix_nh_sphere_omp.h"
+
+namespace LAMMPS_NS {
+
+class FixNVTSphereOMP : public FixNHSphereOMP {
+ public:
+  FixNVTSphereOMP(class LAMMPS *, int, char **);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/fix_omp.cpp ../lammps-stable_2Aug2023/src/fix_omp.cpp
--- lammps-stable_2Aug2023/src/fix_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_omp.cpp	2023-09-26 15:27:26.620742000 -0400
@@ -0,0 +1,333 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+   OpenMP based threading support for LAMMPS
+------------------------------------------------------------------------- */
+
+#include "fix_omp.h"
+#include "thr_data.h"
+
+#include "atom.h"
+#include "comm.h"
+#include "error.h"
+#include "force.h"
+#include "neighbor.h"
+#include "universe.h"
+#include "update.h"
+
+#include "pair_hybrid.h"
+#include "bond_hybrid.h"
+#include "angle_hybrid.h"
+#include "dihedral_hybrid.h"
+#include "improper_hybrid.h"
+#include "kspace.h"
+
+#include <cstring>
+
+#include "omp_compat.h"
+#if defined(_OPENMP)
+#include <omp.h>
+#endif
+
+
+#include "suffix.h"
+
+using namespace LAMMPS_NS;
+using namespace FixConst;
+
+static int get_tid()
+{
+  int tid = 0;
+#if defined(_OPENMP)
+  tid = omp_get_thread_num();
+#endif
+  return tid;
+}
+
+/* ---------------------------------------------------------------------- */
+
+FixOMP::FixOMP(LAMMPS *lmp, int narg, char **arg)
+  :  Fix(lmp, narg, arg),
+     thr(nullptr), last_omp_style(nullptr), last_pair_hybrid(nullptr),
+     _nthr(-1), _neighbor(true), _mixed(false), _reduced(true),
+     _pair_compute_flag(false), _kspace_compute_flag(false)
+{
+  if (narg < 4) error->all(FLERR,"Illegal package omp command");
+
+  int nthreads = 1;
+  if (narg > 3) {
+#if defined(_OPENMP)
+    if (strcmp(arg[3],"0") == 0)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(nthreads)
+      nthreads = omp_get_num_threads();
+    else
+      nthreads = utils::inumeric(FLERR,arg[3],false,lmp);
+#endif
+  }
+
+#if defined(_OPENMP)
+  if (nthreads < 1)
+    error->all(FLERR,"Illegal number of OpenMP threads requested");
+
+  int reset_thr = 0;
+#endif
+  if (nthreads != comm->nthreads) {
+#if defined(_OPENMP)
+    reset_thr = 1;
+    omp_set_num_threads(nthreads);
+#endif
+    comm->nthreads = nthreads;
+  }
+
+  // optional keywords
+
+  int iarg = 4;
+  while (iarg < narg) {
+    if (strcmp(arg[iarg],"neigh") == 0) {
+      if (iarg+2 > narg) error->all(FLERR,"Illegal package omp command");
+      _neighbor = utils::logical(FLERR,arg[iarg+1],false,lmp) != 0;
+      iarg += 2;
+    } else error->all(FLERR,"Illegal package omp command");
+  }
+
+  // print summary of settings
+
+  if (comm->me == 0) {
+#if defined(_OPENMP)
+    const char * const nmode = _neighbor ? "multi-threaded" : "serial";
+
+    if (reset_thr)
+      utils::logmesg(lmp, "set {} OpenMP thread(s) per MPI task\n", nthreads);
+    utils::logmesg(lmp, "using {} neighbor list subroutines\n", nmode);
+#else
+    error->warning(FLERR,"OpenMP support not enabled during compilation; "
+                         "using 1 thread only.");
+#endif
+  }
+
+  // allocate list for per thread accumulator manager class instances
+  // and then have each thread create an instance of this class to
+  // encourage the OS to use storage that is "close" to each thread's CPU.
+
+  thr = new ThrData *[nthreads];
+  _nthr = nthreads;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(lmp)
+#endif
+  {
+    const int tid = get_tid();
+    auto t = new Timer(lmp);
+    thr[tid] = new ThrData(tid,t);
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+FixOMP::~FixOMP()
+{
+  for (int i=0; i < _nthr; ++i)
+    delete thr[i];
+
+  delete[] thr;
+}
+
+/* ---------------------------------------------------------------------- */
+
+int FixOMP::setmask()
+{
+  int mask = 0;
+  mask |= PRE_FORCE;
+  mask |= PRE_FORCE_RESPA;
+  mask |= MIN_PRE_FORCE;
+  return mask;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixOMP::init()
+{
+  // OPENMP package cannot be used with atom_style template
+  if (atom->molecular == Atom::TEMPLATE)
+    error->all(FLERR,"OPENMP package does not (yet) work with "
+               "atom_style template");
+
+  // adjust number of data objects when the number of OpenMP
+  // threads has been changed somehow
+  const int nthreads = comm->nthreads;
+  if (_nthr != nthreads) {
+    if (comm->me == 0)
+      utils::logmesg(lmp,"Re-init OPENMP for {} OpenMP thread(s)\n", nthreads);
+
+    for (int i=0; i < _nthr; ++i)
+      delete thr[i];
+
+    thr = new ThrData *[nthreads];
+    _nthr = nthreads;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE
+#endif
+    {
+      const int tid = get_tid();
+      auto t = new Timer(lmp);
+      thr[tid] = new ThrData(tid,t);
+    }
+  }
+
+  // reset per thread timer
+  for (int i=0; i < nthreads; ++i) {
+    thr[i]->_timer_active=1;
+    thr[i]->timer(Timer::RESET);
+    thr[i]->_timer_active=-1;
+  }
+
+  if (utils::strmatch(update->integrate_style,"^respa")
+      && !utils::strmatch(update->integrate_style,"^respa/omp"))
+    error->all(FLERR,"Must use respa/omp for r-RESPA with /omp styles");
+
+  _pair_compute_flag = force->pair && force->pair->compute_flag;
+  _kspace_compute_flag = force->kspace && force->kspace->compute_flag;
+
+  int check_hybrid, kspace_split;
+  last_pair_hybrid = nullptr;
+  last_omp_style = nullptr;
+  const char *last_omp_name = nullptr;
+  const char *last_hybrid_name = nullptr;
+  const char *last_force_name = nullptr;
+
+  // support for verlet/split operation.
+  // kspace_split == 0 : regular processing
+  // kspace_split < 0  : master partition, does not do kspace
+  // kspace_split > 0  : slave partition, only does kspace
+
+  if (strstr(update->integrate_style,"verlet/split") != nullptr) {
+    if (universe->iworld == 0) kspace_split = -1;
+    else kspace_split = 1;
+  } else {
+    kspace_split = 0;
+  }
+
+// determine which is the last force style with OpenMP
+// support as this is the one that has to reduce the forces
+
+#define CheckStyleForOMP(name)                                          \
+  check_hybrid = 0;                                                     \
+  if (force->name) {                                                    \
+    if ( (strcmp(force->name ## _style,"hybrid") == 0) ||               \
+         (strcmp(force->name ## _style,"hybrid/overlay") == 0) )        \
+      check_hybrid=1;                                                   \
+    if (force->name->suffix_flag & Suffix::OMP) {                       \
+      last_force_name = (const char *) #name;                           \
+      last_omp_name = force->name ## _style;                            \
+      last_omp_style = (void *) force->name;                            \
+    }                                                                   \
+  }
+
+#define CheckHybridForOMP(name,Class) \
+  if (check_hybrid) {                                         \
+    Class ## Hybrid *style = (Class ## Hybrid *) force->name; \
+    for (int i=0; i < style->nstyles; i++) {                  \
+      if (style->styles[i]->suffix_flag & Suffix::OMP) {      \
+        last_force_name = (const char *) #name;               \
+        last_omp_name = style->keywords[i];                   \
+        last_omp_style = style->styles[i];                    \
+      }                                                       \
+    }                                                         \
+  }
+
+  if (_pair_compute_flag && (kspace_split <= 0)) {
+    CheckStyleForOMP(pair);
+    CheckHybridForOMP(pair,Pair);
+    if (check_hybrid) {
+      last_pair_hybrid = last_omp_style;
+      last_hybrid_name = last_omp_name;
+    }
+
+    CheckStyleForOMP(bond);
+    CheckHybridForOMP(bond,Bond);
+
+    CheckStyleForOMP(angle);
+    CheckHybridForOMP(angle,Angle);
+
+    CheckStyleForOMP(dihedral);
+    CheckHybridForOMP(dihedral,Dihedral);
+
+    CheckStyleForOMP(improper);
+    CheckHybridForOMP(improper,Improper);
+  }
+
+  if (_kspace_compute_flag && (kspace_split >= 0)) {
+    CheckStyleForOMP(kspace);
+  }
+
+#undef CheckStyleForOMP
+#undef CheckHybridForOMP
+  neighbor->set_omp_neighbor(_neighbor ? 1 : 0);
+
+  // diagnostic output
+  if (comm->me == 0) {
+    if (last_omp_style) {
+      if (last_pair_hybrid)
+        utils::logmesg(lmp,"Hybrid pair style last /omp style {}\n",last_hybrid_name);
+      utils::logmesg(lmp,"Last active /omp style is {}_style {}\n",last_force_name,last_omp_name);
+    } else {
+      utils::logmesg(lmp,"No /omp style for force computation currently active\n");
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void FixOMP::setup(int)
+{
+  // we are post the force compute in setup. turn on timers
+  for (int i=0; i < _nthr; ++i)
+    thr[i]->_timer_active=0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+// adjust size and clear out per thread accumulator arrays
+void FixOMP::pre_force(int)
+{
+  const int nall = atom->nlocal + atom->nghost;
+
+  double **f = atom->f;
+  double **torque = atom->torque;
+  double *erforce = atom->erforce;
+  double *desph = atom->desph;
+  double *drho = atom->drho;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(f,torque,erforce,desph,drho)
+#endif
+  {
+    const int tid = get_tid();
+    thr[tid]->check_tid(tid);
+    thr[tid]->init_force(nall,f,torque,erforce,desph,drho);
+  } // end of omp parallel region
+
+  _reduced = false;
+}
+
+/* ---------------------------------------------------------------------- */
+
+double FixOMP::memory_usage()
+{
+  double bytes = (double)_nthr * (sizeof(ThrData *) + sizeof(ThrData));
+  bytes += (double)_nthr * thr[0]->memory_usage();
+
+  return bytes;
+}
diff -ruN lammps-stable_2Aug2023/src/fix_omp.h ../lammps-stable_2Aug2023/src/fix_omp.h
--- lammps-stable_2Aug2023/src/fix_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/fix_omp.h	2023-09-26 15:27:28.434067000 -0400
@@ -0,0 +1,79 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef FIX_CLASS
+// clang-format off
+FixStyle(OMP,FixOMP);
+// clang-format on
+#else
+
+#ifndef LMP_FIX_OMP_H
+#define LMP_FIX_OMP_H
+
+#include "fix.h"
+
+namespace LAMMPS_NS {
+
+class ThrData;
+
+class FixOMP : public Fix {
+  friend class ThrOMP;
+  friend class RespaOMP;
+
+ public:
+  FixOMP(class LAMMPS *, int, char **);
+  ~FixOMP() override;
+  int setmask() override;
+  void init() override;
+  void setup(int) override;
+  void min_setup(int flag) override { setup(flag); }
+  void pre_force(int) override;
+
+  void setup_pre_force(int vflag) override { pre_force(vflag); }
+  virtual void min_setup_pre_force(int vflag) { pre_force(vflag); }
+  void min_pre_force(int vflag) override { pre_force(vflag); }
+  void setup_pre_force_respa(int vflag, int) override { pre_force(vflag); }
+  void pre_force_respa(int vflag, int, int) override { pre_force(vflag); }
+
+  double memory_usage() override;
+
+ protected:
+  ThrData **thr;
+  void *last_omp_style;      // pointer to the style that needs
+                             // to do the general force reduction
+  void *last_pair_hybrid;    // pointer to the pair style that needs
+                             // to call virial_fdot_compute()
+  // signal that an /omp style did the force reduction. needed by respa/omp
+  void did_reduce() { _reduced = true; }
+
+ public:
+  ThrData *get_thr(int tid) { return thr[tid]; }
+  int get_nthr() const { return _nthr; }
+
+  bool get_neighbor() const { return _neighbor; }
+  bool get_mixed() const { return _mixed; }
+  bool get_reduced() const { return _reduced; }
+
+ private:
+  int _nthr;                    // number of currently active ThrData objects
+  bool _neighbor;               // en/disable threads for neighbor list construction
+  bool _mixed;                  // whether to prefer mixed precision compute kernels
+  bool _reduced;                // whether forces have been reduced for this step
+  bool _pair_compute_flag;      // whether pair_compute is called
+  bool _kspace_compute_flag;    // whether kspace_compute is called
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/lmptype.h ../lammps-stable_2Aug2023/src/lmptype.h
--- lammps-stable_2Aug2023/src/lmptype.h	2023-08-03 11:33:14.000000000 -0400
+++ ../lammps-stable_2Aug2023/src/lmptype.h	2023-11-18 23:16:20.028182199 -0500
@@ -129,7 +129,7 @@
 typedef int64_t tagint;
 typedef int64_t bigint;
 
-#define MAXSMALLINT INT_MAX
+#define MAXSMALLINT INT_MAX 
 #define MAXTAGINT INT64_MAX
 #define MAXBIGINT INT64_MAX
 #define MAXDOUBLEINT 9007199254740992    // 2^53
diff -ruN lammps-stable_2Aug2023/src/main.cpp ../lammps-stable_2Aug2023/src/main.cpp
--- lammps-stable_2Aug2023/src/main.cpp	2023-08-03 11:33:14.000000000 -0400
+++ ../lammps-stable_2Aug2023/src/main.cpp	2024-04-12 00:54:22.544805718 -0400
@@ -32,6 +32,10 @@
 #include <mdi.h>
 #endif
 
+#if defined APPEKG
+#include "appekg.h"
+#endif
+
 using namespace LAMMPS_NS;
 
 // for convenience
@@ -48,6 +52,14 @@
 int main(int argc, char **argv)
 {
   MPI_Init(&argc, &argv);
+#if defined APPEKG
+  int appekg_myrank;
+  MPI_Comm_rank(MPI_COMM_WORLD, &appekg_myrank);
+  EKG_INITIALIZE(2, 1, 4, 0, appekg_myrank, 1);
+  EKG_NAME_HEARTBEAT(1,"BuildNiegbhours");
+  EKG_NAME_HEARTBEAT(2,"LJForceCompute");
+#endif
+
   MPI_Comm lammps_comm = MPI_COMM_WORLD;
 
 #if defined(LMP_MDI)
@@ -114,4 +126,7 @@
   finalize();
   MPI_Barrier(lammps_comm);
   MPI_Finalize();
+#if defined APPEKG
+  EKG_FINALIZE();
+#endif
 }
diff -ruN lammps-stable_2Aug2023/src/MAKE/Makefile.appekg ../lammps-stable_2Aug2023/src/MAKE/Makefile.appekg
--- lammps-stable_2Aug2023/src/MAKE/Makefile.appekg	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/MAKE/Makefile.appekg	2023-09-22 00:06:01.730385000 -0400
@@ -0,0 +1,128 @@
+# mpi = MPI with its default compiler
+
+SHELL = /bin/sh
+
+APPEKGDIR = /anvil/projects/x-cis230165/tools/AppEKG/
+APPEKGCFLAGS = -DAPPEKG -I${APPEKGDIR}
+APPEKGLDOBJ = -L${APPEKGDIR} -lappekg -lpthread -lrt
+
+# ---------------------------------------------------------------------
+# compiler/linker settings
+# specify flags and libraries needed for your compiler
+
+CC =		mpicxx
+CCFLAGS =	-g -O3 -std=c++11 -fopenmp ${APPEKGCFLAGS} -D_OPENMP
+SHFLAGS =	-fPIC
+DEPFLAGS =	-M
+
+LINK =		mpicxx
+LINKFLAGS =	-g -O3 -std=c++11 -fopenmp ${APPEKGCFLAGS}
+LIB =
+SIZE =		size
+
+ARCHIVE =	ar
+ARFLAGS =	-rc
+SHLIBFLAGS =	-shared -rdynamic
+
+# ---------------------------------------------------------------------
+# LAMMPS-specific settings, all OPTIONAL
+# specify settings for LAMMPS features you will use
+# if you change any -D setting, do full re-compile after "make clean"
+
+# LAMMPS ifdef settings
+# see possible settings in Section 3.5 of the manual
+
+LMP_INC =	-DLAMMPS_GZIP -DLAMMPS_MEMALIGN=64  # -DLAMMPS_CXX98
+
+# MPI library
+# see discussion in Section 3.4 of the manual
+# MPI wrapper compiler/linker can provide this info
+# can point to dummy MPI library in src/STUBS as in Makefile.serial
+# use -D MPICH and OMPI settings in INC to avoid C++ lib conflicts
+# INC = path for mpi.h, MPI compiler settings
+# PATH = path for MPI library
+# LIB = name of MPI library
+
+MPI_INC =       -DMPICH_SKIP_MPICXX -DOMPI_SKIP_MPICXX=1
+MPI_PATH =
+MPI_LIB =
+
+# FFT library
+# see discussion in Section 3.5.2 of manual
+# can be left blank to use provided KISS FFT library
+# INC = -DFFT setting, e.g. -DFFT_FFTW, FFT compiler settings
+# PATH = path for FFT library
+# LIB = name of FFT library
+
+FFT_INC =
+FFT_PATH =
+FFT_LIB =
+
+# JPEG and/or PNG library
+# see discussion in Section 3.5.4 of manual
+# only needed if -DLAMMPS_JPEG or -DLAMMPS_PNG listed with LMP_INC
+# INC = path(s) for jpeglib.h and/or png.h
+# PATH = path(s) for JPEG library and/or PNG library
+# LIB = name(s) of JPEG library and/or PNG library
+
+JPG_INC =
+JPG_PATH =
+JPG_LIB =
+
+# library for loading shared objects (defaults to -ldl, should be empty on Windows)
+# uncomment to change the default
+
+# override DYN_LIB =
+
+# ---------------------------------------------------------------------
+# build rules and dependencies
+# do not edit this section
+
+include Makefile.package.settings
+include Makefile.package
+
+EXTRA_INC = $(LMP_INC) $(PKG_INC) $(MPI_INC) $(FFT_INC) $(JPG_INC) $(PKG_SYSINC)
+EXTRA_PATH = $(PKG_PATH) $(MPI_PATH) $(FFT_PATH) $(JPG_PATH) $(PKG_SYSPATH)
+EXTRA_LIB = $(PKG_LIB) $(MPI_LIB) $(FFT_LIB) $(JPG_LIB) $(PKG_SYSLIB) $(DYN_LIB)
+EXTRA_CPP_DEPENDS = $(PKG_CPP_DEPENDS)
+EXTRA_LINK_DEPENDS = $(PKG_LINK_DEPENDS)
+
+# Path to src files
+
+vpath %.cpp ..
+vpath %.h ..
+
+# Link target
+
+$(EXE): main.o $(LMPLIB) $(EXTRA_LINK_DEPENDS)
+	$(LINK) $(LINKFLAGS) main.o $(EXTRA_PATH) $(LMPLINK) $(EXTRA_LIB) $(LIB) -o $@ $(APPEKGLDOBJ)
+	$(SIZE) $@
+
+# Library targets
+
+$(ARLIB): $(OBJ) $(EXTRA_LINK_DEPENDS)
+	@rm -f ../$(ARLIB)
+	$(ARCHIVE) $(ARFLAGS) ../$(ARLIB) $(OBJ)
+	@rm -f $(ARLIB)
+	@ln -s ../$(ARLIB) $(ARLIB)
+
+$(SHLIB): $(OBJ) $(EXTRA_LINK_DEPENDS)
+	$(CC) $(CCFLAGS) $(SHFLAGS) $(SHLIBFLAGS) $(EXTRA_PATH) -o ../$(SHLIB) \
+		$(OBJ) $(EXTRA_LIB) $(LIB) $(APPEKGLDOBJ)
+	@rm -f $(SHLIB)
+	@ln -s ../$(SHLIB) $(SHLIB)
+
+# Compilation rules
+
+%.o:%.cpp
+	$(CC) $(CCFLAGS) $(SHFLAGS) $(EXTRA_INC) -c $<
+
+# Individual dependencies
+
+depend : fastdep.exe $(SRC)
+	@./fastdep.exe $(EXTRA_INC) -- $^ > .depend || exit 1
+
+fastdep.exe: ../DEPEND/fastdep.c
+	cc -O -o $@ $<
+
+sinclude .depend
diff -ruN lammps-stable_2Aug2023/src/MAKE/MINE/Makefile.omp ../lammps-stable_2Aug2023/src/MAKE/MINE/Makefile.omp
--- lammps-stable_2Aug2023/src/MAKE/MINE/Makefile.omp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/MAKE/MINE/Makefile.omp	2023-11-18 22:30:37.631350000 -0500
@@ -0,0 +1,127 @@
+# omp = OPENMP package, MPI with its default compiler
+
+SHELL = /bin/sh
+
+
+
+# ---------------------------------------------------------------------
+# compiler/linker settings
+# specify flags and libraries needed for your compiler
+
+CC =		mpicxx
+CCFLAGS =	-g -O3  -fopenmp -std=c++11  
+SHFLAGS =	-fPIC
+DEPFLAGS =	-M
+
+LINK =		mpicxx
+LINKFLAGS =	-g -O -fopenmp -std=c++11
+LIB = 
+SIZE =		size
+
+ARCHIVE =	ar
+ARFLAGS =	-rc
+SHLIBFLAGS =	-shared
+
+# ---------------------------------------------------------------------
+# LAMMPS-specific settings, all OPTIONAL
+# specify settings for LAMMPS features you will use
+# if you change any -D setting, do full re-compile after "make clean"
+
+# LAMMPS ifdef settings
+# see possible settings in Section 3.5 of the manual
+
+# define LAMMPS_BIGBIG to skip error "New atom IDs exceed maximum allowed ID 2147483647"
+LMP_INC =	-DLAMMPS_GZIP -DLAMMPS_BIGBIG
+
+# MPI library
+# see discussion in Section 3.4 of the manual
+# MPI wrapper compiler/linker can provide this info
+# can point to dummy MPI library in src/STUBS as in Makefile.serial
+# use -D MPICH and OMPI settings in INC to avoid C++ lib conflicts
+# INC = path for mpi.h, MPI compiler settings
+# PATH = path for MPI library
+# LIB = name of MPI library
+
+MPI_INC =       #-DMPICH_SKIP_MPICXX -DOMPI_SKIP_MPICXX=1
+MPI_PATH =
+MPI_LIB =
+
+# FFT library
+# see discussion in Section 3.5.2 of manual
+# can be left blank to use provided KISS FFT library
+# INC = -DFFT setting, e.g. -DFFT_FFTW, FFT compiler settings
+# PATH = path for FFT library
+# LIB = name of FFT library
+
+FFT_INC =
+FFT_PATH =
+FFT_LIB =
+
+# JPEG and/or PNG library
+# see discussion in Section 3.5.4 of manual
+# only needed if -DLAMMPS_JPEG or -DLAMMPS_PNG listed with LMP_INC
+# INC = path(s) for jpeglib.h and/or png.h
+# PATH = path(s) for JPEG library and/or PNG library
+# LIB = name(s) of JPEG library and/or PNG library
+
+JPG_INC =
+JPG_PATH =
+JPG_LIB =
+
+#  library for loading shared objects (defaults to -ldl, should be empty on Windows)
+# uncomment to change the default
+
+# override DYN_LIB =
+
+# ---------------------------------------------------------------------
+# build rules and dependencies
+# do not edit this section
+
+include Makefile.package.settings
+include Makefile.package
+
+EXTRA_INC = $(LMP_INC) $(PKG_INC) $(MPI_INC) $(FFT_INC) $(JPG_INC) $(PKG_SYSINC)
+EXTRA_PATH = $(PKG_PATH) $(MPI_PATH) $(FFT_PATH) $(JPG_PATH) $(PKG_SYSPATH)
+EXTRA_LIB = $(PKG_LIB) $(MPI_LIB) $(FFT_LIB) $(JPG_LIB) $(PKG_SYSLIB) $(DYN_LIB)
+EXTRA_CPP_DEPENDS = $(PKG_CPP_DEPENDS)
+EXTRA_LINK_DEPENDS = $(PKG_LINK_DEPENDS)
+
+# Path to src files
+
+vpath %.cpp ..
+vpath %.h ..
+
+# Link target
+
+$(EXE): main.o $(LMPLIB) $(EXTRA_LINK_DEPENDS)
+	$(LINK) $(LINKFLAGS) main.o $(EXTRA_PATH) $(LMPLINK) $(EXTRA_LIB) $(LIB) -o $@
+	$(SIZE) $@
+
+# Library targets
+
+$(ARLIB): $(OBJ) $(EXTRA_LINK_DEPENDS)
+	@rm -f ../$(ARLIB)
+	$(ARCHIVE) $(ARFLAGS) ../$(ARLIB) $(OBJ)
+	@rm -f $(ARLIB)
+	@ln -s ../$(ARLIB) $(ARLIB)
+
+$(SHLIB): $(OBJ) $(EXTRA_LINK_DEPENDS)
+	$(CC) $(CCFLAGS) $(SHFLAGS) $(SHLIBFLAGS) $(EXTRA_PATH) -o ../$(SHLIB) \
+		$(OBJ) $(EXTRA_LIB) $(LIB)
+	@rm -f $(SHLIB)
+	@ln -s ../$(SHLIB) $(SHLIB)
+
+# Compilation rules
+
+%.o:%.cpp
+	$(CC) $(CCFLAGS) $(SHFLAGS) $(EXTRA_INC) -c $<
+
+# Individual dependencies
+
+depend : fastdep.exe $(SRC)
+	@./fastdep.exe $(EXTRA_INC) -- $^ > .depend || exit 1
+
+fastdep.exe: ../DEPEND/fastdep.c
+	cc -O -o $@ $<
+
+sinclude .depend
diff -ruN lammps-stable_2Aug2023/src/MAKE/MINE/Makefile.omp_appekg ../lammps-stable_2Aug2023/src/MAKE/MINE/Makefile.omp_appekg
--- lammps-stable_2Aug2023/src/MAKE/MINE/Makefile.omp_appekg	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/MAKE/MINE/Makefile.omp_appekg	2023-11-18 22:13:53.002774000 -0500
@@ -0,0 +1,134 @@
+# omp = OPENMP package, MPI with its default compiler
+
+SHELL = /bin/sh
+
+
+APPEKGDIR = /anvil/projects/x-cis230165/tools/ghappekg
+APPEKGCFLAGS = -DAPPEKG -I${APPEKGDIR}
+APPEKGLDOBJ = -L${APPEKGDIR} -lappekg -lpthread -lrt
+
+# no APPEKG
+#APPEKGCFLAGS = 
+#APPEKGLDOBJ = 
+
+# ---------------------------------------------------------------------
+# compiler/linker settings
+# specify flags and libraries needed for your compiler
+
+CC =		mpicxx
+CCFLAGS =	-g -O3  -fopenmp -std=c++11 ${APPEKGCFLAGS} 
+SHFLAGS =	-fPIC
+DEPFLAGS =	-M
+
+LINK =		mpicxx
+LINKFLAGS =	-g -O -fopenmp -std=c++11 #${APPEKGLDOBJ}
+LIB = 
+SIZE =		size
+
+ARCHIVE =	ar
+ARFLAGS =	-rc
+SHLIBFLAGS =	-shared
+
+# ---------------------------------------------------------------------
+# LAMMPS-specific settings, all OPTIONAL
+# specify settings for LAMMPS features you will use
+# if you change any -D setting, do full re-compile after "make clean"
+
+# LAMMPS ifdef settings
+# see possible settings in Section 3.5 of the manual
+
+# define LAMMPS_BIGBIG to skip error "New atom IDs exceed maximum allowed ID 2147483647"
+LMP_INC =	-DLAMMPS_GZIP -DLAMMPS_BIGBIG
+
+# MPI library
+# see discussion in Section 3.4 of the manual
+# MPI wrapper compiler/linker can provide this info
+# can point to dummy MPI library in src/STUBS as in Makefile.serial
+# use -D MPICH and OMPI settings in INC to avoid C++ lib conflicts
+# INC = path for mpi.h, MPI compiler settings
+# PATH = path for MPI library
+# LIB = name of MPI library
+
+MPI_INC =       #-DMPICH_SKIP_MPICXX -DOMPI_SKIP_MPICXX=1
+MPI_PATH =
+MPI_LIB =
+
+# FFT library
+# see discussion in Section 3.5.2 of manual
+# can be left blank to use provided KISS FFT library
+# INC = -DFFT setting, e.g. -DFFT_FFTW, FFT compiler settings
+# PATH = path for FFT library
+# LIB = name of FFT library
+
+FFT_INC =
+FFT_PATH =
+FFT_LIB =
+
+# JPEG and/or PNG library
+# see discussion in Section 3.5.4 of manual
+# only needed if -DLAMMPS_JPEG or -DLAMMPS_PNG listed with LMP_INC
+# INC = path(s) for jpeglib.h and/or png.h
+# PATH = path(s) for JPEG library and/or PNG library
+# LIB = name(s) of JPEG library and/or PNG library
+
+JPG_INC =
+JPG_PATH =
+JPG_LIB =
+
+#  library for loading shared objects (defaults to -ldl, should be empty on Windows)
+# uncomment to change the default
+
+# override DYN_LIB =
+
+# ---------------------------------------------------------------------
+# build rules and dependencies
+# do not edit this section
+
+include Makefile.package.settings
+include Makefile.package
+
+EXTRA_INC = $(LMP_INC) $(PKG_INC) $(MPI_INC) $(FFT_INC) $(JPG_INC) $(PKG_SYSINC)
+EXTRA_PATH = $(PKG_PATH) $(MPI_PATH) $(FFT_PATH) $(JPG_PATH) $(PKG_SYSPATH)
+EXTRA_LIB = $(PKG_LIB) $(MPI_LIB) $(FFT_LIB) $(JPG_LIB) $(PKG_SYSLIB) $(DYN_LIB)
+EXTRA_CPP_DEPENDS = $(PKG_CPP_DEPENDS)
+EXTRA_LINK_DEPENDS = $(PKG_LINK_DEPENDS)
+
+# Path to src files
+
+vpath %.cpp ..
+vpath %.h ..
+
+# Link target
+
+$(EXE): main.o $(LMPLIB) $(EXTRA_LINK_DEPENDS)
+	$(LINK) $(LINKFLAGS) main.o ${APPEKGLDOBJ} $(EXTRA_PATH) $(LMPLINK) $(EXTRA_LIB) $(LIB) -o $@
+	$(SIZE) $@
+
+# Library targets
+
+$(ARLIB): $(OBJ) $(EXTRA_LINK_DEPENDS)
+	@rm -f ../$(ARLIB)
+	$(ARCHIVE) $(ARFLAGS) ../$(ARLIB) $(OBJ)
+	@rm -f $(ARLIB)
+	@ln -s ../$(ARLIB) $(ARLIB)
+
+$(SHLIB): $(OBJ) $(EXTRA_LINK_DEPENDS)
+	$(CC) $(CCFLAGS) $(SHFLAGS) $(SHLIBFLAGS) $(EXTRA_PATH) -o ../$(SHLIB) \
+		$(OBJ) $(EXTRA_LIB) $(LIB)
+	@rm -f $(SHLIB)
+	@ln -s ../$(SHLIB) $(SHLIB)
+
+# Compilation rules
+
+%.o:%.cpp
+	$(CC) $(CCFLAGS) $(SHFLAGS) $(EXTRA_INC) -c $<
+
+# Individual dependencies
+
+depend : fastdep.exe $(SRC)
+	@./fastdep.exe $(EXTRA_INC) -- $^ > .depend || exit 1
+
+fastdep.exe: ../DEPEND/fastdep.c
+	cc -O -o $@ $<
+
+sinclude .depend
diff -ruN lammps-stable_2Aug2023/src/MAKE/OPTIONS/Makefile.omp ../lammps-stable_2Aug2023/src/MAKE/OPTIONS/Makefile.omp
--- lammps-stable_2Aug2023/src/MAKE/OPTIONS/Makefile.omp	2023-08-03 11:33:14.000000000 -0400
+++ ../lammps-stable_2Aug2023/src/MAKE/OPTIONS/Makefile.omp	2023-11-18 22:29:10.855720000 -0500
@@ -2,17 +2,18 @@
 
 SHELL = /bin/sh
 
+
 # ---------------------------------------------------------------------
 # compiler/linker settings
 # specify flags and libraries needed for your compiler
 
 CC =		mpicxx
-CCFLAGS =	-g -O3 -restrict -fopenmp -std=c++11
+CCFLAGS =	-g -O3 -restrict -fopenmp -std=c++11  
 SHFLAGS =	-fPIC
 DEPFLAGS =	-M
 
 LINK =		mpicxx
-LINKFLAGS =	-g -O -fopenmp -std=c++11
+LINKFLAGS =	-g -O -fopenmp -std=c++11 
 LIB = 
 SIZE =		size
 
diff -ruN lammps-stable_2Aug2023/src/Makefile.package ../lammps-stable_2Aug2023/src/Makefile.package
--- lammps-stable_2Aug2023/src/Makefile.package	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/Makefile.package	2023-09-26 15:27:29.156732538 -0400
@@ -0,0 +1,12 @@
+# Settings for libraries used by specific LAMMPS packages
+# this file is auto-edited when those packages are included/excluded
+
+PKG_INC = -DLMP_OPENMP 
+PKG_PATH = 
+PKG_LIB = 
+PKG_CPP_DEPENDS = 
+PKG_LINK_DEPENDS = 
+
+PKG_SYSINC = 
+PKG_SYSLIB = 
+PKG_SYSPATH = 
diff -ruN lammps-stable_2Aug2023/src/Makefile.package.settings ../lammps-stable_2Aug2023/src/Makefile.package.settings
--- lammps-stable_2Aug2023/src/Makefile.package.settings	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/Makefile.package.settings	2023-09-06 00:02:00.970906000 -0400
@@ -0,0 +1,4 @@
+# Makefile settings generated by libraries used by specific LAMMPS packages
+# this file is auto-edited when those packages are included/excluded
+
+
diff -ruN lammps-stable_2Aug2023/src/npair_full_bin_atomonly_omp.cpp ../lammps-stable_2Aug2023/src/npair_full_bin_atomonly_omp.cpp
--- lammps-stable_2Aug2023/src/npair_full_bin_atomonly_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_full_bin_atomonly_omp.cpp	2023-09-26 15:27:26.666978000 -0400
@@ -0,0 +1,106 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_full_bin_atomonly_omp.h"
+
+#include "atom.h"
+#include "error.h"
+#include "my_page.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairFullBinAtomonlyOmp::NPairFullBinAtomonlyOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   binned neighbor list construction for all neighbors
+   every neighbor pair appears in list of both atoms i and j
+------------------------------------------------------------------------- */
+
+void NPairFullBinAtomonlyOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,k,n,itype,jtype,ibin;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr;
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *molecule = atom->molecule;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  // loop over owned atoms, storing neighbors
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+
+    // loop over all atoms in surrounding bins in stencil including self
+    // skip i = j
+
+    ibin = atom2bin[i];
+
+    for (k = 0; k < nstencil; k++) {
+      for (j = binhead[ibin+stencil[k]]; j >= 0; j = bins[j]) {
+        if (i == j) continue;
+
+        jtype = type[j];
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+
+        if (rsq <= cutneighsq[itype][jtype]) neighptr[n++] = j;
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+  list->gnum = 0;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_full_bin_atomonly_omp.h ../lammps-stable_2Aug2023/src/npair_full_bin_atomonly_omp.h
--- lammps-stable_2Aug2023/src/npair_full_bin_atomonly_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_full_bin_atomonly_omp.h	2023-09-26 15:27:28.489328000 -0400
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(full/bin/atomonly/omp,
+           NPairFullBinAtomonlyOmp,
+           NP_FULL | NP_BIN | NP_ATOMONLY | NP_OMP |
+           NP_NEWTON | NP_NEWTOFF | NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_FULL_BIN_ATOMONLY_OMP_H
+#define LMP_NPAIR_FULL_BIN_ATOMONLY_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairFullBinAtomonlyOmp : public NPair {
+ public:
+  NPairFullBinAtomonlyOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_full_bin_ghost_omp.cpp ../lammps-stable_2Aug2023/src/npair_full_bin_ghost_omp.cpp
--- lammps-stable_2Aug2023/src/npair_full_bin_ghost_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_full_bin_ghost_omp.cpp	2023-09-26 15:27:26.678644000 -0400
@@ -0,0 +1,166 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_full_bin_ghost_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairFullBinGhostOmp::NPairFullBinGhostOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   binned neighbor list construction for all neighbors
+   include neighbors of ghost atoms, but no "special neighbors" for ghosts
+   every neighbor pair appears in list of both atoms i and j
+------------------------------------------------------------------------- */
+
+void NPairFullBinGhostOmp::build(NeighList *list)
+{
+  const int nlocal = atom->nlocal;
+  const int nall = nlocal + atom->nghost;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nall);
+
+  int i,j,k,n,itype,jtype,ibin,which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int xbin,ybin,zbin,xbin2,ybin2,zbin2;
+  int *neighptr;
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  // loop over owned & ghost atoms, storing neighbors
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over all atoms in surrounding bins in stencil including self
+    // when i is a ghost atom, must check if stencil bin is out of bounds
+    // skip i = j
+    // no molecular test when i = ghost atom
+
+    if (i < nlocal) {
+      ibin = atom2bin[i];
+      for (k = 0; k < nstencil; k++) {
+        for (j = binhead[ibin+stencil[k]]; j >= 0; j = bins[j]) {
+          if (i == j) continue;
+
+          jtype = type[j];
+          if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+          delx = xtmp - x[j][0];
+          dely = ytmp - x[j][1];
+          delz = ztmp - x[j][2];
+          rsq = delx*delx + dely*dely + delz*delz;
+
+          if (rsq <= cutneighsq[itype][jtype]) {
+            if (molecular != Atom::ATOMIC) {
+              if (!moltemplate)
+                which = find_special(special[i],nspecial[i],tag[j]);
+              else if (imol >= 0)
+                which = find_special(onemols[imol]->special[iatom],
+                                     onemols[imol]->nspecial[iatom],
+                                     tag[j]-tagprev);
+              else which = 0;
+              if (which == 0) neighptr[n++] = j;
+              else if (domain->minimum_image_check(delx,dely,delz))
+                neighptr[n++] = j;
+              else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+            } else neighptr[n++] = j;
+          }
+        }
+      }
+
+    } else {
+      ibin = coord2bin(x[i],xbin,ybin,zbin);
+      for (k = 0; k < nstencil; k++) {
+        xbin2 = xbin + stencilxyz[k][0];
+        ybin2 = ybin + stencilxyz[k][1];
+        zbin2 = zbin + stencilxyz[k][2];
+        if (xbin2 < 0 || xbin2 >= mbinx ||
+            ybin2 < 0 || ybin2 >= mbiny ||
+            zbin2 < 0 || zbin2 >= mbinz) continue;
+        for (j = binhead[ibin+stencil[k]]; j >= 0; j = bins[j]) {
+          if (i == j) continue;
+
+          jtype = type[j];
+          if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+          delx = xtmp - x[j][0];
+          dely = ytmp - x[j][1];
+          delz = ztmp - x[j][2];
+          rsq = delx*delx + dely*dely + delz*delz;
+
+          if (rsq <= cutneighghostsq[itype][jtype]) neighptr[n++] = j;
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+  list->gnum = nall - nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_full_bin_ghost_omp.h ../lammps-stable_2Aug2023/src/npair_full_bin_ghost_omp.h
--- lammps-stable_2Aug2023/src/npair_full_bin_ghost_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_full_bin_ghost_omp.h	2023-09-26 15:27:28.493595000 -0400
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(full/bin/ghost/omp,
+           NPairFullBinGhostOmp,
+           NP_FULL | NP_BIN | NP_GHOST | NP_OMP | NP_NEWTON | NP_NEWTOFF |
+           NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_FULL_BIN_GHOST_OMP_H
+#define LMP_NPAIR_FULL_BIN_GHOST_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairFullBinGhostOmp : public NPair {
+ public:
+  NPairFullBinGhostOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_full_bin_omp.cpp ../lammps-stable_2Aug2023/src/npair_full_bin_omp.cpp
--- lammps-stable_2Aug2023/src/npair_full_bin_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_full_bin_omp.cpp	2023-09-26 15:27:26.694664000 -0400
@@ -0,0 +1,135 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_full_bin_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairFullBinOmp::NPairFullBinOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   binned neighbor list construction for all neighbors
+   every neighbor pair appears in list of both atoms i and j
+------------------------------------------------------------------------- */
+
+void NPairFullBinOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,k,n,itype,jtype,ibin,which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr;
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  // loop over owned atoms, storing neighbors
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over all atoms in surrounding bins in stencil including self
+    // skip i = j
+
+    ibin = atom2bin[i];
+
+    for (k = 0; k < nstencil; k++) {
+      for (j = binhead[ibin+stencil[k]]; j >= 0; j = bins[j]) {
+        if (i == j) continue;
+
+        jtype = type[j];
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+
+        if (rsq <= cutneighsq[itype][jtype]) {
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = j;
+            else if (domain->minimum_image_check(delx,dely,delz))
+              neighptr[n++] = j;
+            else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+          } else neighptr[n++] = j;
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+  list->gnum = 0;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_full_bin_omp.h ../lammps-stable_2Aug2023/src/npair_full_bin_omp.h
--- lammps-stable_2Aug2023/src/npair_full_bin_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_full_bin_omp.h	2023-09-26 15:27:28.497760000 -0400
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(full/bin/omp,
+           NPairFullBinOmp,
+           NP_FULL | NP_BIN | NP_OMP | NP_NEWTON | NP_NEWTOFF |
+           NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_FULL_BIN_OMP_H
+#define LMP_NPAIR_FULL_BIN_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairFullBinOmp : public NPair {
+ public:
+  NPairFullBinOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_full_multi_old_omp.cpp ../lammps-stable_2Aug2023/src/npair_full_multi_old_omp.cpp
--- lammps-stable_2Aug2023/src/npair_full_multi_old_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_full_multi_old_omp.cpp	2023-09-26 15:27:26.718046000 -0400
@@ -0,0 +1,144 @@
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_full_multi_old_omp.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "domain.h"
+#include "error.h"
+#include "molecule.h"
+#include "my_page.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+#include "omp_compat.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairFullMultiOldOmp::NPairFullMultiOldOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   binned neighbor list construction for all neighbors
+   multi-type stencil is itype dependent and is distance checked
+   every neighbor pair appears in list of both atoms i and j
+------------------------------------------------------------------------- */
+
+void NPairFullMultiOldOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i, j, k, n, itype, jtype, ibin, which, ns, imol, iatom;
+  tagint tagprev;
+  double xtmp, ytmp, ztmp, delx, dely, delz, rsq;
+  int *neighptr, *s;
+  double *cutsq, *distsq;
+
+  // loop over each atom, storing neighbors
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over all atoms in other bins in stencil, including self
+    // skip if i,j neighbor cutoff is less than bin distance
+    // skip i = j
+
+    ibin = atom2bin[i];
+    s = stencil_multi_old[itype];
+    distsq = distsq_multi_old[itype];
+    cutsq = cutneighsq[itype];
+    ns = nstencil_multi_old[itype];
+    for (k = 0; k < ns; k++) {
+      for (j = binhead[ibin + s[k]]; j >= 0; j = bins[j]) {
+        jtype = type[j];
+        if (cutsq[jtype] < distsq[k]) continue;
+        if (i == j) continue;
+
+        if (exclude && exclusion(i, j, itype, jtype, mask, molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx * delx + dely * dely + delz * delz;
+
+        if (rsq <= cutneighsq[itype][jtype]) {
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i], nspecial[i], tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom], onemols[imol]->nspecial[iatom],
+                                   tag[j] - tagprev);
+            else
+              which = 0;
+            if (which == 0)
+              neighptr[n++] = j;
+            else if (domain->minimum_image_check(delx, dely, delz))
+              neighptr[n++] = j;
+            else if (which > 0)
+              neighptr[n++] = j ^ (which << SBBITS);
+          } else
+            neighptr[n++] = j;
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status()) error->one(FLERR, "Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+  list->gnum = 0;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_full_multi_old_omp.h ../lammps-stable_2Aug2023/src/npair_full_multi_old_omp.h
--- lammps-stable_2Aug2023/src/npair_full_multi_old_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_full_multi_old_omp.h	2023-09-26 15:27:28.501985000 -0400
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(full/multi/old/omp,
+           NPairFullMultiOldOmp,
+           NP_FULL | NP_MULTI_OLD | NP_OMP |
+           NP_NEWTON | NP_NEWTOFF | NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_FULL_MULTI_OLD_OMP_H
+#define LMP_NPAIR_FULL_MULTI_OLD_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairFullMultiOldOmp : public NPair {
+ public:
+  NPairFullMultiOldOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_full_multi_omp.cpp ../lammps-stable_2Aug2023/src/npair_full_multi_omp.cpp
--- lammps-stable_2Aug2023/src/npair_full_multi_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_full_multi_omp.cpp	2023-09-26 15:27:26.759853000 -0400
@@ -0,0 +1,154 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_full_multi_omp.h"
+#include "npair_omp.h"
+#include "neighbor.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairFullMultiOmp::NPairFullMultiOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   binned neighbor list construction for all neighbors
+   multi stencil is icollection-jcollection dependent
+   every neighbor pair appears in list of both atoms i and j
+------------------------------------------------------------------------- */
+
+void NPairFullMultiOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,k,n,itype,jtype,icollection,jcollection,ibin,jbin,which,ns,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr,*s;
+  int js;
+
+  // loop over each atom, storing neighbors
+
+  int *collection = neighbor->collection;
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    icollection = collection[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    ibin = atom2bin[i];
+
+    // loop through stencils for all collections
+    for (jcollection = 0; jcollection < ncollections; jcollection++) {
+
+      // if same collection use own bin
+      if (icollection == jcollection) jbin = ibin;
+          else jbin = coord2bin(x[i], jcollection);
+
+      // loop over all atoms in surrounding bins in stencil including self
+      // skip i = j
+      // use full stencil for all collection combinations
+
+      s = stencil_multi[icollection][jcollection];
+      ns = nstencil_multi[icollection][jcollection];
+
+      for (k = 0; k < ns; k++) {
+            js = binhead_multi[jcollection][jbin + s[k]];
+            for (j = js; j >= 0; j = bins[j]) {
+              if (i == j) continue;
+
+          jtype = type[j];
+              if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+              delx = xtmp - x[j][0];
+              dely = ytmp - x[j][1];
+              delz = ztmp - x[j][2];
+              rsq = delx*delx + dely*dely + delz*delz;
+
+              if (rsq <= cutneighsq[itype][jtype]) {
+                if (molecular != Atom::ATOMIC) {
+                  if (!moltemplate)
+                        which = find_special(special[i],nspecial[i],tag[j]);
+                  else if (imol >= 0)
+                        which = find_special(onemols[imol]->special[iatom],
+                                     onemols[imol]->nspecial[iatom],
+                                     tag[j]-tagprev);
+                  else which = 0;
+                  if (which == 0) neighptr[n++] = j;
+                  else if (domain->minimum_image_check(delx,dely,delz))
+                        neighptr[n++] = j;
+                  else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+                } else neighptr[n++] = j;
+              }
+            }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+  list->gnum = 0;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_full_multi_omp.h ../lammps-stable_2Aug2023/src/npair_full_multi_omp.h
--- lammps-stable_2Aug2023/src/npair_full_multi_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_full_multi_omp.h	2023-09-26 15:27:28.506386000 -0400
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(full/multi/omp,
+           NPairFullMultiOmp,
+           NP_FULL | NP_MULTI | NP_OMP |
+           NP_NEWTON | NP_NEWTOFF | NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_FULL_MULTI_OMP_H
+#define LMP_NPAIR_FULL_MULTI_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairFullMultiOmp : public NPair {
+ public:
+  NPairFullMultiOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_full_nsq_ghost_omp.cpp ../lammps-stable_2Aug2023/src/npair_full_nsq_ghost_omp.cpp
--- lammps-stable_2Aug2023/src/npair_full_nsq_ghost_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_full_nsq_ghost_omp.cpp	2023-09-26 15:27:26.777202000 -0400
@@ -0,0 +1,148 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_full_nsq_ghost_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairFullNsqGhostOmp::NPairFullNsqGhostOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   N^2 search for all neighbors
+   include neighbors of ghost atoms, but no "special neighbors" for ghosts
+   every neighbor pair appears in list of both atoms i and j
+------------------------------------------------------------------------- */
+
+void NPairFullNsqGhostOmp::build(NeighList *list)
+{
+  const int nlocal = atom->nlocal;
+  const int nall = nlocal + atom->nghost;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nall);
+
+  int i,j,n,itype,jtype,which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr;
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  // loop over owned & ghost atoms, storing neighbors
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over all atoms, owned and ghost
+    // skip i = j
+    // no molecular test when i = ghost atom
+
+    if (i < nlocal) {
+      for (j = 0; j < nall; j++) {
+        if (i == j) continue;
+        jtype = type[j];
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+        if (rsq <= cutneighsq[itype][jtype]) {
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = j;
+            else if (domain->minimum_image_check(delx,dely,delz))
+              neighptr[n++] = j;
+            else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+          } else neighptr[n++] = j;
+        }
+      }
+    } else {
+      for (j = 0; j < nall; j++) {
+        if (i == j) continue;
+        jtype = type[j];
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+
+        if (rsq <= cutneighghostsq[itype][jtype]) neighptr[n++] = j;
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+  list->gnum = nall - nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_full_nsq_ghost_omp.h ../lammps-stable_2Aug2023/src/npair_full_nsq_ghost_omp.h
--- lammps-stable_2Aug2023/src/npair_full_nsq_ghost_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_full_nsq_ghost_omp.h	2023-09-26 15:27:28.510605000 -0400
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(full/nsq/ghost/omp,
+           NPairFullNsqGhostOmp,
+           NP_FULL | NP_NSQ | NP_GHOST | NP_OMP | NP_NEWTON | NP_NEWTOFF |
+           NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_FULL_NSQ_GHOST_OMP_H
+#define LMP_NPAIR_FULL_NSQ_GHOST_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairFullNsqGhostOmp : public NPair {
+ public:
+  NPairFullNsqGhostOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_full_nsq_omp.cpp ../lammps-stable_2Aug2023/src/npair_full_nsq_omp.cpp
--- lammps-stable_2Aug2023/src/npair_full_nsq_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_full_nsq_omp.cpp	2023-09-26 15:27:26.787601000 -0400
@@ -0,0 +1,134 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_full_nsq_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "group.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairFullNsqOmp::NPairFullNsqOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   N^2 search for all neighbors
+   every neighbor pair appears in list of both atoms i and j
+------------------------------------------------------------------------- */
+
+void NPairFullNsqOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int bitmask = (includegroup) ? group->bitmask[includegroup] : 0;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,n,itype,jtype,which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr;
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int nall = atom->nlocal + atom->nghost;
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  // loop over owned atoms, storing neighbors
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over all atoms, owned and ghost
+    // skip i = j
+
+    for (j = 0; j < nall; j++) {
+      if (includegroup && !(mask[j] & bitmask)) continue;
+      if (i == j) continue;
+      jtype = type[j];
+      if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+      if (rsq <= cutneighsq[itype][jtype]) {
+        if (molecular != Atom::ATOMIC) {
+          if (!moltemplate)
+            which = find_special(special[i],nspecial[i],tag[j]);
+          else if (imol >= 0)
+            which = find_special(onemols[imol]->special[iatom],
+                                 onemols[imol]->nspecial[iatom],
+                                 tag[j]-tagprev);
+          else which = 0;
+          if (which == 0) neighptr[n++] = j;
+          else if (domain->minimum_image_check(delx,dely,delz))
+            neighptr[n++] = j;
+          else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+        } else neighptr[n++] = j;
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+  list->gnum = 0;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_full_nsq_omp.h ../lammps-stable_2Aug2023/src/npair_full_nsq_omp.h
--- lammps-stable_2Aug2023/src/npair_full_nsq_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_full_nsq_omp.h	2023-09-26 15:27:28.514791000 -0400
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(full/nsq/omp,
+           NPairFullNsqOmp,
+           NP_FULL | NP_NSQ | NP_OMP | NP_NEWTON | NP_NEWTOFF |
+           NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_FULL_NSQ_OMP_H
+#define LMP_NPAIR_FULL_NSQ_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairFullNsqOmp : public NPair {
+ public:
+  NPairFullNsqOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_bin_atomonly_newton.cpp ../lammps-stable_2Aug2023/src/npair_half_bin_atomonly_newton.cpp
--- lammps-stable_2Aug2023/src/npair_half_bin_atomonly_newton.cpp	2023-08-03 11:33:14.000000000 -0400
+++ ../lammps-stable_2Aug2023/src/npair_half_bin_atomonly_newton.cpp	2023-11-29 18:15:02.563325000 -0500
@@ -18,6 +18,7 @@
 #include "my_page.h"
 #include "neigh_list.h"
 
+
 using namespace LAMMPS_NS;
 
 /* ---------------------------------------------------------------------- */
diff -ruN lammps-stable_2Aug2023/src/npair_half_bin_atomonly_newton_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_bin_atomonly_newton_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_bin_atomonly_newton_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_bin_atomonly_newton_omp.cpp	2024-04-12 01:37:40.510274457 -0400
@@ -0,0 +1,135 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_half_bin_atomonly_newton_omp.h"
+
+#include "atom.h"
+#include "error.h"
+#include "my_page.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+
+#if defined APPEKG
+#include "appekg.h"
+#endif
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfBinAtomonlyNewtonOmp::NPairHalfBinAtomonlyNewtonOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   binned neighbor list construction with full Newton's 3rd law
+   each owned atom i checks its own bin and other bins in Newton stencil
+   every pair stored exactly once by some processor
+------------------------------------------------------------------------- */
+
+void NPairHalfBinAtomonlyNewtonOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,k,n,itype,jtype,ibin;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr;
+
+  // loop over each atom, storing neighbors
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *molecule = atom->molecule;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+#if defined APPEKG
+     EKG_BEGIN_HEARTBEAT(1,65100);
+#endif
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+
+    // loop over rest of atoms in i's bin, ghosts are at end of linked list
+    // if j is owned atom, store it, since j is beyond i in linked list
+    // if j is ghost, only store if j coords are "above and to the right" of i
+
+    for (j = bins[i]; j >= 0; j = bins[j]) {
+      if (j >= nlocal) {
+        if (x[j][2] < ztmp) continue;
+        if (x[j][2] == ztmp) {
+          if (x[j][1] < ytmp) continue;
+          if (x[j][1] == ytmp && x[j][0] < xtmp) continue;
+        }
+      }
+
+      jtype = type[j];
+      if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+
+      if (rsq <= cutneighsq[itype][jtype]) neighptr[n++] = j;
+    }
+
+    // loop over all atoms in other bins in stencil, store every pair
+
+    ibin = atom2bin[i];
+    for (k = 0; k < nstencil; k++) {
+      for (j = binhead[ibin+stencil[k]]; j >= 0; j = bins[j]) {
+        jtype = type[j];
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+
+        if (rsq <= cutneighsq[itype][jtype]) neighptr[n++] = j;
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+#if defined APPEKG
+    EKG_END_HEARTBEAT(1);
+#endif  
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_bin_atomonly_newton_omp.h ../lammps-stable_2Aug2023/src/npair_half_bin_atomonly_newton_omp.h
--- lammps-stable_2Aug2023/src/npair_half_bin_atomonly_newton_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_bin_atomonly_newton_omp.h	2023-09-26 15:27:28.519035000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/bin/atomonly/newton/omp,
+           NPairHalfBinAtomonlyNewtonOmp,
+           NP_HALF | NP_BIN | NP_ATOMONLY | NP_NEWTON | NP_OMP | NP_ORTHO);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_BIN_ATOMONLY_NEWTON_OMP_H
+#define LMP_NPAIR_HALF_BIN_ATOMONLY_NEWTON_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfBinAtomonlyNewtonOmp : public NPair {
+ public:
+  NPairHalfBinAtomonlyNewtonOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_bin_newtoff_ghost_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_bin_newtoff_ghost_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_bin_newtoff_ghost_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_bin_newtoff_ghost_omp.cpp	2023-09-26 15:27:26.812181000 -0400
@@ -0,0 +1,174 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_bin_newtoff_ghost_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfBinNewtoffGhostOmp::NPairHalfBinNewtoffGhostOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   binned neighbor list construction with partial Newton's 3rd law
+   include neighbors of ghost atoms, but no "special neighbors" for ghosts
+   owned and ghost atoms check own bin and other bins in stencil
+   pair stored once if i,j are both owned and i < j
+   pair stored by me if i owned and j ghost (also stored by proc owning j)
+   pair stored once if i,j are both ghost and i < j
+------------------------------------------------------------------------- */
+
+void NPairHalfBinNewtoffGhostOmp::build(NeighList *list)
+{
+  const int nlocal = atom->nlocal;
+  const int nall = nlocal + atom->nghost;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nall);
+
+  int i,j,k,n,itype,jtype,ibin,which,imol,iatom;
+  tagint tagprev;
+  int xbin,ybin,zbin,xbin2,ybin2,zbin2;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr;
+
+  // loop over each atom, storing neighbors
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over all atoms in other bins in stencil including self
+    // when i is a ghost atom, must check if stencil bin is out of bounds
+    // only store pair if i < j
+    // stores own/own pairs only once
+    // stores own/ghost pairs with owned atom only, on both procs
+    // stores ghost/ghost pairs only once
+    // no molecular test when i = ghost atom
+
+    if (i < nlocal) {
+      ibin = atom2bin[i];
+
+      for (k = 0; k < nstencil; k++) {
+        for (j = binhead[ibin+stencil[k]]; j >= 0; j = bins[j]) {
+          if (j <= i) continue;
+
+          jtype = type[j];
+          if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+          delx = xtmp - x[j][0];
+          dely = ytmp - x[j][1];
+          delz = ztmp - x[j][2];
+          rsq = delx*delx + dely*dely + delz*delz;
+
+          if (rsq <= cutneighsq[itype][jtype]) {
+            if (molecular != Atom::ATOMIC) {
+              if (!moltemplate)
+                which = find_special(special[i],nspecial[i],tag[j]);
+              else if (imol >= 0)
+                which = find_special(onemols[imol]->special[iatom],
+                                     onemols[imol]->nspecial[iatom],
+                                     tag[j]-tagprev);
+              else which = 0;
+              if (which == 0) neighptr[n++] = j;
+              else if (domain->minimum_image_check(delx,dely,delz))
+                neighptr[n++] = j;
+              else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+            } else neighptr[n++] = j;
+          }
+        }
+      }
+
+    } else {
+      ibin = coord2bin(x[i],xbin,ybin,zbin);
+      for (k = 0; k < nstencil; k++) {
+        xbin2 = xbin + stencilxyz[k][0];
+        ybin2 = ybin + stencilxyz[k][1];
+        zbin2 = zbin + stencilxyz[k][2];
+        if (xbin2 < 0 || xbin2 >= mbinx ||
+            ybin2 < 0 || ybin2 >= mbiny ||
+            zbin2 < 0 || zbin2 >= mbinz) continue;
+        for (j = binhead[ibin+stencil[k]]; j >= 0; j = bins[j]) {
+          if (j <= i) continue;
+
+          jtype = type[j];
+          if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+          delx = xtmp - x[j][0];
+          dely = ytmp - x[j][1];
+          delz = ztmp - x[j][2];
+          rsq = delx*delx + dely*dely + delz*delz;
+
+          if (rsq <= cutneighghostsq[itype][jtype]) neighptr[n++] = j;
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+  list->gnum = nall - atom->nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_bin_newtoff_ghost_omp.h ../lammps-stable_2Aug2023/src/npair_half_bin_newtoff_ghost_omp.h
--- lammps-stable_2Aug2023/src/npair_half_bin_newtoff_ghost_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_bin_newtoff_ghost_omp.h	2023-09-26 15:27:28.523243000 -0400
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/bin/newtoff/ghost/omp,
+           NPairHalfBinNewtoffGhostOmp,
+           NP_HALF | NP_BIN | NP_NEWTOFF | NP_GHOST | NP_OMP |
+           NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_BIN_NEWTOFF_GHOST_OMP_H
+#define LMP_NPAIR_HALF_BIN_NEWTOFF_GHOST_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfBinNewtoffGhostOmp : public NPair {
+ public:
+  NPairHalfBinNewtoffGhostOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_bin_newtoff_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_bin_newtoff_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_bin_newtoff_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_bin_newtoff_omp.cpp	2023-09-26 15:27:26.835074000 -0400
@@ -0,0 +1,139 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_bin_newtoff_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfBinNewtoffOmp::NPairHalfBinNewtoffOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   binned neighbor list construction with partial Newton's 3rd law
+   each owned atom i checks own bin and other bins in stencil
+   pair stored once if i,j are both owned and i < j
+   pair stored by me if j is ghost (also stored by proc owning j)
+------------------------------------------------------------------------- */
+
+void NPairHalfBinNewtoffOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,k,n,itype,jtype,ibin,which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr;
+
+  // loop over each atom, storing neighbors
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over all atoms in other bins in stencil including self
+    // only store pair if i < j
+    // stores own/own pairs only once
+    // stores own/ghost pairs on both procs
+
+    ibin = atom2bin[i];
+
+    for (k = 0; k < nstencil; k++) {
+      for (j = binhead[ibin+stencil[k]]; j >= 0; j = bins[j]) {
+        if (j <= i) continue;
+
+        jtype = type[j];
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+
+        if (rsq <= cutneighsq[itype][jtype]) {
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = j;
+            else if (domain->minimum_image_check(delx,dely,delz))
+              neighptr[n++] = j;
+            else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+          } else neighptr[n++] = j;
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_bin_newtoff_omp.h ../lammps-stable_2Aug2023/src/npair_half_bin_newtoff_omp.h
--- lammps-stable_2Aug2023/src/npair_half_bin_newtoff_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_bin_newtoff_omp.h	2023-09-26 15:27:28.527628000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/bin/newtoff/omp,
+           NPairHalfBinNewtoffOmp,
+           NP_HALF | NP_BIN | NP_NEWTOFF | NP_OMP | NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_BIN_NEWTOFF_OMP_H
+#define LMP_NPAIR_HALF_BIN_NEWTOFF_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfBinNewtoffOmp : public NPair {
+ public:
+  NPairHalfBinNewtoffOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_bin_newton_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_bin_newton_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_bin_newton_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_bin_newton_omp.cpp	2023-09-26 15:27:26.849378000 -0400
@@ -0,0 +1,172 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_bin_newton_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfBinNewtonOmp::NPairHalfBinNewtonOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   binned neighbor list construction with full Newton's 3rd law
+   each owned atom i checks its own bin and other bins in Newton stencil
+   every pair stored exactly once by some processor
+------------------------------------------------------------------------- */
+
+void NPairHalfBinNewtonOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,k,n,itype,jtype,ibin,which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr;
+
+  // loop over each atom, storing neighbors
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over rest of atoms in i's bin, ghosts are at end of linked list
+    // if j is owned atom, store it, since j is beyond i in linked list
+    // if j is ghost, only store if j coords are "above and to the right" of i
+
+    for (j = bins[i]; j >= 0; j = bins[j]) {
+      if (j >= nlocal) {
+        if (x[j][2] < ztmp) continue;
+        if (x[j][2] == ztmp) {
+          if (x[j][1] < ytmp) continue;
+          if (x[j][1] == ytmp && x[j][0] < xtmp) continue;
+        }
+      }
+
+      jtype = type[j];
+      if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+
+      if (rsq <= cutneighsq[itype][jtype]) {
+        if (molecular != Atom::ATOMIC) {
+          if (!moltemplate)
+            which = find_special(special[i],nspecial[i],tag[j]);
+          else if (imol >= 0)
+            which = find_special(onemols[imol]->special[iatom],
+                                 onemols[imol]->nspecial[iatom],
+                                 tag[j]-tagprev);
+          else which = 0;
+          if (which == 0) neighptr[n++] = j;
+          else if (domain->minimum_image_check(delx,dely,delz))
+            neighptr[n++] = j;
+          else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+          // OLD: if (which >= 0) neighptr[n++] = j ^ (which << SBBITS);
+        } else neighptr[n++] = j;
+      }
+    }
+
+    // loop over all atoms in other bins in stencil, store every pair
+
+    ibin = atom2bin[i];
+    for (k = 0; k < nstencil; k++) {
+      for (j = binhead[ibin+stencil[k]]; j >= 0; j = bins[j]) {
+        jtype = type[j];
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+
+        if (rsq <= cutneighsq[itype][jtype]) {
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = j;
+            else if (domain->minimum_image_check(delx,dely,delz))
+              neighptr[n++] = j;
+            else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+            // OLD: if (which >= 0) neighptr[n++] = j ^ (which << SBBITS);
+          } else neighptr[n++] = j;
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_bin_newton_omp.h ../lammps-stable_2Aug2023/src/npair_half_bin_newton_omp.h
--- lammps-stable_2Aug2023/src/npair_half_bin_newton_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_bin_newton_omp.h	2023-09-26 15:27:28.531923000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/bin/newton/omp,
+           NPairHalfBinNewtonOmp,
+           NP_HALF | NP_BIN | NP_NEWTON | NP_OMP | NP_ORTHO);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_BIN_NEWTON_OMP_H
+#define LMP_NPAIR_HALF_BIN_NEWTON_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfBinNewtonOmp : public NPair {
+ public:
+  NPairHalfBinNewtonOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_bin_newton_tri_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_bin_newton_tri_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_bin_newton_tri_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_bin_newton_tri_omp.cpp	2023-09-26 15:27:26.867645000 -0400
@@ -0,0 +1,145 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_bin_newton_tri_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfBinNewtonTriOmp::NPairHalfBinNewtonTriOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   binned neighbor list construction with Newton's 3rd law for triclinic
+   each owned atom i checks its own bin and other bins in triclinic stencil
+   every pair stored exactly once by some processor
+------------------------------------------------------------------------- */
+
+void NPairHalfBinNewtonTriOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,k,n,itype,jtype,ibin,which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr;
+
+  // loop over each atom, storing neighbors
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over all atoms in bins in stencil
+    // pairs for atoms j "below" i are excluded
+    // below = lower z or (equal z and lower y) or (equal zy and lower x)
+    //         (equal zyx and j <= i)
+    // latter excludes self-self interaction but allows superposed atoms
+
+    ibin = atom2bin[i];
+    for (k = 0; k < nstencil; k++) {
+      for (j = binhead[ibin+stencil[k]]; j >= 0; j = bins[j]) {
+        if (x[j][2] < ztmp) continue;
+        if (x[j][2] == ztmp) {
+          if (x[j][1] < ytmp) continue;
+          if (x[j][1] == ytmp) {
+            if (x[j][0] < xtmp) continue;
+            if (x[j][0] == xtmp && j <= i) continue;
+          }
+        }
+
+        jtype = type[j];
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+
+        if (rsq <= cutneighsq[itype][jtype]) {
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = j;
+            else if (domain->minimum_image_check(delx,dely,delz))
+              neighptr[n++] = j;
+            else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+          } else neighptr[n++] = j;
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_bin_newton_tri_omp.h ../lammps-stable_2Aug2023/src/npair_half_bin_newton_tri_omp.h
--- lammps-stable_2Aug2023/src/npair_half_bin_newton_tri_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_bin_newton_tri_omp.h	2023-09-26 15:27:28.536203000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/bin/newton/tri/omp,
+           NPairHalfBinNewtonTriOmp,
+           NP_HALF | NP_BIN | NP_NEWTON | NP_TRI | NP_OMP);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_BIN_NEWTON_TRI_OMP_H
+#define LMP_NPAIR_HALF_BIN_NEWTON_TRI_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfBinNewtonTriOmp : public NPair {
+ public:
+  NPairHalfBinNewtonTriOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_halffull_newtoff_omp.cpp ../lammps-stable_2Aug2023/src/npair_halffull_newtoff_omp.cpp
--- lammps-stable_2Aug2023/src/npair_halffull_newtoff_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_halffull_newtoff_omp.cpp	2023-09-26 15:27:27.535299000 -0400
@@ -0,0 +1,90 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_halffull_newtoff_omp.h"
+
+#include "error.h"
+#include "my_page.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalffullNewtoffOmp::NPairHalffullNewtoffOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   build half list from full list
+   pair stored once if i,j are both owned and i < j
+   pair stored by me if j is ghost (also stored by proc owning j)
+   works if full list is a skip list
+------------------------------------------------------------------------- */
+
+void NPairHalffullNewtoffOmp::build(NeighList *list)
+{
+  const int inum_full = list->listfull->inum;
+
+  NPAIR_OMP_INIT;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(inum_full);
+
+  int i,j,ii,jj,n,jnum,joriginal;
+  int *neighptr,*jlist;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+  int *ilist_full = list->listfull->ilist;
+  int *numneigh_full = list->listfull->numneigh;
+  int **firstneigh_full = list->listfull->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  // loop over atoms in full list
+
+  for (ii = ifrom; ii < ito; ii++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    // loop over parent full list
+
+    i = ilist_full[ii];
+    jlist = firstneigh_full[i];
+    jnum = numneigh_full[i];
+
+    for (jj = 0; jj < jnum; jj++) {
+      joriginal = jlist[jj];
+      j = joriginal & NEIGHMASK;
+      if (j > i) neighptr[n++] = joriginal;
+    }
+
+    ilist[ii] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = inum_full;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_halffull_newtoff_omp.h ../lammps-stable_2Aug2023/src/npair_halffull_newtoff_omp.h
--- lammps-stable_2Aug2023/src/npair_halffull_newtoff_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_halffull_newtoff_omp.h	2023-09-26 15:27:28.660045000 -0400
@@ -0,0 +1,44 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(halffull/newtoff/omp,
+           NPairHalffullNewtoffOmp,
+           NP_HALF_FULL | NP_NEWTOFF | NP_NSQ | NP_BIN | NP_MULTI | NP_MULTI_OLD | NP_HALF |
+           NP_ORTHO | NP_TRI |NP_OMP);
+
+NPairStyle(halffull/newtoff/skip/omp,
+           NPairHalffullNewtoffOmp,
+           NP_HALF_FULL | NP_NEWTOFF | NP_NSQ | NP_BIN | NP_MULTI | NP_MULTI_OLD | NP_HALF |
+           NP_ORTHO | NP_TRI | NP_SKIP | NP_OMP);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALFFULL_NEWTOFF_OMP_H
+#define LMP_NPAIR_HALFFULL_NEWTOFF_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalffullNewtoffOmp : public NPair {
+ public:
+  NPairHalffullNewtoffOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_halffull_newtoff_trim_omp.cpp ../lammps-stable_2Aug2023/src/npair_halffull_newtoff_trim_omp.cpp
--- lammps-stable_2Aug2023/src/npair_halffull_newtoff_trim_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_halffull_newtoff_trim_omp.cpp	2023-09-26 15:27:27.539842000 -0400
@@ -0,0 +1,111 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_halffull_newtoff_trim_omp.h"
+
+#include "atom.h"
+#include "error.h"
+#include "my_page.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalffullNewtoffTrimOmp::NPairHalffullNewtoffTrimOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   build half list from full list and trim to shorter cutoff
+   pair stored once if i,j are both owned and i < j
+   pair stored by me if j is ghost (also stored by proc owning j)
+   works if full list is a skip list
+------------------------------------------------------------------------- */
+
+void NPairHalffullNewtoffTrimOmp::build(NeighList *list)
+{
+  const int inum_full = list->listfull->inum;
+
+  NPAIR_OMP_INIT;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(inum_full);
+
+  int i,j,ii,jj,n,jnum,joriginal;
+  int *neighptr,*jlist;
+  double xtmp,ytmp,ztmp;
+  double delx,dely,delz,rsq;
+
+  double **x = atom->x;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+  int *ilist_full = list->listfull->ilist;
+  int *numneigh_full = list->listfull->numneigh;
+  int **firstneigh_full = list->listfull->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  double cutsq_custom = cutoff_custom * cutoff_custom;
+
+  // loop over atoms in full list
+
+  for (ii = ifrom; ii < ito; ii++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    // loop over parent full list
+
+    i = ilist_full[ii];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+
+    jlist = firstneigh_full[i];
+    jnum = numneigh_full[i];
+
+    for (jj = 0; jj < jnum; jj++) {
+      joriginal = jlist[jj];
+      j = joriginal & NEIGHMASK;
+
+      // trim to shorter cutoff
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx * delx + dely * dely + delz * delz;
+
+      if (rsq > cutsq_custom) continue;
+
+      if (j > i) neighptr[n++] = joriginal;
+    }
+
+    ilist[ii] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = inum_full;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_halffull_newtoff_trim_omp.h ../lammps-stable_2Aug2023/src/npair_halffull_newtoff_trim_omp.h
--- lammps-stable_2Aug2023/src/npair_halffull_newtoff_trim_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_halffull_newtoff_trim_omp.h	2023-09-26 15:27:28.664376000 -0400
@@ -0,0 +1,44 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(halffull/newtoff/trim/omp,
+           NPairHalffullNewtoffTrimOmp,
+           NP_HALF_FULL | NP_NEWTOFF | NP_NSQ | NP_BIN | NP_MULTI | NP_MULTI_OLD | NP_HALF |
+           NP_ORTHO | NP_TRI | NP_TRIM | NP_OMP);
+
+NPairStyle(halffull/newtoff/skip/trim/omp,
+           NPairHalffullNewtoffTrimOmp,
+           NP_HALF_FULL | NP_NEWTOFF | NP_NSQ | NP_BIN | NP_MULTI | NP_MULTI_OLD | NP_HALF |
+           NP_ORTHO | NP_TRI | NP_SKIP | NP_TRIM | NP_OMP);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALFFULL_NEWTOFF_TRIM_OMP_H
+#define LMP_NPAIR_HALFFULL_NEWTOFF_TRIM_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalffullNewtoffTrimOmp : public NPair {
+ public:
+  NPairHalffullNewtoffTrimOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_halffull_newton_omp.cpp ../lammps-stable_2Aug2023/src/npair_halffull_newton_omp.cpp
--- lammps-stable_2Aug2023/src/npair_halffull_newton_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_halffull_newton_omp.cpp	2023-09-26 15:27:27.544032000 -0400
@@ -0,0 +1,107 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_halffull_newton_omp.h"
+
+#include "atom.h"
+#include "error.h"
+#include "my_page.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalffullNewtonOmp::NPairHalffullNewtonOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   build half list from full list
+   pair stored once if i,j are both owned and i < j
+   if j is ghost, only store if j coords are "above and to the right" of i
+   works if full list is a skip list
+------------------------------------------------------------------------- */
+
+void NPairHalffullNewtonOmp::build(NeighList *list)
+{
+  const int inum_full = list->listfull->inum;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(inum_full);
+
+  int i,j,ii,jj,n,jnum,joriginal;
+  int *neighptr,*jlist;
+  double xtmp,ytmp,ztmp;
+
+  double **x = atom->x;
+  int nlocal = atom->nlocal;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+  int *ilist_full = list->listfull->ilist;
+  int *numneigh_full = list->listfull->numneigh;
+  int **firstneigh_full = list->listfull->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  // loop over parent full list
+
+  for (ii = ifrom; ii < ito; ii++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    i = ilist_full[ii];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+
+    // loop over full neighbor list
+
+    jlist = firstneigh_full[i];
+    jnum = numneigh_full[i];
+
+    for (jj = 0; jj < jnum; jj++) {
+      joriginal = jlist[jj];
+      j = joriginal & NEIGHMASK;
+      if (j < nlocal) {
+        if (i > j) continue;
+      } else {
+        if (x[j][2] < ztmp) continue;
+        if (x[j][2] == ztmp) {
+          if (x[j][1] < ytmp) continue;
+          if (x[j][1] == ytmp && x[j][0] < xtmp) continue;
+        }
+      }
+      neighptr[n++] = joriginal;
+    }
+
+    ilist[ii] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = inum_full;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_halffull_newton_omp.h ../lammps-stable_2Aug2023/src/npair_halffull_newton_omp.h
--- lammps-stable_2Aug2023/src/npair_halffull_newton_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_halffull_newton_omp.h	2023-09-26 15:27:28.669102000 -0400
@@ -0,0 +1,44 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(halffull/newton/omp,
+           NPairHalffullNewtonOmp,
+           NP_HALF_FULL | NP_NEWTON | NP_HALF | NP_NSQ | NP_BIN | NP_MULTI | NP_MULTI_OLD |
+           NP_ORTHO | NP_TRI| NP_OMP);
+
+NPairStyle(halffull/newton/skip/omp,
+           NPairHalffullNewtonOmp,
+           NP_HALF_FULL | NP_NEWTON | NP_HALF | NP_NSQ | NP_BIN | NP_MULTI | NP_MULTI_OLD |
+           NP_ORTHO | NP_TRI | NP_SKIP | NP_OMP);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALFFULL_NEWTON_OMP_H
+#define LMP_NPAIR_HALFFULL_NEWTON_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalffullNewtonOmp : public NPair {
+ public:
+  NPairHalffullNewtonOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_halffull_newton_trim_omp.cpp ../lammps-stable_2Aug2023/src/npair_halffull_newton_trim_omp.cpp
--- lammps-stable_2Aug2023/src/npair_halffull_newton_trim_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_halffull_newton_trim_omp.cpp	2023-09-26 15:27:27.548238000 -0400
@@ -0,0 +1,120 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_halffull_newton_trim_omp.h"
+
+#include "atom.h"
+#include "error.h"
+#include "my_page.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalffullNewtonTrimOmp::NPairHalffullNewtonTrimOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   build half list from full list and trim to shorter cutoff
+   pair stored once if i,j are both owned and i < j
+   if j is ghost, only store if j coords are "above and to the right" of i
+   works if full list is a skip list
+------------------------------------------------------------------------- */
+
+void NPairHalffullNewtonTrimOmp::build(NeighList *list)
+{
+  const int inum_full = list->listfull->inum;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(inum_full);
+
+  int i,j,ii,jj,n,jnum,joriginal;
+  int *neighptr,*jlist;
+  double xtmp,ytmp,ztmp;
+  double delx,dely,delz,rsq;
+
+  double **x = atom->x;
+  int nlocal = atom->nlocal;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+  int *ilist_full = list->listfull->ilist;
+  int *numneigh_full = list->listfull->numneigh;
+  int **firstneigh_full = list->listfull->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  double cutsq_custom = cutoff_custom * cutoff_custom;
+
+  // loop over parent full list
+
+  for (ii = ifrom; ii < ito; ii++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    i = ilist_full[ii];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+
+    // loop over full neighbor list
+
+    jlist = firstneigh_full[i];
+    jnum = numneigh_full[i];
+
+    for (jj = 0; jj < jnum; jj++) {
+      joriginal = jlist[jj];
+      j = joriginal & NEIGHMASK;
+      if (j < nlocal) {
+        if (i > j) continue;
+      } else {
+        if (x[j][2] < ztmp) continue;
+        if (x[j][2] == ztmp) {
+          if (x[j][1] < ytmp) continue;
+          if (x[j][1] == ytmp && x[j][0] < xtmp) continue;
+        }
+      }
+
+      // trim to shorter cutoff
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx * delx + dely * dely + delz * delz;
+
+      if (rsq > cutsq_custom) continue;
+
+      neighptr[n++] = joriginal;
+    }
+
+    ilist[ii] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = inum_full;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_halffull_newton_trim_omp.h ../lammps-stable_2Aug2023/src/npair_halffull_newton_trim_omp.h
--- lammps-stable_2Aug2023/src/npair_halffull_newton_trim_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_halffull_newton_trim_omp.h	2023-09-26 15:27:28.673359000 -0400
@@ -0,0 +1,44 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(halffull/newton/trim/omp,
+           NPairHalffullNewtonTrimOmp,
+           NP_HALF_FULL | NP_NEWTON | NP_HALF | NP_NSQ | NP_BIN | NP_MULTI | NP_MULTI_OLD |
+           NP_ORTHO | NP_TRI| NP_TRIM | NP_OMP);
+
+NPairStyle(halffull/newton/skip/trim/omp,
+           NPairHalffullNewtonTrimOmp,
+           NP_HALF_FULL | NP_NEWTON | NP_HALF | NP_NSQ | NP_BIN | NP_MULTI | NP_MULTI_OLD |
+           NP_ORTHO | NP_TRI | NP_SKIP | NP_TRIM | NP_OMP);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALFFULL_NEWTON_TRIM_OMP_H
+#define LMP_NPAIR_HALFFULL_NEWTON_TRIM_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalffullNewtonTrimOmp : public NPair {
+ public:
+  NPairHalffullNewtonTrimOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_multi_newtoff_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_multi_newtoff_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_multi_newtoff_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_multi_newtoff_omp.cpp	2023-09-26 15:27:26.885566000 -0400
@@ -0,0 +1,157 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_multi_newtoff_omp.h"
+#include "npair_omp.h"
+#include "neighbor.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfMultiNewtoffOmp::NPairHalfMultiNewtoffOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   binned neighbor list construction with partial Newton's 3rd law
+   multi stencil is icollection-jcollection dependent
+   each owned atom i checks own bin and other bins in stencil
+   pair stored once if i,j are both owned and i < j
+   pair stored by me if j is ghost (also stored by proc owning j)
+------------------------------------------------------------------------- */
+
+void NPairHalfMultiNewtoffOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,k,n,itype,jtype,icollection,jcollection,ibin,jbin,which,ns,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr,*s;
+  int js;
+
+  // loop over each atom, storing neighbors
+
+  int *collection = neighbor->collection;
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    icollection = collection[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    ibin = atom2bin[i];
+
+    // loop through stencils for all collections
+    for (jcollection = 0; jcollection < ncollections; jcollection++) {
+
+      // if same collection use own bin
+      if (icollection == jcollection) jbin = ibin;
+          else jbin = coord2bin(x[i], jcollection);
+
+      // loop over all atoms in other bins in stencil including self
+      // only store pair if i < j
+      // stores own/own pairs only once
+      // stores own/ghost pairs on both procs
+      // use full stencil for all collection combinations
+
+      s = stencil_multi[icollection][jcollection];
+      ns = nstencil_multi[icollection][jcollection];
+
+      for (k = 0; k < ns; k++) {
+            js = binhead_multi[jcollection][jbin + s[k]];
+            for (j = js; j >= 0; j = bins[j]) {
+              if (j <= i) continue;
+
+          jtype = type[j];
+              if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+              delx = xtmp - x[j][0];
+              dely = ytmp - x[j][1];
+              delz = ztmp - x[j][2];
+          rsq = delx*delx + dely*dely + delz*delz;
+
+          if (rsq <= cutneighsq[itype][jtype]) {
+            if (molecular != Atom::ATOMIC) {
+              if (!moltemplate)
+                which = find_special(special[i],nspecial[i],tag[j]);
+              else if (imol >= 0)
+                which = find_special(onemols[imol]->special[iatom],
+                                     onemols[imol]->nspecial[iatom],
+                                     tag[j]-tagprev);
+              else which = 0;
+              if (which == 0) neighptr[n++] = j;
+              else if (domain->minimum_image_check(delx,dely,delz))
+                neighptr[n++] = j;
+              else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+            } else neighptr[n++] = j;
+          }
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_multi_newtoff_omp.h ../lammps-stable_2Aug2023/src/npair_half_multi_newtoff_omp.h
--- lammps-stable_2Aug2023/src/npair_half_multi_newtoff_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_multi_newtoff_omp.h	2023-09-26 15:27:28.540703000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/multi/newtoff/omp,
+           NPairHalfMultiNewtoffOmp,
+           NP_HALF | NP_MULTI | NP_NEWTOFF | NP_OMP | NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_MULTI_NEWTOFF_OMP_H
+#define LMP_NPAIR_HALF_MULTI_NEWTOFF_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfMultiNewtoffOmp : public NPair {
+ public:
+  NPairHalfMultiNewtoffOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_multi_newton_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_multi_newton_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_multi_newton_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_multi_newton_omp.cpp	2023-09-26 15:27:26.924083000 -0400
@@ -0,0 +1,205 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_multi_newton_omp.h"
+#include "npair_omp.h"
+#include "neighbor.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfMultiNewtonOmp::NPairHalfMultiNewtonOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   binned neighbor list construction with full Newton's 3rd law
+   multi stencil is icollection-jcollection dependent
+   each owned atom i checks its own bin and other bins in Newton stencil
+   every pair stored exactly once by some processor
+------------------------------------------------------------------------- */
+
+void NPairHalfMultiNewtonOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,k,n,itype,jtype,icollection,jcollection,ibin,jbin,which,ns,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr,*s;
+  int js;
+
+  // loop over each atom, storing neighbors
+
+  int *collection = neighbor->collection;
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    icollection = collection[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    ibin = atom2bin[i];
+
+    // loop through stencils for all collections
+    for (jcollection = 0; jcollection < ncollections; jcollection++) {
+
+      // if same collection use own bin
+      if (icollection == jcollection) jbin = ibin;
+          else jbin = coord2bin(x[i], jcollection);
+
+      // if same size: uses half stencil so check central bin
+      if (cutcollectionsq[icollection][icollection] == cutcollectionsq[jcollection][jcollection]){
+
+        if (icollection == jcollection) js = bins[i];
+        else js = binhead_multi[jcollection][jbin];
+
+        // if same collection,
+        //   if j is owned atom, store it, since j is beyond i in linked list
+        //   if j is ghost, only store if j coords are "above and to the right" of i
+
+        // if different collections,
+        //   if j is owned atom, store it if j > i
+        //   if j is ghost, only store if j coords are "above and to the right" of i
+
+            for (j = js; j >= 0; j = bins[j]) {
+          if ((icollection != jcollection) && (j < i)) continue;
+
+              if (j >= nlocal) {
+                if (x[j][2] < ztmp) continue;
+                if (x[j][2] == ztmp) {
+                  if (x[j][1] < ytmp) continue;
+                  if (x[j][1] == ytmp && x[j][0] < xtmp) continue;
+                }
+              }
+
+          jtype = type[j];
+          if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+              delx = xtmp - x[j][0];
+              dely = ytmp - x[j][1];
+              delz = ztmp - x[j][2];
+              rsq = delx*delx + dely*dely + delz*delz;
+
+              if (rsq <= cutneighsq[itype][jtype]) {
+                if (molecular) {
+                  if (!moltemplate)
+                    which = find_special(special[i],nspecial[i],tag[j]);
+                  else if (imol >= 0)
+                    which = find_special(onemols[imol]->special[iatom],
+                               onemols[imol]->nspecial[iatom],
+                               tag[j]-tagprev);
+                  else which = 0;
+                  if (which == 0) neighptr[n++] = j;
+                  else if (domain->minimum_image_check(delx,dely,delz))
+                    neighptr[n++] = j;
+                  else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+                } else neighptr[n++] = j;
+              }
+            }
+      }
+
+      // for all collections, loop over all atoms in other bins in stencil, store every pair
+      // stencil is empty if i larger than j
+      // stencil is half if i same size as j
+      // stencil is full if i smaller than j
+
+          s = stencil_multi[icollection][jcollection];
+          ns = nstencil_multi[icollection][jcollection];
+
+          for (k = 0; k < ns; k++) {
+            js = binhead_multi[jcollection][jbin + s[k]];
+            for (j = js; j >= 0; j = bins[j]) {
+
+          jtype = type[j];
+          if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+              delx = xtmp - x[j][0];
+              dely = ytmp - x[j][1];
+              delz = ztmp - x[j][2];
+              rsq = delx*delx + dely*dely + delz*delz;
+
+              if (rsq <= cutneighsq[itype][jtype]) {
+                if (molecular != Atom::ATOMIC) {
+                    if (!moltemplate)
+                      which = find_special(special[i],nspecial[i],tag[j]);
+                    else if (imol >= 0)
+                      which = find_special(onemols[imol]->special[iatom],
+                                       onemols[imol]->nspecial[iatom],
+                                       tag[j]-tagprev);
+                    else which = 0;
+                    if (which == 0) neighptr[n++] = j;
+                    else if (domain->minimum_image_check(delx,dely,delz))
+                      neighptr[n++] = j;
+                    else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+                } else neighptr[n++] = j;
+              }
+            }
+          }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_multi_newton_omp.h ../lammps-stable_2Aug2023/src/npair_half_multi_newton_omp.h
--- lammps-stable_2Aug2023/src/npair_half_multi_newton_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_multi_newton_omp.h	2023-09-26 15:27:28.546138000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/multi/newton/omp,
+           NPairHalfMultiNewtonOmp,
+           NP_HALF | NP_MULTI | NP_NEWTON | NP_OMP | NP_ORTHO);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_MULTI_NEWTON_OMP_H
+#define LMP_NPAIR_HALF_MULTI_NEWTON_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfMultiNewtonOmp : public NPair {
+ public:
+  NPairHalfMultiNewtonOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_multi_newton_tri_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_multi_newton_tri_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_multi_newton_tri_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_multi_newton_tri_omp.cpp	2023-09-26 15:27:26.958404000 -0400
@@ -0,0 +1,171 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_multi_newton_tri_omp.h"
+#include "npair_omp.h"
+#include "neighbor.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfMultiNewtonTriOmp::NPairHalfMultiNewtonTriOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   binned neighbor list construction with Newton's 3rd law for triclinic
+   multi stencil is icollection-jcollection dependent
+   each owned atom i checks its own bin and other bins in triclinic stencil
+   every pair stored exactly once by some processor
+------------------------------------------------------------------------- */
+
+void NPairHalfMultiNewtonTriOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,k,n,itype,jtype,ibin,jbin,icollection,jcollection,which,ns,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr,*s;
+  int js;
+
+  // loop over each atom, storing neighbors
+
+  int *collection = neighbor->collection;
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    icollection = collection[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    ibin = atom2bin[i];
+
+    // loop through stencils for all collections
+    for (jcollection = 0; jcollection < ncollections; jcollection++) {
+
+      // if same collection use own bin
+      if (icollection == jcollection) jbin = ibin;
+          else jbin = coord2bin(x[i], jcollection);
+
+      // loop over all atoms in bins in stencil
+      // stencil is empty if i larger than j
+      // stencil is half if i same size as j
+      // stencil is full if i smaller than j
+      // if half: pairs for atoms j "below" i are excluded
+      // below = lower z or (equal z and lower y) or (equal zy and lower x)
+      //         (equal zyx and j <= i)
+      // latter excludes self-self interaction but allows superposed atoms
+
+          s = stencil_multi[icollection][jcollection];
+          ns = nstencil_multi[icollection][jcollection];
+
+          for (k = 0; k < ns; k++) {
+            js = binhead_multi[jcollection][jbin + s[k]];
+            for (j = js; j >= 0; j = bins[j]) {
+
+          // if same size (same collection), use half stencil
+          if (cutcollectionsq[icollection][icollection] == cutcollectionsq[jcollection][jcollection]){
+            if (x[j][2] < ztmp) continue;
+            if (x[j][2] == ztmp) {
+              if (x[j][1] < ytmp) continue;
+              if (x[j][1] == ytmp) {
+                if (x[j][0] < xtmp) continue;
+                if (x[j][0] == xtmp && j <= i) continue;
+              }
+            }
+          }
+
+          jtype = type[j];
+              if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+              delx = xtmp - x[j][0];
+              dely = ytmp - x[j][1];
+              delz = ztmp - x[j][2];
+              rsq = delx*delx + dely*dely + delz*delz;
+
+              if (rsq <= cutneighsq[itype][jtype]) {
+                if (molecular != Atom::ATOMIC) {
+                    if (!moltemplate)
+                      which = find_special(special[i],nspecial[i],tag[j]);
+                    else if (imol >= 0)
+                      which = find_special(onemols[imol]->special[iatom],
+                                       onemols[imol]->nspecial[iatom],
+                                       tag[j]-tagprev);
+                    else which = 0;
+                    if (which == 0) neighptr[n++] = j;
+                    else if (domain->minimum_image_check(delx,dely,delz))
+                      neighptr[n++] = j;
+                    else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+                } else neighptr[n++] = j;
+              }
+            }
+          }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_multi_newton_tri_omp.h ../lammps-stable_2Aug2023/src/npair_half_multi_newton_tri_omp.h
--- lammps-stable_2Aug2023/src/npair_half_multi_newton_tri_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_multi_newton_tri_omp.h	2023-09-26 15:27:28.550408000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/multi/newton/tri/omp,
+           NPairHalfMultiNewtonTriOmp,
+           NP_HALF | NP_MULTI | NP_NEWTON | NP_TRI | NP_OMP);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_MULTI_NEWTON_TRI_OMP_H
+#define LMP_NPAIR_HALF_MULTI_NEWTON_TRI_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfMultiNewtonTriOmp : public NPair {
+ public:
+  NPairHalfMultiNewtonTriOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_multi_old_newtoff_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_multi_old_newtoff_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_multi_old_newtoff_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_multi_old_newtoff_omp.cpp	2023-09-26 15:27:26.974442000 -0400
@@ -0,0 +1,146 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_multi_old_newtoff_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfMultiOldNewtoffOmp::NPairHalfMultiOldNewtoffOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   binned neighbor list construction with partial Newton's 3rd law
+   each owned atom i checks own bin and other bins in stencil
+   multi-type stencil is itype dependent and is distance checked
+   pair stored once if i,j are both owned and i < j
+   pair stored by me if j is ghost (also stored by proc owning j)
+------------------------------------------------------------------------- */
+
+void NPairHalfMultiOldNewtoffOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,k,n,itype,jtype,ibin,which,ns,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr,*s;
+  double *cutsq,*distsq;
+
+  // loop over each atom, storing neighbors
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over all atoms in other bins in stencil including self
+    // only store pair if i < j
+    // skip if i,j neighbor cutoff is less than bin distance
+    // stores own/own pairs only once
+    // stores own/ghost pairs on both procs
+
+    ibin = atom2bin[i];
+    s = stencil_multi_old[itype];
+    distsq = distsq_multi_old[itype];
+    cutsq = cutneighsq[itype];
+    ns = nstencil_multi_old[itype];
+    for (k = 0; k < ns; k++) {
+      for (j = binhead[ibin+s[k]]; j >= 0; j = bins[j]) {
+        if (j <= i) continue;
+        jtype = type[j];
+        if (cutsq[jtype] < distsq[k]) continue;
+
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+
+        if (rsq <= cutneighsq[itype][jtype]) {
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = j;
+            else if (domain->minimum_image_check(delx,dely,delz))
+              neighptr[n++] = j;
+            else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+          } else neighptr[n++] = j;
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_multi_old_newtoff_omp.h ../lammps-stable_2Aug2023/src/npair_half_multi_old_newtoff_omp.h
--- lammps-stable_2Aug2023/src/npair_half_multi_old_newtoff_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_multi_old_newtoff_omp.h	2023-09-26 15:27:28.565923000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/multi/old/newtoff/omp,
+           NPairHalfMultiOldNewtoffOmp,
+           NP_HALF | NP_MULTI_OLD | NP_NEWTOFF | NP_OMP | NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_MULTI_OLD_NEWTOFF_OMP_H
+#define LMP_NPAIR_HALF_MULTI_OLD_NEWTOFF_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfMultiOldNewtoffOmp : public NPair {
+ public:
+  NPairHalfMultiOldNewtoffOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_multi_old_newton_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_multi_old_newton_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_multi_old_newton_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_multi_old_newton_omp.cpp	2023-09-26 15:27:27.012721000 -0400
@@ -0,0 +1,179 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_multi_old_newton_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfMultiOldNewtonOmp::NPairHalfMultiOldNewtonOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   binned neighbor list construction with full Newton's 3rd law
+   each owned atom i checks its own bin and other bins in Newton stencil
+   multi-type stencil is itype dependent and is distance checked
+   every pair stored exactly once by some processor
+------------------------------------------------------------------------- */
+
+void NPairHalfMultiOldNewtonOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,k,n,itype,jtype,ibin,which,ns,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr,*s;
+  double *cutsq,*distsq;
+
+  // loop over each atom, storing neighbors
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over rest of atoms in i's bin, ghosts are at end of linked list
+    // if j is owned atom, store it, since j is beyond i in linked list
+    // if j is ghost, only store if j coords are "above and to the right" of i
+
+    for (j = bins[i]; j >= 0; j = bins[j]) {
+      if (j >= nlocal) {
+        if (x[j][2] < ztmp) continue;
+        if (x[j][2] == ztmp) {
+          if (x[j][1] < ytmp) continue;
+          if (x[j][1] == ytmp && x[j][0] < xtmp) continue;
+        }
+      }
+
+      jtype = type[j];
+      if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+
+      if (rsq <= cutneighsq[itype][jtype]) {
+        if (molecular != Atom::ATOMIC) {
+          if (!moltemplate)
+            which = find_special(special[i],nspecial[i],tag[j]);
+          else if (imol >= 0)
+            which = find_special(onemols[imol]->special[iatom],
+                                 onemols[imol]->nspecial[iatom],
+                                 tag[j]-tagprev);
+          else which = 0;
+          if (which == 0) neighptr[n++] = j;
+          else if (domain->minimum_image_check(delx,dely,delz))
+            neighptr[n++] = j;
+          else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+        } else neighptr[n++] = j;
+      }
+    }
+
+    // loop over all atoms in other bins in stencil, store every pair
+    // skip if i,j neighbor cutoff is less than bin distance
+
+    ibin = atom2bin[i];
+    s = stencil_multi_old[itype];
+    distsq = distsq_multi_old[itype];
+    cutsq = cutneighsq[itype];
+    ns = nstencil_multi_old[itype];
+    for (k = 0; k < ns; k++) {
+      for (j = binhead[ibin+s[k]]; j >= 0; j = bins[j]) {
+        jtype = type[j];
+        if (cutsq[jtype] < distsq[k]) continue;
+
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+
+        if (rsq <= cutneighsq[itype][jtype]) {
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = j;
+            else if (domain->minimum_image_check(delx,dely,delz))
+              neighptr[n++] = j;
+            else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+          } else neighptr[n++] = j;
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_multi_old_newton_omp.h ../lammps-stable_2Aug2023/src/npair_half_multi_old_newton_omp.h
--- lammps-stable_2Aug2023/src/npair_half_multi_old_newton_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_multi_old_newton_omp.h	2023-09-26 15:27:28.570577000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/multi/old/newton/omp,
+           NPairHalfMultiOldNewtonOmp,
+           NP_HALF | NP_MULTI_OLD | NP_NEWTON | NP_OMP | NP_ORTHO);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_MULTI_OLD_NEWTON_OMP_H
+#define LMP_NPAIR_HALF_MULTI_OLD_NEWTON_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfMultiOldNewtonOmp : public NPair {
+ public:
+  NPairHalfMultiOldNewtonOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_multi_old_newton_tri_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_multi_old_newton_tri_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_multi_old_newton_tri_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_multi_old_newton_tri_omp.cpp	2023-09-26 15:27:27.042812000 -0400
@@ -0,0 +1,155 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_multi_old_newton_tri_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfMultiOldNewtonTriOmp::NPairHalfMultiOldNewtonTriOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   binned neighbor list construction with Newton's 3rd law for triclinic
+   each owned atom i checks its own bin and other bins in triclinic stencil
+   multi-type stencil is itype dependent and is distance checked
+   every pair stored exactly once by some processor
+------------------------------------------------------------------------- */
+
+void NPairHalfMultiOldNewtonTriOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,k,n,itype,jtype,ibin,which,ns,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr,*s;
+  double *cutsq,*distsq;
+
+  // loop over each atom, storing neighbors
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over all atoms in bins, including self, in stencil
+    // skip if i,j neighbor cutoff is less than bin distance
+    // bins below self are excluded from stencil
+    // pairs for atoms j "below" i are excluded
+    // below = lower z or (equal z and lower y) or (equal zy and lower x)
+    //         (equal zyx and j <= i)
+    // latter excludes self-self interaction but allows superposed atoms
+
+    ibin = atom2bin[i];
+    s = stencil_multi_old[itype];
+    distsq = distsq_multi_old[itype];
+    cutsq = cutneighsq[itype];
+    ns = nstencil_multi_old[itype];
+    for (k = 0; k < ns; k++) {
+      for (j = binhead[ibin+s[k]]; j >= 0; j = bins[j]) {
+        jtype = type[j];
+        if (cutsq[jtype] < distsq[k]) continue;
+        if (x[j][2] < ztmp) continue;
+        if (x[j][2] == ztmp) {
+          if (x[j][1] < ytmp) continue;
+          if (x[j][1] == ytmp) {
+            if (x[j][0] < xtmp) continue;
+            if (x[j][0] == xtmp && j <= i) continue;
+          }
+        }
+
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+
+        if (rsq <= cutneighsq[itype][jtype]) {
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = j;
+            else if (domain->minimum_image_check(delx,dely,delz))
+              neighptr[n++] = j;
+            else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+          } else neighptr[n++] = j;
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_multi_old_newton_tri_omp.h ../lammps-stable_2Aug2023/src/npair_half_multi_old_newton_tri_omp.h
--- lammps-stable_2Aug2023/src/npair_half_multi_old_newton_tri_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_multi_old_newton_tri_omp.h	2023-09-26 15:27:28.574866000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/multi/old/newton/tri/omp,
+           NPairHalfMultiOldNewtonTriOmp,
+           NP_HALF | NP_MULTI_OLD | NP_NEWTON | NP_TRI | NP_OMP);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_MULTI_OLD_NEWTON_TRI_OMP_H
+#define LMP_NPAIR_HALF_MULTI_OLD_NEWTON_TRI_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfMultiOldNewtonTriOmp : public NPair {
+ public:
+  NPairHalfMultiOldNewtonTriOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_nsq_newtoff_ghost_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_nsq_newtoff_ghost_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_nsq_newtoff_ghost_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_nsq_newtoff_ghost_omp.cpp	2023-09-26 15:27:27.058994000 -0400
@@ -0,0 +1,158 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_nsq_newtoff_ghost_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "group.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfNsqNewtoffGhostOmp::NPairHalfNsqNewtoffGhostOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   N^2 / 2 search for neighbor pairs with partial Newton's 3rd law
+   include neighbors of ghost atoms, but no "special neighbors" for ghosts
+   pair stored once if i,j are both owned and i < j
+   pair stored by me if i owned and j ghost (also stored by proc owning j)
+   pair stored once if i,j are both ghost and i < j
+------------------------------------------------------------------------- */
+
+void NPairHalfNsqNewtoffGhostOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int bitmask = (includegroup) ? group->bitmask[includegroup] : 0;
+  const int nall = nlocal + atom->nghost;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nall);
+
+  int i,j,n,itype,jtype,which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr;
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  // loop over owned & ghost atoms, storing neighbors
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over remaining atoms, owned and ghost
+    // only store pair if i < j
+    // stores own/own pairs only once
+    // stores own/ghost pairs with owned atom only, on both procs
+    // stores ghost/ghost pairs only once
+    // no molecular test when i = ghost atom
+
+    if (i < nlocal) {
+      for (j = i+1; j < nall; j++) {
+        if (includegroup && !(mask[j] & bitmask)) continue;
+        jtype = type[j];
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+
+        if (rsq <= cutneighsq[itype][jtype]) {
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = j;
+            else if (domain->minimum_image_check(delx,dely,delz))
+              neighptr[n++] = j;
+            else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+          } else neighptr[n++] = j;
+        }
+      }
+
+    } else {
+      for (j = i+1; j < nall; j++) {
+        if (includegroup && !(mask[j] & bitmask)) continue;
+        jtype = type[j];
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+
+        if (rsq <= cutneighsq[itype][jtype]) neighptr[n++] = j;
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = atom->nlocal;
+  list->gnum = nall - atom->nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_nsq_newtoff_ghost_omp.h ../lammps-stable_2Aug2023/src/npair_half_nsq_newtoff_ghost_omp.h
--- lammps-stable_2Aug2023/src/npair_half_nsq_newtoff_ghost_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_nsq_newtoff_ghost_omp.h	2023-09-26 15:27:28.579100000 -0400
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/nsq/newtoff/ghost/omp,
+           NPairHalfNsqNewtoffGhostOmp,
+           NP_HALF | NP_NSQ | NP_NEWTOFF | NP_GHOST | NP_OMP |
+           NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_NSQ_NEWTOFF_GHOST_OMP_H
+#define LMP_NPAIR_HALF_NSQ_NEWTOFF_GHOST_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfNsqNewtoffGhostOmp : public NPair {
+ public:
+  NPairHalfNsqNewtoffGhostOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_nsq_newtoff_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_nsq_newtoff_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_nsq_newtoff_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_nsq_newtoff_omp.cpp	2023-09-26 15:27:27.066910000 -0400
@@ -0,0 +1,134 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_nsq_newtoff_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "group.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfNsqNewtoffOmp::NPairHalfNsqNewtoffOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   N^2 / 2 search for neighbor pairs with partial Newton's 3rd law
+   pair stored once if i,j are both owned and i < j
+   pair stored by me if j is ghost (also stored by proc owning j)
+------------------------------------------------------------------------- */
+
+void NPairHalfNsqNewtoffOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int bitmask = (includegroup) ? group->bitmask[includegroup] : 0;
+  const int nall = atom->nlocal + atom->nghost;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,n,itype,jtype,which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr;
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  // loop over owned atoms, storing neighbors
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over remaining atoms, owned and ghost
+    // only store pair if i < j
+
+    for (j = i+1; j < nall; j++) {
+      if (includegroup && !(mask[j] & bitmask)) continue;
+      jtype = type[j];
+      if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+
+      if (rsq <= cutneighsq[itype][jtype]) {
+        if (molecular != Atom::ATOMIC) {
+          if (!moltemplate)
+            which = find_special(special[i],nspecial[i],tag[j]);
+          else if (imol >= 0)
+            which = find_special(onemols[imol]->special[iatom],
+                                 onemols[imol]->nspecial[iatom],
+                                 tag[j]-tagprev);
+          else which = 0;
+          if (which == 0) neighptr[n++] = j;
+          else if (domain->minimum_image_check(delx,dely,delz))
+            neighptr[n++] = j;
+          else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+        } else neighptr[n++] = j;
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_nsq_newtoff_omp.h ../lammps-stable_2Aug2023/src/npair_half_nsq_newtoff_omp.h
--- lammps-stable_2Aug2023/src/npair_half_nsq_newtoff_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_nsq_newtoff_omp.h	2023-09-26 15:27:28.583301000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/nsq/newtoff/omp,
+           NPairHalfNsqNewtoffOmp,
+           NP_HALF | NP_NSQ | NP_NEWTOFF | NP_OMP | NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_NSQ_NEWTOFF_OMP_H
+#define LMP_NPAIR_HALF_NSQ_NEWTOFF_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfNsqNewtoffOmp : public NPair {
+ public:
+  NPairHalfNsqNewtoffOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_nsq_newton_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_nsq_newton_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_nsq_newton_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_nsq_newton_omp.cpp	2023-09-26 15:27:27.099766000 -0400
@@ -0,0 +1,152 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_nsq_newton_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "group.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfNsqNewtonOmp::NPairHalfNsqNewtonOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   N^2 / 2 search for neighbor pairs with full Newton's 3rd law
+   every pair stored exactly once by some processor
+   decision on ghost atoms based on itag,jtag tests
+------------------------------------------------------------------------- */
+
+void NPairHalfNsqNewtonOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int bitmask = (includegroup) ? group->bitmask[includegroup] : 0;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,n,itype,jtype,which,imol,iatom;
+  tagint itag,jtag,tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr;
+
+  // loop over each atom, storing neighbors
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int nall = atom->nlocal + atom->nghost;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itag = tag[i];
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over remaining atoms, owned and ghost
+    // itag = jtag is possible for long cutoffs that include images of self
+
+    for (j = i+1; j < nall; j++) {
+      if (includegroup && !(mask[j] & bitmask)) continue;
+
+      if (j >= nlocal) {
+        jtag = tag[j];
+        if (itag > jtag) {
+          if ((itag+jtag) % 2 == 0) continue;
+        } else if (itag < jtag) {
+          if ((itag+jtag) % 2 == 1) continue;
+        } else {
+          if (x[j][2] < ztmp) continue;
+          if (x[j][2] == ztmp) {
+            if (x[j][1] < ytmp) continue;
+            if (x[j][1] == ytmp && x[j][0] < xtmp) continue;
+          }
+        }
+      }
+
+      jtype = type[j];
+      if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+
+      if (rsq <= cutneighsq[itype][jtype]) {
+        if (molecular != Atom::ATOMIC) {
+          if (!moltemplate)
+            which = find_special(special[i],nspecial[i],tag[j]);
+          else if (imol >= 0)
+            which = find_special(onemols[imol]->special[iatom],
+                                 onemols[imol]->nspecial[iatom],
+                                 tag[j]-tagprev);
+          else which = 0;
+          if (which == 0) neighptr[n++] = j;
+          else if (domain->minimum_image_check(delx,dely,delz))
+            neighptr[n++] = j;
+          else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+        } else neighptr[n++] = j;
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_nsq_newton_omp.h ../lammps-stable_2Aug2023/src/npair_half_nsq_newton_omp.h
--- lammps-stable_2Aug2023/src/npair_half_nsq_newton_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_nsq_newton_omp.h	2023-09-26 15:27:28.587568000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/nsq/newton/omp,
+           NPairHalfNsqNewtonOmp,
+           NP_HALF | NP_NSQ | NP_NEWTON | NP_OMP | NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_NSQ_NEWTON_OMP_H
+#define LMP_NPAIR_HALF_NSQ_NEWTON_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfNsqNewtonOmp : public NPair {
+ public:
+  NPairHalfNsqNewtonOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_respa_bin_newtoff_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_respa_bin_newtoff_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_respa_bin_newtoff_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_respa_bin_newtoff_omp.cpp	2023-09-26 15:27:27.120424000 -0400
@@ -0,0 +1,203 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_respa_bin_newtoff_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfRespaBinNewtoffOmp::NPairHalfRespaBinNewtoffOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   multiple respa lists
+   binned neighbor list construction with partial Newton's 3rd law
+   each owned atom i checks own bin and surrounding bins in non-Newton stencil
+   pair stored once if i,j are both owned and i < j
+   pair stored by me if j is ghost (also stored by proc owning j)
+------------------------------------------------------------------------- */
+
+void NPairHalfRespaBinNewtoffOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+
+  const int respamiddle = list->respamiddle;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,k,n,itype,jtype,ibin,n_inner,n_middle,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr,*neighptr_inner,*neighptr_middle;
+
+  // loop over each atom, storing neighbors
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  int *ilist_inner = list->ilist_inner;
+  int *numneigh_inner = list->numneigh_inner;
+  int **firstneigh_inner = list->firstneigh_inner;
+
+  int *ilist_middle,*numneigh_middle,**firstneigh_middle;
+  if (respamiddle) {
+    ilist_middle = list->ilist_middle;
+    numneigh_middle = list->numneigh_middle;
+    firstneigh_middle = list->firstneigh_middle;
+  }
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  MyPage<int> &ipage_inner = list->ipage_inner[tid];
+  ipage.reset();
+  ipage_inner.reset();
+
+  MyPage<int> *ipage_middle;
+  if (respamiddle) {
+    ipage_middle = list->ipage_middle + tid;
+    ipage_middle->reset();
+  }
+
+  int which = 0;
+  int minchange = 0;
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = n_inner = 0;
+    neighptr = ipage.vget();
+    neighptr_inner = ipage_inner.vget();
+    if (respamiddle) {
+      n_middle = 0;
+      neighptr_middle = ipage_middle->vget();
+    }
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    ibin = atom2bin[i];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over all atoms in surrounding bins in stencil including self
+    // only store pair if i < j
+    // stores own/own pairs only once
+    // stores own/ghost pairs on both procs
+
+    for (k = 0; k < nstencil; k++) {
+      for (j = binhead[ibin+stencil[k]]; j >= 0; j = bins[j]) {
+        if (j <= i) continue;
+
+        jtype = type[j];
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+
+        if (rsq <= cutneighsq[itype][jtype]) {
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = j;
+            else if ((minchange = domain->minimum_image_check(delx,dely,delz)))
+              neighptr[n++] = j;
+            else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+          } else neighptr[n++] = j;
+
+          if (rsq < cut_inner_sq) {
+            if (which == 0) neighptr_inner[n_inner++] = j;
+            else if (minchange) neighptr_inner[n_inner++] = j;
+            else if (which > 0)
+              neighptr_inner[n_inner++] = j ^ (which << SBBITS);
+          }
+
+          if (respamiddle &&
+              rsq < cut_middle_sq && rsq > cut_middle_inside_sq) {
+            if (which == 0) neighptr_middle[n_middle++] = j;
+            else if (minchange) neighptr_middle[n_middle++] = j;
+            else if (which > 0)
+              neighptr_middle[n_middle++] = j ^ (which << SBBITS);
+          }
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+
+    ilist_inner[i] = i;
+    firstneigh_inner[i] = neighptr_inner;
+    numneigh_inner[i] = n_inner;
+    ipage.vgot(n_inner);
+    if (ipage_inner.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+
+    if (respamiddle) {
+      ilist_middle[i] = i;
+      firstneigh_middle[i] = neighptr_middle;
+      numneigh_middle[i] = n_middle;
+      ipage_middle->vgot(n_middle);
+      if (ipage_middle->status())
+        error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+    }
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+  list->inum_inner = nlocal;
+  if (respamiddle) list->inum_middle = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_respa_bin_newtoff_omp.h ../lammps-stable_2Aug2023/src/npair_half_respa_bin_newtoff_omp.h
--- lammps-stable_2Aug2023/src/npair_half_respa_bin_newtoff_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_respa_bin_newtoff_omp.h	2023-09-26 15:27:28.591712000 -0400
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/respa/bin/newtoff/omp,
+           NPairHalfRespaBinNewtoffOmp,
+           NP_HALF | NP_RESPA | NP_BIN | NP_NEWTOFF | NP_OMP |
+           NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_RESPA_BIN_NEWTOFF_OMP_H
+#define LMP_NPAIR_HALF_RESPA_BIN_NEWTOFF_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfRespaBinNewtoffOmp : public NPair {
+ public:
+  NPairHalfRespaBinNewtoffOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_respa_bin_newton_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_respa_bin_newton_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_respa_bin_newton_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_respa_bin_newton_omp.cpp	2023-09-26 15:27:27.135099000 -0400
@@ -0,0 +1,249 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_respa_bin_newton_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfRespaBinNewtonOmp::NPairHalfRespaBinNewtonOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   multiple respa lists
+   binned neighbor list construction with full Newton's 3rd law
+   each owned atom i checks its own bin and other bins in Newton stencil
+   every pair stored exactly once by some processor
+------------------------------------------------------------------------- */
+
+void NPairHalfRespaBinNewtonOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+
+  const int respamiddle = list->respamiddle;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,k,n,itype,jtype,ibin,n_inner,n_middle,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr,*neighptr_inner,*neighptr_middle;
+
+  // loop over each atom, storing neighbors
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  int *ilist_inner = list->ilist_inner;
+  int *numneigh_inner = list->numneigh_inner;
+  int **firstneigh_inner = list->firstneigh_inner;
+
+  int *ilist_middle,*numneigh_middle,**firstneigh_middle;
+  if (respamiddle) {
+    ilist_middle = list->ilist_middle;
+    numneigh_middle = list->numneigh_middle;
+    firstneigh_middle = list->firstneigh_middle;
+  }
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  MyPage<int> &ipage_inner = list->ipage_inner[tid];
+  ipage.reset();
+  ipage_inner.reset();
+
+  MyPage<int> *ipage_middle;
+  if (respamiddle) {
+    ipage_middle = list->ipage_middle + tid;
+    ipage_middle->reset();
+  }
+
+  int which = 0;
+  int minchange = 0;
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = n_inner = 0;
+    neighptr = ipage.vget();
+    neighptr_inner = ipage_inner.vget();
+    if (respamiddle) {
+      n_middle = 0;
+      neighptr_middle = ipage_middle->vget();
+    }
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over rest of atoms in i's bin, ghosts are at end of linked list
+    // if j is owned atom, store it, since j is beyond i in linked list
+    // if j is ghost, only store if j coords are "above and to the right" of i
+
+    for (j = bins[i]; j >= 0; j = bins[j]) {
+      if (j >= nlocal) {
+        if (x[j][2] < ztmp) continue;
+        if (x[j][2] == ztmp) {
+          if (x[j][1] < ytmp) continue;
+          if (x[j][1] == ytmp && x[j][0] < xtmp) continue;
+        }
+      }
+
+      jtype = type[j];
+      if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+
+      if (rsq <= cutneighsq[itype][jtype]) {
+        if (molecular != Atom::ATOMIC) {
+          if (!moltemplate)
+            which = find_special(special[i],nspecial[i],tag[j]);
+          else if (imol >= 0)
+            which = find_special(onemols[imol]->special[iatom],
+                                 onemols[imol]->nspecial[iatom],
+                                 tag[j]-tagprev);
+            else which = 0;
+          if (which == 0) neighptr[n++] = j;
+          else if ((minchange = domain->minimum_image_check(delx,dely,delz)))
+            neighptr[n++] = j;
+          else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+        } else neighptr[n++] = j;
+
+        if (rsq < cut_inner_sq) {
+          if (which == 0) neighptr_inner[n_inner++] = j;
+          else if (minchange) neighptr_inner[n_inner++] = j;
+          else if (which > 0) neighptr_inner[n_inner++] = j ^ (which << SBBITS);
+        }
+
+        if (respamiddle &&
+            rsq < cut_middle_sq && rsq > cut_middle_inside_sq) {
+          if (which == 0) neighptr_middle[n_middle++] = j;
+          else if (minchange) neighptr_middle[n_middle++] = j;
+          else if (which > 0)
+            neighptr_middle[n_middle++] = j ^ (which << SBBITS);
+        }
+      }
+    }
+
+    // loop over all atoms in other bins in stencil, store every pair
+
+    ibin = atom2bin[i];
+    for (k = 0; k < nstencil; k++) {
+      for (j = binhead[ibin+stencil[k]]; j >= 0; j = bins[j]) {
+        jtype = type[j];
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+
+        if (rsq <= cutneighsq[itype][jtype]) {
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = j;
+            else if ((minchange = domain->minimum_image_check(delx,dely,delz)))
+              neighptr[n++] = j;
+            else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+          } else neighptr[n++] = j;
+
+          if (rsq < cut_inner_sq) {
+            if (which == 0) neighptr_inner[n_inner++] = j;
+            else if (minchange) neighptr_inner[n_inner++] = j;
+            else if (which > 0)
+              neighptr_inner[n_inner++] = j ^ (which << SBBITS);
+          }
+
+          if (respamiddle &&
+              rsq < cut_middle_sq && rsq > cut_middle_inside_sq) {
+            if (which == 0) neighptr_middle[n_middle++] = j;
+            else if (minchange) neighptr_middle[n_middle++] = j;
+            else if (which > 0)
+              neighptr_middle[n_middle++] = j ^ (which << SBBITS);
+          }
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+
+    ilist_inner[i] = i;
+    firstneigh_inner[i] = neighptr_inner;
+    numneigh_inner[i] = n_inner;
+    ipage.vgot(n_inner);
+    if (ipage_inner.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+
+    if (respamiddle) {
+      ilist_middle[i] = i;
+      firstneigh_middle[i] = neighptr_middle;
+      numneigh_middle[i] = n_middle;
+      ipage_middle->vgot(n_middle);
+      if (ipage_middle->status())
+        error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+    }
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+  list->inum_inner = nlocal;
+  if (respamiddle) list->inum_middle = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_respa_bin_newton_omp.h ../lammps-stable_2Aug2023/src/npair_half_respa_bin_newton_omp.h
--- lammps-stable_2Aug2023/src/npair_half_respa_bin_newton_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_respa_bin_newton_omp.h	2023-09-26 15:27:28.595925000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/respa/bin/newton/omp,
+           NPairHalfRespaBinNewtonOmp,
+           NP_HALF | NP_RESPA | NP_BIN | NP_NEWTON | NP_OMP | NP_ORTHO);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_RESPA_BIN_NEWTON_OMP_H
+#define LMP_NPAIR_HALF_RESPA_BIN_NEWTON_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfRespaBinNewtonOmp : public NPair {
+ public:
+  NPairHalfRespaBinNewtonOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_respa_bin_newton_tri_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_respa_bin_newton_tri_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_respa_bin_newton_tri_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_respa_bin_newton_tri_omp.cpp	2023-09-26 15:27:27.195748000 -0400
@@ -0,0 +1,210 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_respa_bin_newton_tri_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfRespaBinNewtonTriOmp::NPairHalfRespaBinNewtonTriOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   multiple respa lists
+   binned neighbor list construction with Newton's 3rd law for triclinic
+   each owned atom i checks its own bin and other bins in triclinic stencil
+   every pair stored exactly once by some processor
+------------------------------------------------------------------------- */
+
+void NPairHalfRespaBinNewtonTriOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+
+  const int respamiddle = list->respamiddle;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,k,n,itype,jtype,ibin,n_inner,n_middle,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr,*neighptr_inner,*neighptr_middle;
+
+  // loop over each atom, storing neighbors
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  int *ilist_inner = list->ilist_inner;
+  int *numneigh_inner = list->numneigh_inner;
+  int **firstneigh_inner = list->firstneigh_inner;
+
+  int *ilist_middle,*numneigh_middle,**firstneigh_middle;
+  if (respamiddle) {
+    ilist_middle = list->ilist_middle;
+    numneigh_middle = list->numneigh_middle;
+    firstneigh_middle = list->firstneigh_middle;
+  }
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  MyPage<int> &ipage_inner = list->ipage_inner[tid];
+  ipage.reset();
+  ipage_inner.reset();
+
+  MyPage<int> *ipage_middle;
+  if (respamiddle) {
+    ipage_middle = list->ipage_middle + tid;
+    ipage_middle->reset();
+  }
+
+  int which = 0;
+  int minchange = 0;
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = n_inner = 0;
+    neighptr = ipage.vget();
+    neighptr_inner = ipage_inner.vget();
+    if (respamiddle) {
+      n_middle = 0;
+      neighptr_middle = ipage_middle->vget();
+    }
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over all atoms in bins in stencil
+    // pairs for atoms j "below" i are excluded
+    // below = lower z or (equal z and lower y) or (equal zy and lower x)
+    //         (equal zyx and j <= i)
+    // latter excludes self-self interaction but allows superposed atoms
+
+    ibin = atom2bin[i];
+    for (k = 0; k < nstencil; k++) {
+      for (j = binhead[ibin+stencil[k]]; j >= 0; j = bins[j]) {
+        if (x[j][2] < ztmp) continue;
+        if (x[j][2] == ztmp) {
+          if (x[j][1] < ytmp) continue;
+          if (x[j][1] == ytmp) {
+            if (x[j][0] < xtmp) continue;
+            if (x[j][0] == xtmp && j <= i) continue;
+          }
+        }
+
+        jtype = type[j];
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+
+        if (rsq <= cutneighsq[itype][jtype]) {
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = j;
+            else if ((minchange = domain->minimum_image_check(delx,dely,delz)))
+              neighptr[n++] = j;
+            else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+          } else neighptr[n++] = j;
+
+          if (rsq < cut_inner_sq) {
+            if (which == 0) neighptr_inner[n_inner++] = j;
+            else if (minchange) neighptr_inner[n_inner++] = j;
+            else if (which > 0)
+              neighptr_inner[n_inner++] = j ^ (which << SBBITS);
+          }
+
+          if (respamiddle &&
+              rsq < cut_middle_sq && rsq > cut_middle_inside_sq) {
+            if (which == 0) neighptr_middle[n_middle++] = j;
+            else if (minchange) neighptr_middle[n_middle++] = j;
+            else if (which > 0)
+              neighptr_middle[n_middle++] = j ^ (which << SBBITS);
+          }
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+
+    ilist_inner[i] = i;
+    firstneigh_inner[i] = neighptr_inner;
+    numneigh_inner[i] = n_inner;
+    ipage_inner.vgot(n_inner);
+    if (ipage_inner.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+
+    if (respamiddle) {
+      ilist_middle[i] = i;
+      firstneigh_middle[i] = neighptr_middle;
+      numneigh_middle[i] = n_middle;
+      ipage_middle->vgot(n_middle);
+      if (ipage_middle->status())
+        error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+    }
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+  list->inum_inner = nlocal;
+  if (respamiddle) list->inum_middle = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_respa_bin_newton_tri_omp.h ../lammps-stable_2Aug2023/src/npair_half_respa_bin_newton_tri_omp.h
--- lammps-stable_2Aug2023/src/npair_half_respa_bin_newton_tri_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_respa_bin_newton_tri_omp.h	2023-09-26 15:27:28.600137000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/respa/bin/newton/tri/omp,
+           NPairHalfRespaBinNewtonTriOmp,
+           NP_HALF | NP_RESPA | NP_BIN | NP_NEWTON | NP_TRI | NP_OMP);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_RESPA_BIN_NEWTON_TRI_OMP_H
+#define LMP_NPAIR_HALF_RESPA_BIN_NEWTON_TRI_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfRespaBinNewtonTriOmp : public NPair {
+ public:
+  NPairHalfRespaBinNewtonTriOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_respa_nsq_newtoff_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_respa_nsq_newtoff_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_respa_nsq_newtoff_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_respa_nsq_newtoff_omp.cpp	2023-09-26 15:27:27.227519000 -0400
@@ -0,0 +1,197 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_respa_nsq_newtoff_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "group.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfRespaNsqNewtoffOmp::NPairHalfRespaNsqNewtoffOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   multiple respa lists
+   N^2 / 2 search for neighbor pairs with partial Newton's 3rd law
+   pair added to list if atoms i and j are both owned and i < j
+   pair added if j is ghost (also stored by proc owning j)
+------------------------------------------------------------------------- */
+
+void NPairHalfRespaNsqNewtoffOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int bitmask = (includegroup) ? group->bitmask[includegroup] : 0;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+
+  const int respamiddle = list->respamiddle;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,n,itype,jtype,n_inner,n_middle,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr,*neighptr_inner,*neighptr_middle;
+
+  // loop over each atom, storing neighbors
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int nall = atom->nlocal + atom->nghost;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  int *ilist_inner = list->ilist_inner;
+  int *numneigh_inner = list->numneigh_inner;
+  int **firstneigh_inner = list->firstneigh_inner;
+
+  int *ilist_middle,*numneigh_middle,**firstneigh_middle;
+  if (respamiddle) {
+    ilist_middle = list->ilist_middle;
+    numneigh_middle = list->numneigh_middle;
+    firstneigh_middle = list->firstneigh_middle;
+  }
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  MyPage<int> &ipage_inner = list->ipage_inner[tid];
+  ipage.reset();
+  ipage_inner.reset();
+
+  MyPage<int> *ipage_middle;
+  if (respamiddle) {
+    ipage_middle = list->ipage_middle + tid;
+    ipage_middle->reset();
+  }
+
+  int which = 0;
+  int minchange = 0;
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = n_inner = 0;
+    neighptr = ipage.vget();
+    neighptr_inner = ipage_inner.vget();
+    if (respamiddle) {
+      n_middle = 0;
+      neighptr_middle = ipage_middle->vget();
+    }
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over remaining atoms, owned and ghost
+
+    for (j = i+1; j < nall; j++) {
+      if (includegroup && !(mask[j] & bitmask)) continue;
+      jtype = type[j];
+      if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+
+      if (rsq <= cutneighsq[itype][jtype]) {
+        if (molecular != Atom::ATOMIC) {
+          if (!moltemplate)
+            which = find_special(special[i],nspecial[i],tag[j]);
+          else if (imol >= 0)
+            which = find_special(onemols[imol]->special[iatom],
+                                 onemols[imol]->nspecial[iatom],
+                                 tag[j]-tagprev);
+          else which = 0;
+          if (which == 0) neighptr[n++] = j;
+          else if ((minchange = domain->minimum_image_check(delx,dely,delz)))
+            neighptr[n++] = j;
+          else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+        } else neighptr[n++] = j;
+
+        if (rsq < cut_inner_sq) {
+          if (which == 0) neighptr_inner[n_inner++] = j;
+          else if (minchange) neighptr_inner[n_inner++] = j;
+          else if (which > 0) neighptr_inner[n_inner++] = j ^ (which << SBBITS);
+        }
+
+        if (respamiddle && rsq < cut_middle_sq && rsq > cut_middle_inside_sq) {
+          if (which == 0) neighptr_middle[n_middle++] = j;
+          else if (minchange) neighptr_middle[n_middle++] = j;
+          else if (which > 0)
+            neighptr_middle[n_middle++] = j ^ (which << SBBITS);
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+
+    ilist_inner[i] = i;
+    firstneigh_inner[i] = neighptr_inner;
+    numneigh_inner[i] = n_inner;
+    ipage.vgot(n_inner);
+    if (ipage_inner.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+
+    if (respamiddle) {
+      ilist_middle[i] = i;
+      firstneigh_middle[i] = neighptr_middle;
+      numneigh_middle[i] = n_middle;
+      ipage_middle->vgot(n_middle);
+      if (ipage_middle->status())
+        error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+    }
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+  list->inum_inner = nlocal;
+  if (respamiddle) list->inum_middle = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_respa_nsq_newtoff_omp.h ../lammps-stable_2Aug2023/src/npair_half_respa_nsq_newtoff_omp.h
--- lammps-stable_2Aug2023/src/npair_half_respa_nsq_newtoff_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_respa_nsq_newtoff_omp.h	2023-09-26 15:27:28.604500000 -0400
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/respa/nsq/newtoff/omp,
+           NPairHalfRespaNsqNewtoffOmp,
+           NP_HALF | NP_RESPA | NP_NSQ | NP_NEWTOFF | NP_OMP |
+           NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_RESPA_NSQ_NEWTOFF_OMP_H
+#define LMP_NPAIR_HALF_RESPA_NSQ_NEWTOFF_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfRespaNsqNewtoffOmp : public NPair {
+ public:
+  NPairHalfRespaNsqNewtoffOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_respa_nsq_newton_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_respa_nsq_newton_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_respa_nsq_newton_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_respa_nsq_newton_omp.cpp	2023-09-26 15:27:27.244979000 -0400
@@ -0,0 +1,216 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "npair_half_respa_nsq_newton_omp.h"
+#include "npair_omp.h"
+#include "neigh_list.h"
+#include "atom.h"
+#include "atom_vec.h"
+#include "group.h"
+#include "molecule.h"
+#include "domain.h"
+#include "my_page.h"
+#include "error.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfRespaNsqNewtonOmp::NPairHalfRespaNsqNewtonOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   multiple respa lists
+   N^2 / 2 search for neighbor pairs with full Newton's 3rd law
+   pair added to list if atoms i and j are both owned and i < j
+   if j is ghost only me or other proc adds pair
+   decision based on itag,jtag tests
+------------------------------------------------------------------------- */
+
+void NPairHalfRespaNsqNewtonOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int bitmask = (includegroup) ? group->bitmask[includegroup] : 0;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+
+  NPAIR_OMP_INIT;
+
+  const int respamiddle = list->respamiddle;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,n,itype,jtype,n_inner,n_middle,imol,iatom;
+  tagint itag,jtag,tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  int *neighptr,*neighptr_inner,*neighptr_middle;
+
+  // loop over each atom, storing neighbors
+
+  double **x = atom->x;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int nall = atom->nlocal + atom->nghost;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  int *ilist_inner = list->ilist_inner;
+  int *numneigh_inner = list->numneigh_inner;
+  int **firstneigh_inner = list->firstneigh_inner;
+
+  int *ilist_middle,*numneigh_middle,**firstneigh_middle;
+  if (respamiddle) {
+    ilist_middle = list->ilist_middle;
+    numneigh_middle = list->numneigh_middle;
+    firstneigh_middle = list->firstneigh_middle;
+  }
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  MyPage<int> &ipage_inner = list->ipage_inner[tid];
+  ipage.reset();
+  ipage_inner.reset();
+
+  MyPage<int> *ipage_middle;
+  if (respamiddle) {
+    ipage_middle = list->ipage_middle + tid;
+    ipage_middle->reset();
+  }
+
+  int which = 0;
+  int minchange = 0;
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = n_inner = 0;
+    neighptr = ipage.vget();
+    neighptr_inner = ipage_inner.vget();
+    if (respamiddle) {
+      n_middle = 0;
+      neighptr_middle = ipage_middle->vget();
+    }
+
+    itag = tag[i];
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over remaining atoms, owned and ghost
+
+    for (j = i+1; j < nall; j++) {
+      if (includegroup && !(mask[j] & bitmask)) continue;
+
+      if (j >= nlocal) {
+        jtag = tag[j];
+        if (itag > jtag) {
+          if ((itag+jtag) % 2 == 0) continue;
+        } else if (itag < jtag) {
+          if ((itag+jtag) % 2 == 1) continue;
+        } else {
+          if (x[j][2] < ztmp) continue;
+          if (x[j][2] == ztmp) {
+            if (x[j][1] < ytmp) continue;
+            if (x[j][1] == ytmp && x[j][0] < xtmp) continue;
+          }
+        }
+      }
+
+      jtype = type[j];
+      if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+
+      if (rsq <= cutneighsq[itype][jtype]) {
+        if (molecular != Atom::ATOMIC) {
+          if (!moltemplate)
+            which = find_special(special[i],nspecial[i],tag[j]);
+          else if (imol >= 0)
+            which = find_special(onemols[imol]->special[iatom],
+                                 onemols[imol]->nspecial[iatom],
+                                 tag[j]-tagprev);
+          else which = 0;
+          if (which == 0) neighptr[n++] = j;
+          else if ((minchange = domain->minimum_image_check(delx,dely,delz)))
+            neighptr[n++] = j;
+          else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+        } else neighptr[n++] = j;
+
+        if (rsq < cut_inner_sq) {
+          if (which == 0) neighptr_inner[n_inner++] = j;
+          else if (minchange) neighptr_inner[n_inner++] = j;
+          else if (which > 0) neighptr_inner[n_inner++] = j ^ (which << SBBITS);
+        }
+
+        if (respamiddle &&
+            rsq < cut_middle_sq && rsq > cut_middle_inside_sq) {
+          if (which == 0) neighptr_middle[n_middle++] = j;
+          else if (minchange) neighptr_middle[n_middle++] = j;
+          else if (which > 0)
+            neighptr_middle[n_middle++] = j ^ (which << SBBITS);
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+
+    ilist_inner[i] = i;
+    firstneigh_inner[i] = neighptr_inner;
+    numneigh_inner[i] = n_inner;
+    ipage.vgot(n_inner);
+    if (ipage_inner.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+
+    if (respamiddle) {
+      ilist_middle[i] = i;
+      firstneigh_middle[i] = neighptr_middle;
+      numneigh_middle[i] = n_middle;
+      ipage_middle->vgot(n_middle);
+      if (ipage_middle->status())
+        error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+    }
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+  list->inum_inner = nlocal;
+  if (respamiddle) list->inum_middle = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_respa_nsq_newton_omp.h ../lammps-stable_2Aug2023/src/npair_half_respa_nsq_newton_omp.h
--- lammps-stable_2Aug2023/src/npair_half_respa_nsq_newton_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_respa_nsq_newton_omp.h	2023-09-26 15:27:28.608724000 -0400
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/respa/nsq/newton/omp,
+           NPairHalfRespaNsqNewtonOmp,
+           NP_HALF | NP_RESPA | NP_NSQ | NP_NEWTON | NP_OMP |
+           NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_RESPA_NSQ_NEWTON_OMP_H
+#define LMP_NPAIR_HALF_RESPA_NSQ_NEWTON_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfRespaNsqNewtonOmp : public NPair {
+ public:
+  NPairHalfRespaNsqNewtonOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_bin_newtoff_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_size_bin_newtoff_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_size_bin_newtoff_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_bin_newtoff_omp.cpp	2023-09-26 15:27:27.267821000 -0400
@@ -0,0 +1,151 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_half_size_bin_newtoff_omp.h"
+
+#include "atom.h"
+#include "atom_vec.h"
+#include "domain.h"
+#include "error.h"
+#include "molecule.h"
+#include "my_page.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfSizeBinNewtoffOmp::NPairHalfSizeBinNewtoffOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   size particles
+   binned neighbor list construction with partial Newton's 3rd law
+   each owned atom i checks own bin and surrounding bins in non-Newton stencil
+   pair stored once if i,j are both owned and i < j
+   pair stored by me if j is ghost (also stored by proc owning j)
+------------------------------------------------------------------------- */
+
+void NPairHalfSizeBinNewtoffOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+  const int history = list->history;
+  const int mask_history = 1 << HISTBITS;
+
+  NPAIR_OMP_INIT;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,jh,k,n,ibin,which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  double radi,radsum,cutsq;
+  int *neighptr;
+
+  // loop over each atom, storing neighbors
+
+  double **x = atom->x;
+  double *radius = atom->radius;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    radi = radius[i];
+    ibin = atom2bin[i];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over all atoms in surrounding bins in stencil including self
+    // only store pair if i < j
+    // stores own/own pairs only once
+    // stores own/ghost pairs on both procs
+
+    for (k = 0; k < nstencil; k++) {
+      for (j = binhead[ibin+stencil[k]]; j >= 0; j = bins[j]) {
+        if (j <= i) continue;
+        if (exclude && exclusion(i,j,type[i],type[j],mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+        radsum = radi + radius[j];
+        cutsq = (radsum+skin) * (radsum+skin);
+
+        if (rsq <= cutsq) {
+          jh = j;
+          if (history && rsq < radsum*radsum)
+            jh = jh ^ mask_history;
+
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = jh;
+            else if (domain->minimum_image_check(delx,dely,delz))
+              neighptr[n++] = jh;
+            else if (which > 0) neighptr[n++] = jh ^ (which << SBBITS);
+          } else neighptr[n++] = jh;
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_bin_newtoff_omp.h ../lammps-stable_2Aug2023/src/npair_half_size_bin_newtoff_omp.h
--- lammps-stable_2Aug2023/src/npair_half_size_bin_newtoff_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_bin_newtoff_omp.h	2023-09-26 15:27:28.612967000 -0400
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/size/bin/newtoff/omp,
+           NPairHalfSizeBinNewtoffOmp,
+           NP_HALF | NP_SIZE | NP_BIN | NP_NEWTOFF | NP_OMP |
+           NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_SIZE_BIN_NEWTOFF_OMP_H
+#define LMP_NPAIR_HALF_SIZE_BIN_NEWTOFF_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfSizeBinNewtoffOmp : public NPair {
+ public:
+  NPairHalfSizeBinNewtoffOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_bin_newton_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_size_bin_newton_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_size_bin_newton_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_bin_newton_omp.cpp	2023-09-26 15:27:27.296783000 -0400
@@ -0,0 +1,187 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_half_size_bin_newton_omp.h"
+
+#include "atom.h"
+#include "atom_vec.h"
+#include "domain.h"
+#include "error.h"
+#include "molecule.h"
+#include "my_page.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfSizeBinNewtonOmp::NPairHalfSizeBinNewtonOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   size particles
+   binned neighbor list construction with full Newton's 3rd law
+   each owned atom i checks its own bin and other bins in Newton stencil
+   every pair stored exactly once by some processor
+------------------------------------------------------------------------- */
+
+void NPairHalfSizeBinNewtonOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+  const int history = list->history;
+  const int mask_history = 1 << HISTBITS;
+
+  NPAIR_OMP_INIT;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,jh,k,n,ibin,which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  double radi,radsum,cutsq;
+  int *neighptr;
+
+  double **x = atom->x;
+  double *radius = atom->radius;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    radi = radius[i];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over rest of atoms in i's bin, ghosts are at end of linked list
+    // if j is owned atom, store it, since j is beyond i in linked list
+    // if j is ghost, only store if j coords are "above and to the right" of i
+
+    for (j = bins[i]; j >= 0; j = bins[j]) {
+      if (j >= nlocal) {
+        if (x[j][2] < ztmp) continue;
+        if (x[j][2] == ztmp) {
+          if (x[j][1] < ytmp) continue;
+          if (x[j][1] == ytmp && x[j][0] < xtmp) continue;
+        }
+      }
+
+      if (exclude && exclusion(i,j,type[i],type[j],mask,molecule)) continue;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+      radsum = radi + radius[j];
+      cutsq = (radsum+skin) * (radsum+skin);
+
+      if (rsq <= cutsq) {
+        jh = j;
+        if (history && rsq < radsum*radsum)
+          jh = jh ^ mask_history;
+
+        if (molecular != Atom::ATOMIC) {
+          if (!moltemplate)
+            which = find_special(special[i],nspecial[i],tag[j]);
+          else if (imol >= 0)
+            which = find_special(onemols[imol]->special[iatom],
+                                 onemols[imol]->nspecial[iatom],
+                                 tag[j]-tagprev);
+          else which = 0;
+          if (which == 0) neighptr[n++] = jh;
+          else if (domain->minimum_image_check(delx,dely,delz))
+            neighptr[n++] = jh;
+          else if (which > 0) neighptr[n++] = jh ^ (which << SBBITS);
+        } else neighptr[n++] = jh;
+      }
+    }
+
+    // loop over all atoms in other bins in stencil, store every pair
+
+    ibin = atom2bin[i];
+    for (k = 0; k < nstencil; k++) {
+      for (j = binhead[ibin+stencil[k]]; j >= 0; j = bins[j]) {
+        if (exclude && exclusion(i,j,type[i],type[j],mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+        radsum = radi + radius[j];
+        cutsq = (radsum+skin) * (radsum+skin);
+
+        if (rsq <= cutsq) {
+          jh = j;
+          if (history && rsq < radsum*radsum)
+            jh = jh ^ mask_history;
+
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = jh;
+            else if (domain->minimum_image_check(delx,dely,delz))
+              neighptr[n++] = jh;
+            else if (which > 0) neighptr[n++] = jh ^ (which << SBBITS);
+          } else neighptr[n++] = jh;
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_bin_newton_omp.h ../lammps-stable_2Aug2023/src/npair_half_size_bin_newton_omp.h
--- lammps-stable_2Aug2023/src/npair_half_size_bin_newton_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_bin_newton_omp.h	2023-09-26 15:27:28.617240000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/size/bin/newton/omp,
+           NPairHalfSizeBinNewtonOmp,
+           NP_HALF | NP_SIZE | NP_BIN | NP_NEWTON | NP_OMP | NP_ORTHO);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_SIZE_BIN_NEWTON_OMP_H
+#define LMP_NPAIR_HALF_SIZE_BIN_NEWTON_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfSizeBinNewtonOmp : public NPair {
+ public:
+  NPairHalfSizeBinNewtonOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_bin_newton_tri_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_size_bin_newton_tri_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_size_bin_newton_tri_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_bin_newton_tri_omp.cpp	2023-09-26 15:27:27.334661000 -0400
@@ -0,0 +1,158 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_half_size_bin_newton_tri_omp.h"
+
+#include "atom.h"
+#include "atom_vec.h"
+#include "domain.h"
+#include "error.h"
+#include "molecule.h"
+#include "my_page.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfSizeBinNewtonTriOmp::NPairHalfSizeBinNewtonTriOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   size particles
+   binned neighbor list construction with Newton's 3rd law for triclinic
+   each owned atom i checks its own bin and other bins in triclinic stencil
+   every pair stored exactly once by some processor
+------------------------------------------------------------------------- */
+
+void NPairHalfSizeBinNewtonTriOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+  const int history = list->history;
+  const int mask_history = 1 << HISTBITS;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,jh,k,n,ibin,which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  double radi,radsum,cutsq;
+  int *neighptr;
+
+  // loop over each atom, storing neighbors
+
+  double **x = atom->x;
+  double *radius = atom->radius;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    radi = radius[i];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over all atoms in bins in stencil
+    // pairs for atoms j "below" i are excluded
+    // below = lower z or (equal z and lower y) or (equal zy and lower x)
+    //         (equal zyx and j <= i)
+    // latter excludes self-self interaction but allows superposed atoms
+
+    ibin = atom2bin[i];
+    for (k = 0; k < nstencil; k++) {
+      for (j = binhead[ibin+stencil[k]]; j >= 0; j = bins[j]) {
+        if (x[j][2] < ztmp) continue;
+        if (x[j][2] == ztmp) {
+          if (x[j][1] < ytmp) continue;
+          if (x[j][1] == ytmp) {
+            if (x[j][0] < xtmp) continue;
+            if (x[j][0] == xtmp && j <= i) continue;
+          }
+        }
+
+        if (exclude && exclusion(i,j,type[i],type[j],mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+        radsum = radi + radius[j];
+        cutsq = (radsum+skin) * (radsum+skin);
+
+        if (rsq <= cutsq) {
+          jh = j;
+          if (history && rsq < radsum*radsum)
+            jh = jh ^ mask_history;
+
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = jh;
+            else if (domain->minimum_image_check(delx,dely,delz))
+              neighptr[n++] = jh;
+            else if (which > 0) neighptr[n++] = jh ^ (which << SBBITS);
+          } else neighptr[n++] = jh;
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_bin_newton_tri_omp.h ../lammps-stable_2Aug2023/src/npair_half_size_bin_newton_tri_omp.h
--- lammps-stable_2Aug2023/src/npair_half_size_bin_newton_tri_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_bin_newton_tri_omp.h	2023-09-26 15:27:28.621816000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/size/bin/newton/tri/omp,
+           NPairHalfSizeBinNewtonTriOmp,
+           NP_HALF | NP_SIZE | NP_BIN | NP_NEWTON | NP_TRI | NP_OMP);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_SIZE_BIN_NEWTON_TRI_OMP_H
+#define LMP_NPAIR_HALF_SIZE_BIN_NEWTON_TRI_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfSizeBinNewtonTriOmp : public NPair {
+ public:
+  NPairHalfSizeBinNewtonTriOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_multi_newtoff_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_size_multi_newtoff_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_size_multi_newtoff_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_multi_newtoff_omp.cpp	2023-09-26 15:27:27.362026000 -0400
@@ -0,0 +1,172 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_half_size_multi_newtoff_omp.h"
+
+#include "atom.h"
+#include "atom_vec.h"
+#include "domain.h"
+#include "error.h"
+#include "molecule.h"
+#include "my_page.h"
+#include "neighbor.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfSizeMultiNewtoffOmp::NPairHalfSizeMultiNewtoffOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   size particles
+   binned neighbor list construction with partial Newton's 3rd law
+   multi stencil is icollection-jcollection dependent
+   each owned atom i checks own bin and other bins in stencil
+   pair stored once if i,j are both owned and i < j
+   pair stored by me if j is ghost (also stored by proc owning j)
+------------------------------------------------------------------------- */
+
+void NPairHalfSizeMultiNewtoffOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+  const int history = list->history;
+  const int mask_history = 1 << HISTBITS;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,jh,k,n,itype,jtype,icollection,jcollection,ibin,jbin,ns;
+  int which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  double radi,radsum,cutdistsq;
+  int *neighptr,*s;
+  int js;
+
+  // loop over each atom, storing neighbors
+
+  int *collection = neighbor->collection;
+  double **x = atom->x;
+  double *radius = atom->radius;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    icollection = collection[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    radi = radius[i];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    ibin = atom2bin[i];
+
+    // loop through stencils for all collections
+    for (jcollection = 0; jcollection < ncollections; jcollection++) {
+
+      // if same collection use own bin
+      if(icollection == jcollection) jbin = ibin;
+          else jbin = coord2bin(x[i], jcollection);
+
+      // loop over all atoms in other bins in stencil including self
+      // only store pair if i < j
+      // stores own/own pairs only once
+      // stores own/ghost pairs on both procs
+      // use full stencil for all collection combinations
+
+      s = stencil_multi[icollection][jcollection];
+      ns = nstencil_multi[icollection][jcollection];
+
+      for (k = 0; k < ns; k++) {
+        js = binhead_multi[jcollection][jbin + s[k]];
+        for (j = js; j >= 0; j = bins[j]) {
+          if (j <= i) continue;
+
+          jtype = type[j];
+          if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+          delx = xtmp - x[j][0];
+          dely = ytmp - x[j][1];
+          delz = ztmp - x[j][2];
+          rsq = delx*delx + dely*dely + delz*delz;
+          radsum = radi + radius[j];
+          cutdistsq = (radsum+skin) * (radsum+skin);
+
+          if (rsq <= cutdistsq) {
+            jh = j;
+            if (history && rsq < radsum*radsum)
+              jh = jh ^ mask_history;
+
+            if (molecular != Atom::ATOMIC) {
+              if (!moltemplate)
+                which = find_special(special[i],nspecial[i],tag[j]);
+              else if (imol >= 0)
+                which = find_special(onemols[imol]->special[iatom],
+                                     onemols[imol]->nspecial[iatom],
+                                     tag[j]-tagprev);
+              else which = 0;
+              if (which == 0) neighptr[n++] = jh;
+              else if (domain->minimum_image_check(delx,dely,delz))
+                neighptr[n++] = jh;
+              else if (which > 0) neighptr[n++] = jh ^ (which << SBBITS);
+            } else neighptr[n++] = jh;
+          }
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_multi_newtoff_omp.h ../lammps-stable_2Aug2023/src/npair_half_size_multi_newtoff_omp.h
--- lammps-stable_2Aug2023/src/npair_half_size_multi_newtoff_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_multi_newtoff_omp.h	2023-09-26 15:27:28.626093000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/size/multi/newtoff/omp,
+           NPairHalfSizeMultiNewtoffOmp,
+           NP_HALF | NP_SIZE | NP_MULTI | NP_NEWTOFF | NP_OMP | NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_SIZE_MULTI_NEWTOFF_OMP_H
+#define LMP_NPAIR_HALF_SIZE_MULTI_NEWTOFF_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfSizeMultiNewtoffOmp : public NPair {
+ public:
+  NPairHalfSizeMultiNewtoffOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_multi_newton_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_size_multi_newton_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_size_multi_newton_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_multi_newton_omp.cpp	2023-09-26 15:27:27.397573000 -0400
@@ -0,0 +1,225 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_half_size_multi_newton_omp.h"
+
+#include "atom.h"
+#include "atom_vec.h"
+#include "domain.h"
+#include "error.h"
+#include "molecule.h"
+#include "my_page.h"
+#include "neighbor.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfSizeMultiNewtonOmp::NPairHalfSizeMultiNewtonOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   size particles
+   binned neighbor list construction with full Newton's 3rd law
+   multi stencil is icollection-jcollection dependent
+   each owned atom i checks its own bin and other bins in Newton stencil
+   every pair stored exactly once by some processor
+------------------------------------------------------------------------- */
+
+void NPairHalfSizeMultiNewtonOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+  const int history = list->history;
+  const int mask_history = 1 << HISTBITS;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,jh,k,n,itype,jtype,icollection,jcollection,ibin,jbin,ns;
+  int which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  double radi,radsum,cutdistsq;
+  int *neighptr,*s;
+  int js;
+
+  // loop over each atom, storing neighbors
+
+  int *collection = neighbor->collection;
+  double **x = atom->x;
+  double *radius = atom->radius;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    icollection = collection[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    radi = radius[i];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    ibin = atom2bin[i];
+
+    // loop through stencils for all collections
+    for (jcollection = 0; jcollection < ncollections; jcollection++) {
+
+      // if same collection use own bin
+      if(icollection == jcollection) jbin = ibin;
+          else jbin = coord2bin(x[i], jcollection);
+
+      // if same size: uses half stencil so check central bin
+      if(cutcollectionsq[icollection][icollection] == cutcollectionsq[jcollection][jcollection]){
+
+        if(icollection == jcollection) js = bins[i];
+        else js = binhead_multi[jcollection][jbin];
+
+        // if same collection,
+        //   if j is owned atom, store it, since j is beyond i in linked list
+        //   if j is ghost, only store if j coords are "above and to the right" of i
+
+        // if different collections,
+        //   if j is owned atom, store it if j > i
+        //   if j is ghost, only store if j coords are "above and to the right" of i
+
+        for (j = js; j >= 0; j = bins[j]) {
+          if(icollection != jcollection && j < i) continue;
+
+              if (j >= nlocal) {
+                if (x[j][2] < ztmp) continue;
+                if (x[j][2] == ztmp) {
+                  if (x[j][1] < ytmp) continue;
+                  if (x[j][1] == ytmp && x[j][0] < xtmp) continue;
+                }
+              }
+
+          jtype = type[j];
+          if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+          delx = xtmp - x[j][0];
+          dely = ytmp - x[j][1];
+          delz = ztmp - x[j][2];
+          rsq = delx*delx + dely*dely + delz*delz;
+          radsum = radi + radius[j];
+          cutdistsq = (radsum+skin) * (radsum+skin);
+
+          if (rsq <= cutdistsq) {
+            jh = j;
+            if (history && rsq < radsum*radsum)
+              jh = jh ^ mask_history;
+
+            if (molecular != Atom::ATOMIC) {
+              if (!moltemplate)
+                which = find_special(special[i],nspecial[i],tag[j]);
+              else if (imol >= 0)
+                which = find_special(onemols[imol]->special[iatom],
+                                     onemols[imol]->nspecial[iatom],
+                                     tag[j]-tagprev);
+              else which = 0;
+              if (which == 0) neighptr[n++] = jh;
+              else if (domain->minimum_image_check(delx,dely,delz))
+                neighptr[n++] = jh;
+              else if (which > 0) neighptr[n++] = jh ^ (which << SBBITS);
+            } else neighptr[n++] = jh;
+          }
+        }
+      }
+
+      // for all collections, loop over all atoms in other bins in stencil, store every pair
+      // stencil is empty if i larger than j
+      // stencil is half if i same size as j
+      // stencil is full if i smaller than j
+
+      s = stencil_multi[icollection][jcollection];
+      ns = nstencil_multi[icollection][jcollection];
+
+      for (k = 0; k < ns; k++) {
+        js = binhead_multi[jcollection][jbin + s[k]];
+        for (j = js; j >= 0; j = bins[j]) {
+
+          jtype = type[j];
+          if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+          delx = xtmp - x[j][0];
+          dely = ytmp - x[j][1];
+          delz = ztmp - x[j][2];
+          rsq = delx*delx + dely*dely + delz*delz;
+          radsum = radi + radius[j];
+          cutdistsq = (radsum+skin) * (radsum+skin);
+
+          if (rsq <= cutdistsq) {
+            if (history && rsq < radsum*radsum)
+              j = j ^ mask_history;
+
+            if (molecular != Atom::ATOMIC) {
+              if (!moltemplate)
+                which = find_special(special[i],nspecial[i],tag[j]);
+              else if (imol >= 0)
+                which = find_special(onemols[imol]->special[iatom],
+                                     onemols[imol]->nspecial[iatom],
+                                     tag[j]-tagprev);
+              else which = 0;
+              if (which == 0) neighptr[n++] = j;
+              else if (domain->minimum_image_check(delx,dely,delz))
+                neighptr[n++] = j;
+              else if (which > 0) neighptr[n++] = j ^ (which << SBBITS);
+            } else neighptr[n++] = j;
+          }
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_multi_newton_omp.h ../lammps-stable_2Aug2023/src/npair_half_size_multi_newton_omp.h
--- lammps-stable_2Aug2023/src/npair_half_size_multi_newton_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_multi_newton_omp.h	2023-09-26 15:27:28.630463000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/size/multi/newton/omp,
+           NPairHalfSizeMultiNewtonOmp,
+           NP_HALF | NP_SIZE | NP_MULTI | NP_NEWTON | NP_OMP | NP_ORTHO);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_SIZE_MULTI_NEWTON_OMP_H
+#define LMP_NPAIR_HALF_SIZE_MULTI_NEWTON_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfSizeMultiNewtonOmp : public NPair {
+ public:
+  NPairHalfSizeMultiNewtonOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_multi_newton_tri_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_size_multi_newton_tri_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_size_multi_newton_tri_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_multi_newton_tri_omp.cpp	2023-09-26 15:27:27.422606000 -0400
@@ -0,0 +1,187 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_half_size_multi_newton_tri_omp.h"
+
+#include "atom.h"
+#include "atom_vec.h"
+#include "domain.h"
+#include "error.h"
+#include "molecule.h"
+#include "my_page.h"
+#include "neighbor.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfSizeMultiNewtonTriOmp::NPairHalfSizeMultiNewtonTriOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   size particles
+   binned neighbor list construction with Newton's 3rd law for triclinic
+   multi stencil is icollection-jcollection dependent
+   each owned atom i checks its own bin and other bins in triclinic stencil
+   every pair stored exactly once by some processor
+------------------------------------------------------------------------- */
+
+void NPairHalfSizeMultiNewtonTriOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+  const int history = list->history;
+  const int mask_history = 1 << HISTBITS;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,jh,k,n,itype,jtype,icollection,jcollection,ibin,jbin,ns;
+  int which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  double radi,radsum,cutdistsq;
+  int *neighptr,*s;
+  int js;
+
+  // loop over each atom, storing neighbors
+
+  int *collection = neighbor->collection;
+  double **x = atom->x;
+  double *radius = atom->radius;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    icollection = collection[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    radi = radius[i];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    ibin = atom2bin[i];
+
+    // loop through stencils for all collections
+    for (jcollection = 0; jcollection < ncollections; jcollection++) {
+
+      // if same collection use own bin
+      if(icollection == jcollection) jbin = ibin;
+          else jbin = coord2bin(x[i], jcollection);
+
+
+      // loop over all atoms in bins in stencil
+      // stencil is empty if i larger than j
+      // stencil is half if i same size as j
+      // stencil is full if i smaller than j
+      // if half: pairs for atoms j "below" i are excluded
+      // below = lower z or (equal z and lower y) or (equal zy and lower x)
+      //         (equal zyx and j <= i)
+      // latter excludes self-self interaction but allows superposed atoms
+
+      s = stencil_multi[icollection][jcollection];
+      ns = nstencil_multi[icollection][jcollection];
+
+      for (k = 0; k < ns; k++) {
+        js = binhead_multi[jcollection][jbin + s[k]];
+        for (j = js; j >= 0; j = bins[j]) {
+
+          // if same size (same collection), use half stencil
+          if(cutcollectionsq[icollection][icollection] == cutcollectionsq[jcollection][jcollection]){
+            if (x[j][2] < ztmp) continue;
+            if (x[j][2] == ztmp) {
+              if (x[j][1] < ytmp) continue;
+              if (x[j][1] == ytmp) {
+                if (x[j][0] < xtmp) continue;
+                if (x[j][0] == xtmp && j <= i) continue;
+              }
+            }
+          }
+
+          jtype = type[j];
+          if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+          delx = xtmp - x[j][0];
+          dely = ytmp - x[j][1];
+          delz = ztmp - x[j][2];
+          rsq = delx*delx + dely*dely + delz*delz;
+          radsum = radi + radius[j];
+          cutdistsq = (radsum+skin) * (radsum+skin);
+
+          if (rsq <= cutdistsq) {
+            jh = j;
+            if (history && rsq < radsum*radsum)
+              jh = jh ^ mask_history;
+
+            if (molecular != Atom::ATOMIC) {
+              if (!moltemplate)
+                which = find_special(special[i],nspecial[i],tag[j]);
+              else if (imol >= 0)
+                which = find_special(onemols[imol]->special[iatom],
+                                     onemols[imol]->nspecial[iatom],
+                                     tag[j]-tagprev);
+              else which = 0;
+              if (which == 0) neighptr[n++] = jh;
+              else if (domain->minimum_image_check(delx,dely,delz))
+                neighptr[n++] = jh;
+              else if (which > 0) neighptr[n++] = jh ^ (which << SBBITS);
+            } else neighptr[n++] = jh;
+          }
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_multi_newton_tri_omp.h ../lammps-stable_2Aug2023/src/npair_half_size_multi_newton_tri_omp.h
--- lammps-stable_2Aug2023/src/npair_half_size_multi_newton_tri_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_multi_newton_tri_omp.h	2023-09-26 15:27:28.634704000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/size/multi/newton/tri/omp,
+           NPairHalfSizeMultiNewtonTriOmp,
+           NP_HALF | NP_SIZE | NP_MULTI | NP_NEWTON | NP_TRI | NP_OMP);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_SIZE_MULTI_NEWTON_TRI_OMP_H
+#define LMP_NPAIR_HALF_SIZE_MULTI_NEWTON_TRI_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfSizeMultiNewtonTriOmp : public NPair {
+ public:
+  NPairHalfSizeMultiNewtonTriOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_multi_old_newtoff_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_size_multi_old_newtoff_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_size_multi_old_newtoff_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_multi_old_newtoff_omp.cpp	2023-09-26 15:27:27.439324000 -0400
@@ -0,0 +1,158 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_half_size_multi_old_newtoff_omp.h"
+
+#include "atom.h"
+#include "atom_vec.h"
+#include "domain.h"
+#include "error.h"
+#include "molecule.h"
+#include "my_page.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfSizeMultiOldNewtoffOmp::NPairHalfSizeMultiOldNewtoffOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   size particles
+   binned neighbor list construction with partial Newton's 3rd law
+   each owned atom i checks own bin and other bins in stencil
+   multi-type stencil is itype dependent and is distance checked
+   pair stored once if i,j are both owned and i < j
+   pair stored by me if j is ghost (also stored by proc owning j)
+------------------------------------------------------------------------- */
+
+void NPairHalfSizeMultiOldNewtoffOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+  const int history = list->history;
+  const int mask_history = 1 << HISTBITS;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,jh,k,n,itype,jtype,ibin,ns,which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  double radi,radsum,cutdistsq;
+  int *neighptr,*s;
+  double *cutsq,*distsq;
+
+  double **x = atom->x;
+  double *radius = atom->radius;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    radi = radius[i];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over all atoms in other bins in stencil including self
+    // only store pair if i < j
+    // skip if i,j neighbor cutoff is less than bin distance
+    // stores own/own pairs only once
+    // stores own/ghost pairs on both procs
+
+    ibin = atom2bin[i];
+    s = stencil_multi_old[itype];
+    distsq = distsq_multi_old[itype];
+    cutsq = cutneighsq[itype];
+    ns = nstencil_multi_old[itype];
+    for (k = 0; k < ns; k++) {
+      for (j = binhead[ibin+s[k]]; j >= 0; j = bins[j]) {
+        if (j <= i) continue;
+        jtype = type[j];
+        if (cutsq[jtype] < distsq[k]) continue;
+
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+        radsum = radi + radius[j];
+        cutdistsq = (radsum+skin) * (radsum+skin);
+
+        if (rsq <= cutdistsq) {
+          jh = j;
+          if (history && rsq < radsum*radsum)
+            jh = jh ^ mask_history;
+
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = jh;
+            else if (domain->minimum_image_check(delx,dely,delz))
+              neighptr[n++] = jh;
+            else if (which > 0) neighptr[n++] = jh ^ (which << SBBITS);
+          } else neighptr[n++] = jh;
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_multi_old_newtoff_omp.h ../lammps-stable_2Aug2023/src/npair_half_size_multi_old_newtoff_omp.h
--- lammps-stable_2Aug2023/src/npair_half_size_multi_old_newtoff_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_multi_old_newtoff_omp.h	2023-09-26 15:27:28.638959000 -0400
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/size/multi/old/newtoff/omp,
+           NPairHalfSizeMultiOldNewtoffOmp,
+           NP_HALF | NP_SIZE | NP_MULTI_OLD | NP_NEWTOFF | NP_OMP |
+           NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_SIZE_MULTI_OLD_NEWTOFF_OMP_H
+#define LMP_NPAIR_HALF_SIZE_MULTI_OLD_NEWTOFF_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfSizeMultiOldNewtoffOmp : public NPair {
+ public:
+  NPairHalfSizeMultiOldNewtoffOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_multi_old_newton_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_size_multi_old_newton_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_size_multi_old_newton_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_multi_old_newton_omp.cpp	2023-09-26 15:27:27.460633000 -0400
@@ -0,0 +1,196 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_half_size_multi_old_newton_omp.h"
+
+#include "atom.h"
+#include "atom_vec.h"
+#include "domain.h"
+#include "error.h"
+#include "molecule.h"
+#include "my_page.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfSizeMultiOldNewtonOmp::NPairHalfSizeMultiOldNewtonOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   size particles
+   binned neighbor list construction with full Newton's 3rd law
+   each owned atom i checks its own bin and other bins in Newton stencil
+   multi-type stencil is itype dependent and is distance checked
+   every pair stored exactly once by some processor
+------------------------------------------------------------------------- */
+
+void NPairHalfSizeMultiOldNewtonOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+  const int history = list->history;
+  const int mask_history = 1 << HISTBITS;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,jh,k,n,itype,jtype,ibin,ns,which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  double radi,radsum,cutdistsq;
+  int *neighptr,*s;
+  double *cutsq,*distsq;
+
+  double **x = atom->x;
+  double *radius = atom->radius;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    radi = radius[i];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over rest of atoms in i's bin, ghosts are at end of linked list
+    // if j is owned atom, store it, since j is beyond i in linked list
+    // if j is ghost, only store if j coords are "above and to the right" of i
+
+    for (j = bins[i]; j >= 0; j = bins[j]) {
+      if (j >= nlocal) {
+        if (x[j][2] < ztmp) continue;
+        if (x[j][2] == ztmp) {
+          if (x[j][1] < ytmp) continue;
+          if (x[j][1] == ytmp && x[j][0] < xtmp) continue;
+        }
+      }
+
+      jtype = type[j];
+      if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+      radsum = radi + radius[j];
+      cutdistsq = (radsum+skin) * (radsum+skin);
+
+      if (rsq <= cutdistsq) {
+        jh = j;
+        if (history && rsq < radsum*radsum)
+          jh = jh ^ mask_history;
+
+        if (molecular != Atom::ATOMIC) {
+          if (!moltemplate)
+            which = find_special(special[i],nspecial[i],tag[j]);
+          else if (imol >= 0)
+            which = find_special(onemols[imol]->special[iatom],
+                                 onemols[imol]->nspecial[iatom],
+                                 tag[j]-tagprev);
+          else which = 0;
+          if (which == 0) neighptr[n++] = jh;
+          else if (domain->minimum_image_check(delx,dely,delz))
+            neighptr[n++] = jh;
+          else if (which > 0) neighptr[n++] = jh ^ (which << SBBITS);
+        } else neighptr[n++] = jh;
+      }
+    }
+
+    // loop over all atoms in other bins in stencil, store every pair
+    // skip if i,j neighbor cutoff is less than bin distance
+
+    ibin = atom2bin[i];
+    s = stencil_multi_old[itype];
+    distsq = distsq_multi_old[itype];
+    cutsq = cutneighsq[itype];
+    ns = nstencil_multi_old[itype];
+    for (k = 0; k < ns; k++) {
+      for (j = binhead[ibin+s[k]]; j >= 0; j = bins[j]) {
+        jtype = type[j];
+        if (cutsq[jtype] < distsq[k]) continue;
+
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+        radsum = radi + radius[j];
+        cutdistsq = (radsum+skin) * (radsum+skin);
+
+        if (rsq <= cutdistsq) {
+          jh = j;
+          if (history && rsq < radsum*radsum)
+            jh = jh ^ mask_history;
+
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = jh;
+            else if (domain->minimum_image_check(delx,dely,delz))
+              neighptr[n++] = jh;
+            else if (which > 0) neighptr[n++] = jh ^ (which << SBBITS);
+          } else neighptr[n++] = jh;
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_multi_old_newton_omp.h ../lammps-stable_2Aug2023/src/npair_half_size_multi_old_newton_omp.h
--- lammps-stable_2Aug2023/src/npair_half_size_multi_old_newton_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_multi_old_newton_omp.h	2023-09-26 15:27:28.643177000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/size/multi/old/newton/omp,
+           NPairHalfSizeMultiOldNewtonOmp,
+           NP_HALF | NP_SIZE | NP_MULTI_OLD | NP_NEWTON | NP_OMP | NP_ORTHO);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_SIZE_MULTI_OLD_NEWTON_OMP_H
+#define LMP_NPAIR_HALF_SIZE_MULTI_OLD_NEWTON_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfSizeMultiOldNewtonOmp : public NPair {
+ public:
+  NPairHalfSizeMultiOldNewtonOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_multi_old_newton_tri_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_size_multi_old_newton_tri_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_size_multi_old_newton_tri_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_multi_old_newton_tri_omp.cpp	2023-09-26 15:27:27.471552000 -0400
@@ -0,0 +1,166 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_half_size_multi_old_newton_tri_omp.h"
+
+#include "atom.h"
+#include "atom_vec.h"
+#include "domain.h"
+#include "error.h"
+#include "molecule.h"
+#include "my_page.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfSizeMultiOldNewtonTriOmp::NPairHalfSizeMultiOldNewtonTriOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   size particles
+   binned neighbor list construction with Newton's 3rd law for triclinic
+   each owned atom i checks its own bin and other bins in triclinic stencil
+   multi-type stencil is itype dependent and is distance checked
+   every pair stored exactly once by some processor
+------------------------------------------------------------------------- */
+
+void NPairHalfSizeMultiOldNewtonTriOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+  const int history = list->history;
+  const int mask_history = 1 << HISTBITS;
+
+  NPAIR_OMP_INIT;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,jh,k,n,itype,jtype,ibin,ns,which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  double radi,radsum,cutdistsq;
+  int *neighptr,*s;
+  double *cutsq,*distsq;
+
+  double **x = atom->x;
+  double *radius = atom->radius;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itype = type[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    radi = radius[i];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over all atoms in bins, including self, in stencil
+    // skip if i,j neighbor cutoff is less than bin distance
+    // bins below self are excluded from stencil
+    // pairs for atoms j "below" i are excluded
+    // below = lower z or (equal z and lower y) or (equal zy and lower x)
+    //         (equal zyx and j <= i)
+    // latter excludes self-self interaction but allows superposed atoms
+
+    ibin = atom2bin[i];
+    s = stencil_multi_old[itype];
+    distsq = distsq_multi_old[itype];
+    cutsq = cutneighsq[itype];
+    ns = nstencil_multi_old[itype];
+    for (k = 0; k < ns; k++) {
+      for (j = binhead[ibin+s[k]]; j >= 0; j = bins[j]) {
+        jtype = type[j];
+        if (cutsq[jtype] < distsq[k]) continue;
+        if (x[j][2] < ztmp) continue;
+        if (x[j][2] == ztmp) {
+          if (x[j][1] < ytmp) continue;
+          if (x[j][1] == ytmp) {
+            if (x[j][0] < xtmp) continue;
+            if (x[j][0] == xtmp && j <= i) continue;
+          }
+        }
+
+        if (exclude && exclusion(i,j,itype,jtype,mask,molecule)) continue;
+
+        delx = xtmp - x[j][0];
+        dely = ytmp - x[j][1];
+        delz = ztmp - x[j][2];
+        rsq = delx*delx + dely*dely + delz*delz;
+        radsum = radi + radius[j];
+        cutdistsq = (radsum+skin) * (radsum+skin);
+
+        if (rsq <= cutdistsq) {
+          jh = j;
+          if (history && rsq < radsum*radsum)
+            jh = jh ^ mask_history;
+
+          if (molecular != Atom::ATOMIC) {
+            if (!moltemplate)
+              which = find_special(special[i],nspecial[i],tag[j]);
+            else if (imol >= 0)
+              which = find_special(onemols[imol]->special[iatom],
+                                   onemols[imol]->nspecial[iatom],
+                                   tag[j]-tagprev);
+            else which = 0;
+            if (which == 0) neighptr[n++] = jh;
+            else if (domain->minimum_image_check(delx,dely,delz))
+              neighptr[n++] = jh;
+            else if (which > 0) neighptr[n++] = jh ^ (which << SBBITS);
+          } else neighptr[n++] = jh;
+        }
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_multi_old_newton_tri_omp.h ../lammps-stable_2Aug2023/src/npair_half_size_multi_old_newton_tri_omp.h
--- lammps-stable_2Aug2023/src/npair_half_size_multi_old_newton_tri_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_multi_old_newton_tri_omp.h	2023-09-26 15:27:28.647252000 -0400
@@ -0,0 +1,38 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/size/multi/old/newton/tri/omp,
+           NPairHalfSizeMultiOldNewtonTriOmp,
+           NP_HALF | NP_SIZE | NP_MULTI_OLD | NP_NEWTON | NP_TRI | NP_OMP);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_SIZE_MULTI_OLD_NEWTON_TRI_OMP_H
+#define LMP_NPAIR_HALF_SIZE_MULTI_OLD_NEWTON_TRI_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfSizeMultiOldNewtonTriOmp : public NPair {
+ public:
+  NPairHalfSizeMultiOldNewtonTriOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_nsq_newtoff_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_size_nsq_newtoff_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_size_nsq_newtoff_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_nsq_newtoff_omp.cpp	2023-09-26 15:27:27.508878000 -0400
@@ -0,0 +1,147 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_half_size_nsq_newtoff_omp.h"
+
+#include "atom.h"
+#include "atom_vec.h"
+#include "domain.h"
+#include "error.h"
+#include "molecule.h"
+#include "group.h"
+#include "my_page.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfSizeNsqNewtoffOmp::NPairHalfSizeNsqNewtoffOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   size particles
+   N^2 / 2 search for neighbor pairs with partial Newton's 3rd law
+   shear history must be accounted for when a neighbor pair is added
+   pair added to list if atoms i and j are both owned and i < j
+   pair added if j is ghost (also stored by proc owning j)
+------------------------------------------------------------------------- */
+
+void NPairHalfSizeNsqNewtoffOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int bitmask = (includegroup) ? group->bitmask[includegroup] : 0;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+  const int history = list->history;
+  const int mask_history = 1 << HISTBITS;
+
+  NPAIR_OMP_INIT;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,jh,n,which,imol,iatom;
+  tagint tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  double radi,radsum,cutsq;
+  int *neighptr;
+
+  double **x = atom->x;
+  double *radius = atom->radius;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *tag = atom->tag;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int nall = atom->nlocal + atom->nghost;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    radi = radius[i];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over remaining atoms, owned and ghost
+
+    for (j = i+1; j < nall; j++) {
+      if (includegroup && !(mask[j] & bitmask)) continue;
+      if (exclude && exclusion(i,j,type[i],type[j],mask,molecule)) continue;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+      radsum = radi + radius[j];
+      cutsq = (radsum+skin) * (radsum+skin);
+
+      if (rsq <= cutsq) {
+        jh = j;
+        if (history && rsq < radsum*radsum)
+          jh = jh ^ mask_history;
+
+        if (molecular != Atom::ATOMIC) {
+          if (!moltemplate)
+            which = find_special(special[i],nspecial[i],tag[j]);
+          else if (imol >= 0)
+            which = find_special(onemols[imol]->special[iatom],
+                                 onemols[imol]->nspecial[iatom],
+                                 tag[j]-tagprev);
+          else which = 0;
+          if (which == 0) neighptr[n++] = jh;
+          else if (domain->minimum_image_check(delx,dely,delz))
+            neighptr[n++] = jh;
+          else if (which > 0) neighptr[n++] = jh ^ (which << SBBITS);
+        } else neighptr[n++] = jh;
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_nsq_newtoff_omp.h ../lammps-stable_2Aug2023/src/npair_half_size_nsq_newtoff_omp.h
--- lammps-stable_2Aug2023/src/npair_half_size_nsq_newtoff_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_nsq_newtoff_omp.h	2023-09-26 15:27:28.651609000 -0400
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/size/nsq/newtoff/omp,
+           NPairHalfSizeNsqNewtoffOmp,
+           NP_HALF | NP_SIZE | NP_NSQ | NP_NEWTOFF | NP_OMP |
+           NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_SIZE_NSQ_NEWTOFF_OMP_H
+#define LMP_NPAIR_HALF_SIZE_NSQ_NEWTOFF_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfSizeNsqNewtoffOmp : public NPair {
+ public:
+  NPairHalfSizeNsqNewtoffOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_nsq_newton_omp.cpp ../lammps-stable_2Aug2023/src/npair_half_size_nsq_newton_omp.cpp
--- lammps-stable_2Aug2023/src/npair_half_size_nsq_newton_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_nsq_newton_omp.cpp	2023-09-26 15:27:27.530346000 -0400
@@ -0,0 +1,166 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_half_size_nsq_newton_omp.h"
+
+#include "atom.h"
+#include "atom_vec.h"
+#include "domain.h"
+#include "error.h"
+#include "molecule.h"
+#include "group.h"
+#include "my_page.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairHalfSizeNsqNewtonOmp::NPairHalfSizeNsqNewtonOmp(LAMMPS *lmp) :
+  NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   size particles
+   N^2 / 2 search for neighbor pairs with full Newton's 3rd law
+   shear history must be accounted for when a neighbor pair is added
+   pair added to list if atoms i and j are both owned and i < j
+   if j is ghost only me or other proc adds pair
+   decision based on itag,jtag tests
+------------------------------------------------------------------------- */
+
+void NPairHalfSizeNsqNewtonOmp::build(NeighList *list)
+{
+  const int nlocal = (includegroup) ? atom->nfirst : atom->nlocal;
+  const int bitmask = (includegroup) ? group->bitmask[includegroup] : 0;
+  const int molecular = atom->molecular;
+  const int moltemplate = (molecular == Atom::TEMPLATE) ? 1 : 0;
+  const int history = list->history;
+  const int mask_history = 1 << HISTBITS;
+
+  NPAIR_OMP_INIT;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(nlocal);
+
+  int i,j,jh,n,which,imol,iatom;
+  tagint itag,jtag,tagprev;
+  double xtmp,ytmp,ztmp,delx,dely,delz,rsq;
+  double radi,radsum,cutsq;
+  int *neighptr;
+
+  double **x = atom->x;
+  double *radius = atom->radius;
+  tagint *tag = atom->tag;
+  int *type = atom->type;
+  int *mask = atom->mask;
+  tagint *molecule = atom->molecule;
+  tagint **special = atom->special;
+  int **nspecial = atom->nspecial;
+
+  int *molindex = atom->molindex;
+  int *molatom = atom->molatom;
+  Molecule **onemols = atom->avec->onemols;
+
+  int nall = atom->nlocal + atom->nghost;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  for (i = ifrom; i < ito; i++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    itag = tag[i];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+    radi = radius[i];
+    if (moltemplate) {
+      imol = molindex[i];
+      iatom = molatom[i];
+      tagprev = tag[i] - iatom - 1;
+    }
+
+    // loop over remaining atoms, owned and ghost
+
+    for (j = i+1; j < nall; j++) {
+      if (includegroup && !(mask[j] & bitmask)) continue;
+
+      if (j >= nlocal) {
+        jtag = tag[j];
+        if (itag > jtag) {
+          if ((itag+jtag) % 2 == 0) continue;
+        } else if (itag < jtag) {
+          if ((itag+jtag) % 2 == 1) continue;
+        } else {
+          if (x[j][2] < ztmp) continue;
+          if (x[j][2] == ztmp) {
+            if (x[j][1] < ytmp) continue;
+            if (x[j][1] == ytmp && x[j][0] < xtmp) continue;
+          }
+        }
+      }
+
+      if (exclude && exclusion(i,j,type[i],type[j],mask,molecule)) continue;
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx*delx + dely*dely + delz*delz;
+      radsum = radi + radius[j];
+      cutsq = (radsum+skin) * (radsum+skin);
+
+      if (rsq <= cutsq) {
+        jh = j;
+        if (history && rsq < radsum*radsum)
+          jh = jh ^ mask_history;
+
+        if (molecular != Atom::ATOMIC) {
+          if (!moltemplate)
+            which = find_special(special[i],nspecial[i],tag[j]);
+          else if (imol >= 0)
+            which = find_special(onemols[imol]->special[iatom],
+                                 onemols[imol]->nspecial[iatom],
+                                 tag[j]-tagprev);
+          else which = 0;
+          if (which == 0) neighptr[n++] = jh;
+          else if (domain->minimum_image_check(delx,dely,delz))
+            neighptr[n++] = jh;
+          else if (which > 0) neighptr[n++] = jh ^ (which << SBBITS);
+        } else neighptr[n++] = jh;
+      }
+    }
+
+    ilist[i] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = nlocal;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_half_size_nsq_newton_omp.h ../lammps-stable_2Aug2023/src/npair_half_size_nsq_newton_omp.h
--- lammps-stable_2Aug2023/src/npair_half_size_nsq_newton_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_half_size_nsq_newton_omp.h	2023-09-26 15:27:28.655782000 -0400
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(half/size/nsq/newton/omp,
+           NPairHalfSizeNsqNewtonOmp,
+           NP_HALF | NP_SIZE | NP_NSQ | NP_NEWTON | NP_OMP |
+           NP_ORTHO | NP_TRI);
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_HALF_SIZE_NSQ_NEWTON_OMP_H
+#define LMP_NPAIR_HALF_SIZE_NSQ_NEWTON_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairHalfSizeNsqNewtonOmp : public NPair {
+ public:
+  NPairHalfSizeNsqNewtonOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_omp.h ../lammps-stable_2Aug2023/src/npair_omp.h
--- lammps-stable_2Aug2023/src/npair_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_omp.h	2023-09-26 15:27:28.677839000 -0400
@@ -0,0 +1,67 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifndef LMP_NPAIR_OMP_H
+#define LMP_NPAIR_OMP_H
+
+#if defined(_OPENMP)
+#include <omp.h>
+#endif
+
+#include "comm.h"
+#include "fix_omp.h"
+#include "modify.h"
+#include "thr_data.h"
+#include "timer.h"
+
+namespace LAMMPS_NS {
+
+// these macros hide some ugly and redundant OpenMP related stuff
+#if defined(_OPENMP)
+
+// get access to number of threads and per-thread data structures via FixOMP
+#define NPAIR_OMP_INIT                 \
+  const int nthreads = comm->nthreads; \
+  const int ifix = modify->find_fix("package_omp")
+
+// get thread id and then assign each thread a fixed chunk of atoms
+#define NPAIR_OMP_SETUP(num)                                           \
+  {                                                                    \
+    const int tid = omp_get_thread_num();                              \
+    const int idelta = 1 + num / nthreads;                             \
+    const int ifrom = tid * idelta;                                    \
+    const int ito = ((ifrom + idelta) > num) ? num : (ifrom + idelta); \
+    FixOMP *fix = static_cast<FixOMP *>(modify->fix[ifix]);            \
+    ThrData *thr = fix->get_thr(tid);                                  \
+    thr->timer(Timer::START);
+
+#define NPAIR_OMP_CLOSE     \
+  thr->timer(Timer::NEIGH); \
+  }
+
+#else /* !defined(_OPENMP) */
+
+#define NPAIR_OMP_INIT
+
+#define NPAIR_OMP_SETUP(num) \
+  const int tid = 0;         \
+  const int ifrom = 0;       \
+  const int ito = num
+
+#define NPAIR_OMP_CLOSE
+
+#endif
+
+}    // namespace LAMMPS_NS
+
+#endif
diff -ruN lammps-stable_2Aug2023/src/npair_skip_omp.h ../lammps-stable_2Aug2023/src/npair_skip_omp.h
--- lammps-stable_2Aug2023/src/npair_skip_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_skip_omp.h	2023-09-26 15:27:28.682208000 -0400
@@ -0,0 +1,55 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+// There is no benefit from multi-threading for skip lists, so we
+// just forward the requests to the corresponding non-omp versions.
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(skip/omp,
+           NPairSkip,
+           NP_SKIP | NP_HALF | NP_FULL |
+           NP_NSQ | NP_BIN | NP_MULTI | NP_MULTI_OLD |
+           NP_NEWTON | NP_NEWTOFF | NP_ORTHO | NP_TRI | NP_OMP);
+
+NPairStyle(skip/half/respa/omp,
+           NPairSkipRespa,
+           NP_SKIP | NP_RESPA | NP_HALF | NP_FULL |
+           NP_NSQ | NP_BIN | NP_MULTI | NP_MULTI_OLD |
+           NP_NEWTON | NP_NEWTOFF | NP_ORTHO | NP_TRI | NP_OMP);
+
+NPairStyle(skip/half/size/omp,
+           NPairSkipSize,
+           NP_SKIP | NP_SIZE | NP_HALF | NP_FULL | NP_NSQ | NP_BIN | NP_MULTI | NP_MULTI_OLD |
+           NP_NEWTON | NP_NEWTOFF | NP_ORTHO | NP_TRI | NP_OMP);
+
+NPairStyle(skip/size/off2on/omp,
+           NPairSkipSizeOff2on,
+           NP_SKIP | NP_SIZE | NP_OFF2ON | NP_HALF |
+           NP_NSQ | NP_BIN | NP_MULTI | NP_MULTI_OLD | NP_MULTI_OLD |
+           NP_NEWTON | NP_NEWTOFF | NP_ORTHO | NP_TRI | NP_OMP);
+
+NPairStyle(skip/size/off2on/oneside/omp,
+           NPairSkipSizeOff2onOneside,
+           NP_SKIP | NP_SIZE | NP_OFF2ON | NP_ONESIDE | NP_HALF |
+           NP_NSQ | NP_BIN | NP_MULTI | NP_MULTI_OLD | NP_NEWTON | NP_NEWTOFF |
+           NP_ORTHO | NP_TRI | NP_OMP);
+
+NPairStyle(skip/ghost/omp,
+           NPairSkip,
+           NP_SKIP | NP_HALF | NP_FULL |
+           NP_NSQ | NP_BIN | NP_MULTI | NP_MULTI_OLD |
+           NP_NEWTON | NP_NEWTOFF | NP_ORTHO | NP_TRI | NP_OMP | NP_GHOST);
+// clang-format off
+#endif
+
diff -ruN lammps-stable_2Aug2023/src/npair_trim_omp.cpp ../lammps-stable_2Aug2023/src/npair_trim_omp.cpp
--- lammps-stable_2Aug2023/src/npair_trim_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_trim_omp.cpp	2023-09-26 15:27:27.552468000 -0400
@@ -0,0 +1,108 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#include "npair_trim_omp.h"
+
+#include "atom.h"
+#include "error.h"
+#include "my_page.h"
+#include "neigh_list.h"
+#include "npair_omp.h"
+
+#include "omp_compat.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+NPairTrimOmp::NPairTrimOmp(LAMMPS *lmp) : NPair(lmp) {}
+
+/* ----------------------------------------------------------------------
+   trim from copy list to shorter cutoff
+------------------------------------------------------------------------- */
+
+void NPairTrimOmp::build(NeighList *list)
+{
+  const int inum_copy = list->listcopy->inum;
+
+  NPAIR_OMP_INIT;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(list)
+#endif
+  NPAIR_OMP_SETUP(inum_copy);
+
+  int i,j,ii,jj,n,jnum,joriginal;
+  int *neighptr,*jlist;
+  double xtmp,ytmp,ztmp;
+  double delx,dely,delz,rsq;
+
+  double **x = atom->x;
+
+  int *ilist = list->ilist;
+  int *numneigh = list->numneigh;
+  int **firstneigh = list->firstneigh;
+  int *ilist_copy = list->listcopy->ilist;
+  int *numneigh_copy = list->listcopy->numneigh;
+  int **firstneigh_copy = list->listcopy->firstneigh;
+
+  // each thread has its own page allocator
+  MyPage<int> &ipage = list->ipage[tid];
+  ipage.reset();
+
+  double cutsq_custom = cutoff_custom * cutoff_custom;
+
+  // loop over atoms in copy list
+
+  for (ii = ifrom; ii < ito; ii++) {
+
+    n = 0;
+    neighptr = ipage.vget();
+
+    // loop over parent copy list
+
+    i = ilist_copy[ii];
+    xtmp = x[i][0];
+    ytmp = x[i][1];
+    ztmp = x[i][2];
+
+    jlist = firstneigh_copy[i];
+    jnum = numneigh_copy[i];
+
+    for (jj = 0; jj < jnum; jj++) {
+      joriginal = jlist[jj];
+      j = joriginal & NEIGHMASK;
+
+      // trim to shorter cutoff
+
+      delx = xtmp - x[j][0];
+      dely = ytmp - x[j][1];
+      delz = ztmp - x[j][2];
+      rsq = delx * delx + dely * dely + delz * delz;
+
+      if (rsq > cutsq_custom) continue;
+
+      neighptr[n++] = joriginal;
+    }
+
+    ilist[ii] = i;
+    firstneigh[i] = neighptr;
+    numneigh[i] = n;
+    ipage.vgot(n);
+    if (ipage.status())
+      error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+  }
+  NPAIR_OMP_CLOSE;
+  list->inum = inum_copy;
+}
diff -ruN lammps-stable_2Aug2023/src/npair_trim_omp.h ../lammps-stable_2Aug2023/src/npair_trim_omp.h
--- lammps-stable_2Aug2023/src/npair_trim_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/npair_trim_omp.h	2023-09-26 15:27:28.686479000 -0400
@@ -0,0 +1,39 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef NPAIR_CLASS
+// clang-format off
+NPairStyle(trim/omp,
+           NPairTrimOmp,
+           NP_COPY | NP_TRIM | NP_OMP)
+
+// clang-format on
+#else
+
+#ifndef LMP_NPAIR_TRIM_OMP_H
+#define LMP_NPAIR_TRIM_OMP_H
+
+#include "npair.h"
+
+namespace LAMMPS_NS {
+
+class NPairTrimOmp : public NPair {
+ public:
+  NPairTrimOmp(class LAMMPS *);
+  void build(class NeighList *) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/OPENMP/npair_half_bin_atomonly_newton_omp.cpp ../lammps-stable_2Aug2023/src/OPENMP/npair_half_bin_atomonly_newton_omp.cpp
--- lammps-stable_2Aug2023/src/OPENMP/npair_half_bin_atomonly_newton_omp.cpp	2023-08-03 11:33:14.000000000 -0400
+++ ../lammps-stable_2Aug2023/src/OPENMP/npair_half_bin_atomonly_newton_omp.cpp	2023-09-21 22:43:16.122027000 -0400
@@ -22,6 +22,10 @@
 
 #include "omp_compat.h"
 
+#if defined APPEKG
+#include "appekg.h"
+#endif
+
 using namespace LAMMPS_NS;
 
 /* ---------------------------------------------------------------------- */
@@ -64,7 +68,9 @@
   ipage.reset();
 
   for (i = ifrom; i < ito; i++) {
-
+#if defined APPEKG
+     EKG_BEGIN_HEARTBEAT(1,65100);
+#endif
     n = 0;
     neighptr = ipage.vget();
 
@@ -120,6 +126,9 @@
     ipage.vgot(n);
     if (ipage.status())
       error->one(FLERR,"Neighbor list overflow, boost neigh_modify one");
+#if defined APPEKG
+    EKG_END_HEARTBEAT(1);
+#endif  
   }
   NPAIR_OMP_CLOSE;
   list->inum = nlocal;
diff -ruN lammps-stable_2Aug2023/src/OPENMP/pair_lj_cut_omp.cpp ../lammps-stable_2Aug2023/src/OPENMP/pair_lj_cut_omp.cpp
--- lammps-stable_2Aug2023/src/OPENMP/pair_lj_cut_omp.cpp	2023-08-03 11:33:14.000000000 -0400
+++ ../lammps-stable_2Aug2023/src/OPENMP/pair_lj_cut_omp.cpp	2023-09-22 00:04:14.706198000 -0400
@@ -24,6 +24,10 @@
 #include "omp_compat.h"
 using namespace LAMMPS_NS;
 
+#if defined APPEKG
+#include "appekg.h"
+#endif
+
 /* ---------------------------------------------------------------------- */
 
 PairLJCutOMP::PairLJCutOMP(LAMMPS *lmp) :
@@ -48,6 +52,9 @@
 #pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(eflag,vflag)
 #endif
   {
+#if defined APPEKG
+    EKG_BEGIN_HEARTBEAT(2,1);
+#endif
     int ifrom, ito, tid;
 
     loop_setup_thr(ifrom, ito, tid, inum, nthreads);
@@ -69,6 +76,9 @@
     }
     thr->timer(Timer::PAIR);
     reduce_thr(this, eflag, vflag, thr);
+#if defined APPEKG
+  EKG_END_HEARTBEAT(2);
+#endif  
   } // end of omp parallel region
 }
 
diff -ruN lammps-stable_2Aug2023/src/pair_born_omp.cpp ../lammps-stable_2Aug2023/src/pair_born_omp.cpp
--- lammps-stable_2Aug2023/src/pair_born_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_born_omp.cpp	2023-09-26 15:27:27.605613000 -0400
@@ -0,0 +1,163 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   This software is distributed under the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "pair_born_omp.h"
+#include <cmath>
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "neigh_list.h"
+
+
+#include "suffix.h"
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+PairBornOMP::PairBornOMP(LAMMPS *lmp) :
+  PairBorn(lmp), ThrOMP(lmp, THR_PAIR)
+{
+  suffix_flag |= Suffix::OMP;
+  respa_enable = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairBornOMP::compute(int eflag, int vflag)
+{
+  ev_init(eflag,vflag);
+
+  const int nall = atom->nlocal + atom->nghost;
+  const int nthreads = comm->nthreads;
+  const int inum = list->inum;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(eflag,vflag)
+#endif
+  {
+    int ifrom, ito, tid;
+
+    loop_setup_thr(ifrom, ito, tid, inum, nthreads);
+    ThrData *thr = fix->get_thr(tid);
+    thr->timer(Timer::START);
+    ev_setup_thr(eflag, vflag, nall, eatom, vatom, nullptr, thr);
+
+    if (evflag) {
+      if (eflag) {
+        if (force->newton_pair) eval<1,1,1>(ifrom, ito, thr);
+        else eval<1,1,0>(ifrom, ito, thr);
+      } else {
+        if (force->newton_pair) eval<1,0,1>(ifrom, ito, thr);
+        else eval<1,0,0>(ifrom, ito, thr);
+      }
+    } else {
+      if (force->newton_pair) eval<0,0,1>(ifrom, ito, thr);
+      else eval<0,0,0>(ifrom, ito, thr);
+    }
+
+    thr->timer(Timer::PAIR);
+    reduce_thr(this, eflag, vflag, thr);
+  } // end of omp parallel region
+}
+
+template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+void PairBornOMP::eval(int iifrom, int iito, ThrData * const thr)
+{
+  int i,j,ii,jj,jnum,itype,jtype;
+  double xtmp,ytmp,ztmp,delx,dely,delz,evdwl,fpair;
+  double rsq,r2inv,r6inv,r,rexp,forceborn,factor_lj;
+  int *ilist,*jlist,*numneigh,**firstneigh;
+
+  evdwl = 0.0;
+
+  const auto * _noalias const x = (dbl3_t *) atom->x[0];
+  auto * _noalias const f = (dbl3_t *) thr->get_f()[0];
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+  double *special_lj = force->special_lj;
+  double fxtmp,fytmp,fztmp;
+
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = iifrom; ii < iito; ++ii) {
+
+    i = ilist[ii];
+    xtmp = x[i].x;
+    ytmp = x[i].y;
+    ztmp = x[i].z;
+    itype = type[i];
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+    fxtmp=fytmp=fztmp=0.0;
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_lj = special_lj[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j].x;
+      dely = ytmp - x[j].y;
+      delz = ztmp - x[j].z;
+      rsq = delx*delx + dely*dely + delz*delz;
+      jtype = type[j];
+
+      if (rsq < cutsq[itype][jtype]) {
+        r2inv = 1.0/rsq;
+        r6inv = r2inv*r2inv*r2inv;
+        r = sqrt(rsq);
+        rexp = exp((sigma[itype][jtype]-r)*rhoinv[itype][jtype]);
+        forceborn = born1[itype][jtype]*r*rexp - born2[itype][jtype]*r6inv
+          + born3[itype][jtype]*r2inv*r6inv;
+        fpair = factor_lj*forceborn*r2inv;
+
+        fxtmp += delx*fpair;
+        fytmp += dely*fpair;
+        fztmp += delz*fpair;
+        if (NEWTON_PAIR || j < nlocal) {
+          f[j].x -= delx*fpair;
+          f[j].y -= dely*fpair;
+          f[j].z -= delz*fpair;
+        }
+
+        if (EFLAG) {
+          evdwl = a[itype][jtype]*rexp - c[itype][jtype]*r6inv
+            + d[itype][jtype]*r6inv*r2inv - offset[itype][jtype];
+          evdwl *= factor_lj;
+        }
+
+        if (EVFLAG) ev_tally_thr(this, i,j,nlocal,NEWTON_PAIR,
+                                 evdwl,0.0,fpair,delx,dely,delz,thr);
+      }
+    }
+    f[i].x += fxtmp;
+    f[i].y += fytmp;
+    f[i].z += fztmp;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairBornOMP::memory_usage()
+{
+  double bytes = memory_usage_thr();
+  bytes += PairBorn::memory_usage();
+
+  return bytes;
+}
diff -ruN lammps-stable_2Aug2023/src/pair_born_omp.h ../lammps-stable_2Aug2023/src/pair_born_omp.h
--- lammps-stable_2Aug2023/src/pair_born_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_born_omp.h	2023-09-26 15:27:28.724713000 -0400
@@ -0,0 +1,48 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+// clang-format off
+PairStyle(born/omp,PairBornOMP);
+// clang-format on
+#else
+
+#ifndef LMP_PAIR_BORN_OMP_H
+#define LMP_PAIR_BORN_OMP_H
+
+#include "pair_born.h"
+#include "thr_omp.h"
+
+namespace LAMMPS_NS {
+
+class PairBornOMP : public PairBorn, public ThrOMP {
+
+ public:
+  PairBornOMP(class LAMMPS *);
+
+  void compute(int, int) override;
+  double memory_usage() override;
+
+ private:
+  template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+  void eval(int ifrom, int ito, ThrData *const thr);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/pair_buck_coul_cut_omp.cpp ../lammps-stable_2Aug2023/src/pair_buck_coul_cut_omp.cpp
--- lammps-stable_2Aug2023/src/pair_buck_coul_cut_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_buck_coul_cut_omp.cpp	2023-09-26 15:27:27.652816000 -0400
@@ -0,0 +1,182 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   This software is distributed under the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "pair_buck_coul_cut_omp.h"
+
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "neigh_list.h"
+#include "suffix.h"
+
+#include <cmath>
+
+#include "omp_compat.h"
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+PairBuckCoulCutOMP::PairBuckCoulCutOMP(LAMMPS *lmp) :
+  PairBuckCoulCut(lmp), ThrOMP(lmp, THR_PAIR)
+{
+  suffix_flag |= Suffix::OMP;
+  respa_enable = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairBuckCoulCutOMP::compute(int eflag, int vflag)
+{
+  ev_init(eflag,vflag);
+
+  const int nall = atom->nlocal + atom->nghost;
+  const int nthreads = comm->nthreads;
+  const int inum = list->inum;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(eflag,vflag)
+#endif
+  {
+    int ifrom, ito, tid;
+
+    loop_setup_thr(ifrom, ito, tid, inum, nthreads);
+    ThrData *thr = fix->get_thr(tid);
+    thr->timer(Timer::START);
+    ev_setup_thr(eflag, vflag, nall, eatom, vatom, nullptr, thr);
+
+    if (evflag) {
+      if (eflag) {
+        if (force->newton_pair) eval<1,1,1>(ifrom, ito, thr);
+        else eval<1,1,0>(ifrom, ito, thr);
+      } else {
+        if (force->newton_pair) eval<1,0,1>(ifrom, ito, thr);
+        else eval<1,0,0>(ifrom, ito, thr);
+      }
+    } else {
+      if (force->newton_pair) eval<0,0,1>(ifrom, ito, thr);
+      else eval<0,0,0>(ifrom, ito, thr);
+    }
+    thr->timer(Timer::PAIR);
+    reduce_thr(this, eflag, vflag, thr);
+  } // end of omp parallel region
+}
+
+/* ---------------------------------------------------------------------- */
+
+template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+void PairBuckCoulCutOMP::eval(int iifrom, int iito, ThrData * const thr)
+{
+  int i,j,ii,jj,jnum,itype,jtype;
+  double qtmp,xtmp,ytmp,ztmp,delx,dely,delz,evdwl,ecoul,fpair;
+  double rsq,r2inv,r6inv,r,rexp,forcecoul,forcebuck,factor_coul,factor_lj;
+  int *ilist,*jlist,*numneigh,**firstneigh;
+
+  evdwl = ecoul = 0.0;
+
+  const auto * _noalias const x = (dbl3_t *) atom->x[0];
+  auto * _noalias const f = (dbl3_t *) thr->get_f()[0];
+  const double * _noalias const q = atom->q;
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+  double *special_coul = force->special_coul;
+  double *special_lj = force->special_lj;
+  double qqrd2e = force->qqrd2e;
+  double fxtmp,fytmp,fztmp;
+
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = iifrom; ii < iito; ++ii) {
+
+    i = ilist[ii];
+    qtmp = q[i];
+    xtmp = x[i].x;
+    ytmp = x[i].y;
+    ztmp = x[i].z;
+    itype = type[i];
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+    fxtmp=fytmp=fztmp=0.0;
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_lj = special_lj[sbmask(j)];
+      factor_coul = special_coul[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j].x;
+      dely = ytmp - x[j].y;
+      delz = ztmp - x[j].z;
+      rsq = delx*delx + dely*dely + delz*delz;
+      jtype = type[j];
+
+      if (rsq < cutsq[itype][jtype]) {
+        r2inv = 1.0/rsq;
+        r = sqrt(rsq);
+
+        if (rsq < cut_coulsq[itype][jtype])
+          forcecoul = qqrd2e * qtmp*q[j]/r;
+        else forcecoul = 0.0;
+
+        if (rsq < cut_ljsq[itype][jtype]) {
+          r6inv = r2inv*r2inv*r2inv;
+          rexp = exp(-r*rhoinv[itype][jtype]);
+          forcebuck = buck1[itype][jtype]*r*rexp - buck2[itype][jtype]*r6inv;
+        } else forcebuck = 0.0;
+
+        fpair = (factor_coul*forcecoul + factor_lj*forcebuck)*r2inv;
+
+        fxtmp += delx*fpair;
+        fytmp += dely*fpair;
+        fztmp += delz*fpair;
+        if (NEWTON_PAIR || j < nlocal) {
+          f[j].x -= delx*fpair;
+          f[j].y -= dely*fpair;
+          f[j].z -= delz*fpair;
+        }
+
+        if (EFLAG) {
+          if (rsq < cut_coulsq[itype][jtype])
+            ecoul = factor_coul * qqrd2e * qtmp*q[j]/r;
+          else ecoul = 0.0;
+          if (rsq < cut_ljsq[itype][jtype]) {
+            evdwl = a[itype][jtype]*rexp - c[itype][jtype]*r6inv -
+              offset[itype][jtype];
+            evdwl *= factor_lj;
+          } else evdwl = 0.0;
+        }
+
+        if (EVFLAG) ev_tally_thr(this, i,j,nlocal,NEWTON_PAIR,
+                                 evdwl,ecoul,fpair,delx,dely,delz,thr);
+      }
+    }
+    f[i].x += fxtmp;
+    f[i].y += fytmp;
+    f[i].z += fztmp;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairBuckCoulCutOMP::memory_usage()
+{
+  double bytes = memory_usage_thr();
+  bytes += PairBuckCoulCut::memory_usage();
+
+  return bytes;
+}
diff -ruN lammps-stable_2Aug2023/src/pair_buck_coul_cut_omp.h ../lammps-stable_2Aug2023/src/pair_buck_coul_cut_omp.h
--- lammps-stable_2Aug2023/src/pair_buck_coul_cut_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_buck_coul_cut_omp.h	2023-09-26 15:27:28.734410000 -0400
@@ -0,0 +1,48 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+// clang-format off
+PairStyle(buck/coul/cut/omp,PairBuckCoulCutOMP);
+// clang-format on
+#else
+
+#ifndef LMP_PAIR_BUCK_COUL_CUT_OMP_H
+#define LMP_PAIR_BUCK_COUL_CUT_OMP_H
+
+#include "pair_buck_coul_cut.h"
+#include "thr_omp.h"
+
+namespace LAMMPS_NS {
+
+class PairBuckCoulCutOMP : public PairBuckCoulCut, public ThrOMP {
+
+ public:
+  PairBuckCoulCutOMP(class LAMMPS *);
+
+  void compute(int, int) override;
+  double memory_usage() override;
+
+ private:
+  template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+  void eval(int ifrom, int ito, ThrData *const thr);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/pair_buck_omp.cpp ../lammps-stable_2Aug2023/src/pair_buck_omp.cpp
--- lammps-stable_2Aug2023/src/pair_buck_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_buck_omp.cpp	2023-09-26 15:27:27.694630000 -0400
@@ -0,0 +1,165 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   This software is distributed under the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "pair_buck_omp.h"
+#include <cmath>
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "neigh_list.h"
+
+
+#include "suffix.h"
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+PairBuckOMP::PairBuckOMP(LAMMPS *lmp) :
+  PairBuck(lmp), ThrOMP(lmp, THR_PAIR)
+{
+  suffix_flag |= Suffix::OMP;
+  respa_enable = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairBuckOMP::compute(int eflag, int vflag)
+{
+  ev_init(eflag,vflag);
+
+  const int nall = atom->nlocal + atom->nghost;
+  const int nthreads = comm->nthreads;
+  const int inum = list->inum;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(eflag,vflag)
+#endif
+  {
+    int ifrom, ito, tid;
+
+    loop_setup_thr(ifrom, ito, tid, inum, nthreads);
+    ThrData *thr = fix->get_thr(tid);
+    thr->timer(Timer::START);
+    ev_setup_thr(eflag, vflag, nall, eatom, vatom, nullptr, thr);
+
+    if (evflag) {
+      if (eflag) {
+        if (force->newton_pair) eval<1,1,1>(ifrom, ito, thr);
+        else eval<1,1,0>(ifrom, ito, thr);
+      } else {
+        if (force->newton_pair) eval<1,0,1>(ifrom, ito, thr);
+        else eval<1,0,0>(ifrom, ito, thr);
+      }
+    } else {
+      if (force->newton_pair) eval<0,0,1>(ifrom, ito, thr);
+      else eval<0,0,0>(ifrom, ito, thr);
+    }
+
+    thr->timer(Timer::PAIR);
+    reduce_thr(this, eflag, vflag, thr);
+  } // end of omp parallel region
+}
+
+template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+void PairBuckOMP::eval(int iifrom, int iito, ThrData * const thr)
+{
+  int i,j,ii,jj,jnum,itype,jtype;
+  double xtmp,ytmp,ztmp,delx,dely,delz,evdwl,fpair;
+  double rsq,r2inv,r6inv,r,rexp,forcebuck,factor_lj;
+  int *ilist,*jlist,*numneigh,**firstneigh;
+
+  evdwl = 0.0;
+
+  const auto * _noalias const x = (dbl3_t *) atom->x[0];
+  auto * _noalias const f = (dbl3_t *) thr->get_f()[0];
+  int *type = atom->type;
+  int nlocal = atom->nlocal;
+  double *special_lj = force->special_lj;
+  double fxtmp,fytmp,fztmp;
+
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = iifrom; ii < iito; ++ii) {
+
+    i = ilist[ii];
+    xtmp = x[i].x;
+    ytmp = x[i].y;
+    ztmp = x[i].z;
+    itype = type[i];
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+    fxtmp=fytmp=fztmp=0.0;
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_lj = special_lj[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j].x;
+      dely = ytmp - x[j].y;
+      delz = ztmp - x[j].z;
+      rsq = delx*delx + dely*dely + delz*delz;
+      jtype = type[j];
+
+      if (rsq < cutsq[itype][jtype]) {
+        r2inv = 1.0/rsq;
+        r6inv = r2inv*r2inv*r2inv;
+        r = sqrt(rsq);
+        r2inv = 1.0/rsq;
+        r6inv = r2inv*r2inv*r2inv;
+        r = sqrt(rsq);
+        rexp = exp(-r*rhoinv[itype][jtype]);
+        forcebuck = buck1[itype][jtype]*r*rexp - buck2[itype][jtype]*r6inv;
+        fpair = factor_lj*forcebuck*r2inv;
+
+        fxtmp += delx*fpair;
+        fytmp += dely*fpair;
+        fztmp += delz*fpair;
+        if (NEWTON_PAIR || j < nlocal) {
+          f[j].x -= delx*fpair;
+          f[j].y -= dely*fpair;
+          f[j].z -= delz*fpair;
+        }
+
+        if (EFLAG) {
+          evdwl = a[itype][jtype]*rexp - c[itype][jtype]*r6inv -
+            offset[itype][jtype];
+          evdwl *= factor_lj;
+        }
+
+        if (EVFLAG) ev_tally_thr(this, i,j,nlocal,NEWTON_PAIR,
+                                 evdwl,0.0,fpair,delx,dely,delz,thr);
+      }
+    }
+    f[i].x += fxtmp;
+    f[i].y += fytmp;
+    f[i].z += fztmp;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairBuckOMP::memory_usage()
+{
+  double bytes = memory_usage_thr();
+  bytes += PairBuck::memory_usage();
+
+  return bytes;
+}
diff -ruN lammps-stable_2Aug2023/src/pair_buck_omp.h ../lammps-stable_2Aug2023/src/pair_buck_omp.h
--- lammps-stable_2Aug2023/src/pair_buck_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_buck_omp.h	2023-09-26 15:27:28.745999000 -0400
@@ -0,0 +1,48 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+// clang-format off
+PairStyle(buck/omp,PairBuckOMP);
+// clang-format on
+#else
+
+#ifndef LMP_PAIR_BUCK_OMP_H
+#define LMP_PAIR_BUCK_OMP_H
+
+#include "pair_buck.h"
+#include "thr_omp.h"
+
+namespace LAMMPS_NS {
+
+class PairBuckOMP : public PairBuck, public ThrOMP {
+
+ public:
+  PairBuckOMP(class LAMMPS *);
+
+  void compute(int, int) override;
+  double memory_usage() override;
+
+ private:
+  template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+  void eval(int ifrom, int ito, ThrData *const thr);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/pair_coul_cut_omp.cpp ../lammps-stable_2Aug2023/src/pair_coul_cut_omp.cpp
--- lammps-stable_2Aug2023/src/pair_coul_cut_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_coul_cut_omp.cpp	2023-09-26 15:27:27.721869000 -0400
@@ -0,0 +1,162 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   This software is distributed under the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "pair_coul_cut_omp.h"
+#include <cmath>
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "neigh_list.h"
+
+
+#include "suffix.h"
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+PairCoulCutOMP::PairCoulCutOMP(LAMMPS *lmp) :
+  PairCoulCut(lmp), ThrOMP(lmp, THR_PAIR)
+{
+  suffix_flag |= Suffix::OMP;
+  respa_enable = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairCoulCutOMP::compute(int eflag, int vflag)
+{
+  ev_init(eflag,vflag);
+
+  const int nall = atom->nlocal + atom->nghost;
+  const int nthreads = comm->nthreads;
+  const int inum = list->inum;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(eflag,vflag)
+#endif
+  {
+    int ifrom, ito, tid;
+
+    loop_setup_thr(ifrom, ito, tid, inum, nthreads);
+    ThrData *thr = fix->get_thr(tid);
+    thr->timer(Timer::START);
+    ev_setup_thr(eflag, vflag, nall, eatom, vatom, nullptr, thr);
+
+    if (evflag) {
+      if (eflag) {
+        if (force->newton_pair) eval<1,1,1>(ifrom, ito, thr);
+        else eval<1,1,0>(ifrom, ito, thr);
+      } else {
+        if (force->newton_pair) eval<1,0,1>(ifrom, ito, thr);
+        else eval<1,0,0>(ifrom, ito, thr);
+      }
+    } else {
+      if (force->newton_pair) eval<0,0,1>(ifrom, ito, thr);
+      else eval<0,0,0>(ifrom, ito, thr);
+    }
+
+    thr->timer(Timer::PAIR);
+    reduce_thr(this, eflag, vflag, thr);
+  } // end of omp parallel region
+}
+
+/* ---------------------------------------------------------------------- */
+
+template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+void PairCoulCutOMP::eval(int iifrom, int iito, ThrData * const thr)
+{
+  int i,j,ii,jj,jnum,itype,jtype;
+  double qtmp,xtmp,ytmp,ztmp,delx,dely,delz,ecoul,fpair;
+  double rsq,r2inv,rinv,forcecoul,factor_coul;
+  int *ilist,*jlist,*numneigh,**firstneigh;
+
+  ecoul = 0.0;
+
+  const auto * _noalias const x = (dbl3_t *) atom->x[0];
+  auto * _noalias const f = (dbl3_t *) thr->get_f()[0];
+  const double * _noalias const q = atom->q;
+  const int * _noalias const type = atom->type;
+  const int nlocal = atom->nlocal;
+  const double * _noalias const special_coul = force->special_coul;
+  const double qqrd2e = force->qqrd2e;
+  double fxtmp,fytmp,fztmp;
+
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = iifrom; ii < iito; ++ii) {
+
+    i = ilist[ii];
+    qtmp = q[i];
+    xtmp = x[i].x;
+    ytmp = x[i].y;
+    ztmp = x[i].z;
+    itype = type[i];
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+    fxtmp=fytmp=fztmp=0.0;
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_coul = special_coul[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j].x;
+      dely = ytmp - x[j].y;
+      delz = ztmp - x[j].z;
+      rsq = delx*delx + dely*dely + delz*delz;
+      jtype = type[j];
+
+      if (rsq < cutsq[itype][jtype]) {
+        r2inv = 1.0/rsq;
+        rinv = sqrt(r2inv);
+        forcecoul = qqrd2e * scale[itype][jtype] * qtmp*q[j]*rinv;
+        fpair = factor_coul*forcecoul * r2inv;
+
+        fxtmp += delx*fpair;
+        fytmp += dely*fpair;
+        fztmp += delz*fpair;
+        if (NEWTON_PAIR || j < nlocal) {
+          f[j].x -= delx*fpair;
+          f[j].y -= dely*fpair;
+          f[j].z -= delz*fpair;
+        }
+
+        if (EFLAG)
+          ecoul = factor_coul * qqrd2e * scale[itype][jtype] * qtmp*q[j]*rinv;
+
+        if (EVFLAG) ev_tally_thr(this, i,j,nlocal,NEWTON_PAIR,
+                                 0.0,ecoul,fpair,delx,dely,delz,thr);
+      }
+    }
+    f[i].x += fxtmp;
+    f[i].y += fytmp;
+    f[i].z += fztmp;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairCoulCutOMP::memory_usage()
+{
+  double bytes = memory_usage_thr();
+  bytes += PairCoulCut::memory_usage();
+
+  return bytes;
+}
diff -ruN lammps-stable_2Aug2023/src/pair_coul_cut_omp.h ../lammps-stable_2Aug2023/src/pair_coul_cut_omp.h
--- lammps-stable_2Aug2023/src/pair_coul_cut_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_coul_cut_omp.h	2023-09-26 15:27:28.767802000 -0400
@@ -0,0 +1,48 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+// clang-format off
+PairStyle(coul/cut/omp,PairCoulCutOMP);
+// clang-format on
+#else
+
+#ifndef LMP_PAIR_COUL_CUT_OMP_H
+#define LMP_PAIR_COUL_CUT_OMP_H
+
+#include "pair_coul_cut.h"
+#include "thr_omp.h"
+
+namespace LAMMPS_NS {
+
+class PairCoulCutOMP : public PairCoulCut, public ThrOMP {
+
+ public:
+  PairCoulCutOMP(class LAMMPS *);
+
+  void compute(int, int) override;
+  double memory_usage() override;
+
+ private:
+  template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+  void eval(int ifrom, int ito, ThrData *const thr);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/pair_coul_debye_omp.cpp ../lammps-stable_2Aug2023/src/pair_coul_debye_omp.cpp
--- lammps-stable_2Aug2023/src/pair_coul_debye_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_coul_debye_omp.cpp	2023-09-26 15:27:27.754454000 -0400
@@ -0,0 +1,163 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   This software is distributed under the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "pair_coul_debye_omp.h"
+#include <cmath>
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "neigh_list.h"
+
+
+#include "suffix.h"
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+PairCoulDebyeOMP::PairCoulDebyeOMP(LAMMPS *lmp) :
+  PairCoulDebye(lmp), ThrOMP(lmp, THR_PAIR)
+{
+  suffix_flag |= Suffix::OMP;
+  respa_enable = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairCoulDebyeOMP::compute(int eflag, int vflag)
+{
+  ev_init(eflag,vflag);
+
+  const int nall = atom->nlocal + atom->nghost;
+  const int nthreads = comm->nthreads;
+  const int inum = list->inum;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(eflag,vflag)
+#endif
+  {
+    int ifrom, ito, tid;
+
+    loop_setup_thr(ifrom, ito, tid, inum, nthreads);
+    ThrData *thr = fix->get_thr(tid);
+    thr->timer(Timer::START);
+    ev_setup_thr(eflag, vflag, nall, eatom, vatom, nullptr, thr);
+
+    if (evflag) {
+      if (eflag) {
+        if (force->newton_pair) eval<1,1,1>(ifrom, ito, thr);
+        else eval<1,1,0>(ifrom, ito, thr);
+      } else {
+        if (force->newton_pair) eval<1,0,1>(ifrom, ito, thr);
+        else eval<1,0,0>(ifrom, ito, thr);
+      }
+    } else {
+      if (force->newton_pair) eval<0,0,1>(ifrom, ito, thr);
+      else eval<0,0,0>(ifrom, ito, thr);
+    }
+
+    thr->timer(Timer::PAIR);
+    reduce_thr(this, eflag, vflag, thr);
+  } // end of omp parallel region
+}
+
+/* ---------------------------------------------------------------------- */
+
+template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+void PairCoulDebyeOMP::eval(int iifrom, int iito, ThrData * const thr)
+{
+  int i,j,ii,jj,jnum,itype,jtype;
+  double qtmp,xtmp,ytmp,ztmp,delx,dely,delz,ecoul,fpair;
+  double rsq,r2inv,r,rinv,forcecoul,factor_coul,screening;
+  int *ilist,*jlist,*numneigh,**firstneigh;
+
+  ecoul = 0.0;
+
+  const auto * _noalias const x = (dbl3_t *) atom->x[0];
+  auto * _noalias const f = (dbl3_t *) thr->get_f()[0];
+  const double * _noalias const q = atom->q;
+  const int * _noalias const type = atom->type;
+  const int nlocal = atom->nlocal;
+  const double * _noalias const special_coul = force->special_coul;
+  const double qqrd2e = force->qqrd2e;
+  double fxtmp,fytmp,fztmp;
+
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = iifrom; ii < iito; ++ii) {
+
+    i = ilist[ii];
+    qtmp = q[i];
+    xtmp = x[i].x;
+    ytmp = x[i].y;
+    ztmp = x[i].z;
+    itype = type[i];
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+    fxtmp=fytmp=fztmp=0.0;
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_coul = special_coul[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j].x;
+      dely = ytmp - x[j].y;
+      delz = ztmp - x[j].z;
+      rsq = delx*delx + dely*dely + delz*delz;
+      jtype = type[j];
+
+      if (rsq < cutsq[itype][jtype]) {
+        r2inv = 1.0/rsq;
+        r = sqrt(rsq);
+        rinv = 1.0/r;
+        screening = exp(-kappa*r);
+        forcecoul = qqrd2e * qtmp*q[j] * screening * (kappa + rinv);
+        fpair = factor_coul*forcecoul * r2inv;
+
+        fxtmp += delx*fpair;
+        fytmp += dely*fpair;
+        fztmp += delz*fpair;
+        if (NEWTON_PAIR || j < nlocal) {
+          f[j].x -= delx*fpair;
+          f[j].y -= dely*fpair;
+          f[j].z -= delz*fpair;
+        }
+
+        if (EFLAG)
+          ecoul = factor_coul * qqrd2e * qtmp*q[j] * rinv * screening;
+
+        if (EVFLAG) ev_tally_thr(this, i,j,nlocal,NEWTON_PAIR,
+                                 0.0,ecoul,fpair,delx,dely,delz,thr);
+      }
+    }
+    f[i].x += fxtmp;
+    f[i].y += fytmp;
+    f[i].z += fztmp;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+double PairCoulDebyeOMP::memory_usage()
+{
+  double bytes = memory_usage_thr();
+  bytes += PairCoulDebye::memory_usage();
+
+  return bytes;
+}
diff -ruN lammps-stable_2Aug2023/src/pair_coul_debye_omp.h ../lammps-stable_2Aug2023/src/pair_coul_debye_omp.h
--- lammps-stable_2Aug2023/src/pair_coul_debye_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_coul_debye_omp.h	2023-09-26 15:27:28.774575000 -0400
@@ -0,0 +1,48 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+// clang-format off
+PairStyle(coul/debye/omp,PairCoulDebyeOMP);
+// clang-format on
+#else
+
+#ifndef LMP_PAIR_COUL_DEBYE_OMP_H
+#define LMP_PAIR_COUL_DEBYE_OMP_H
+
+#include "pair_coul_debye.h"
+#include "thr_omp.h"
+
+namespace LAMMPS_NS {
+
+class PairCoulDebyeOMP : public PairCoulDebye, public ThrOMP {
+
+ public:
+  PairCoulDebyeOMP(class LAMMPS *);
+
+  void compute(int, int) override;
+  double memory_usage() override;
+
+ private:
+  template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+  void eval(int ifrom, int ito, ThrData *const thr);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/pair_coul_dsf_omp.cpp ../lammps-stable_2Aug2023/src/pair_coul_dsf_omp.cpp
--- lammps-stable_2Aug2023/src/pair_coul_dsf_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_coul_dsf_omp.cpp	2023-09-26 15:27:27.795937000 -0400
@@ -0,0 +1,183 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   This software is distributed under the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "pair_coul_dsf_omp.h"
+#include <cmath>
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "neigh_list.h"
+
+#include "suffix.h"
+#include "math_const.h"
+using namespace LAMMPS_NS;
+using namespace MathConst;
+
+#define EWALD_F   1.12837917
+#define EWALD_P   0.3275911
+#define A1        0.254829592
+#define A2       -0.284496736
+#define A3        1.421413741
+#define A4       -1.453152027
+#define A5        1.061405429
+
+/* ---------------------------------------------------------------------- */
+
+PairCoulDSFOMP::PairCoulDSFOMP(LAMMPS *lmp) :
+  PairCoulDSF(lmp), ThrOMP(lmp, THR_PAIR)
+{
+  suffix_flag |= Suffix::OMP;
+  respa_enable = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairCoulDSFOMP::compute(int eflag, int vflag)
+{
+  ev_init(eflag,vflag);
+
+  const int nall = atom->nlocal + atom->nghost;
+  const int nthreads = comm->nthreads;
+  const int inum = list->inum;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(eflag,vflag)
+#endif
+  {
+    int ifrom, ito, tid;
+
+    loop_setup_thr(ifrom, ito, tid, inum, nthreads);
+    ThrData *thr = fix->get_thr(tid);
+    thr->timer(Timer::START);
+    ev_setup_thr(eflag, vflag, nall, eatom, vatom, nullptr, thr);
+
+    if (evflag) {
+      if (eflag) {
+        if (force->newton_pair) eval<1,1,1>(ifrom, ito, thr);
+        else eval<1,1,0>(ifrom, ito, thr);
+      } else {
+        if (force->newton_pair) eval<1,0,1>(ifrom, ito, thr);
+        else eval<1,0,0>(ifrom, ito, thr);
+      }
+    } else {
+      if (force->newton_pair) eval<0,0,1>(ifrom, ito, thr);
+      else eval<0,0,0>(ifrom, ito, thr);
+    }
+
+    thr->timer(Timer::PAIR);
+    reduce_thr(this, eflag, vflag, thr);
+  } // end of omp parallel region
+}
+
+/* ---------------------------------------------------------------------- */
+
+template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+void PairCoulDSFOMP::eval(int iifrom, int iito, ThrData * const thr)
+{
+  int i,j,ii,jj,jnum;
+  double qtmp,xtmp,ytmp,ztmp,delx,dely,delz,ecoul,fpair;
+  double r,rsq,r2inv,forcecoul,factor_coul;
+  double prefactor,erfcc,erfcd,t;
+  int *ilist,*jlist,*numneigh,**firstneigh;
+
+  ecoul = 0.0;
+
+  const auto * _noalias const x = (dbl3_t *) atom->x[0];
+  auto * _noalias const f = (dbl3_t *) thr->get_f()[0];
+  const double * _noalias const q = atom->q;
+  const int nlocal = atom->nlocal;
+  const double * _noalias const special_coul = force->special_coul;
+  const double qqrd2e = force->qqrd2e;
+  double fxtmp,fytmp,fztmp;
+
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = iifrom; ii < iito; ++ii) {
+
+    i = ilist[ii];
+    qtmp = q[i];
+    xtmp = x[i].x;
+    ytmp = x[i].y;
+    ztmp = x[i].z;
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+    fxtmp=fytmp=fztmp=0.0;
+
+    if (EFLAG) {
+      double e_self = -(e_shift/2.0 + alpha/MY_PIS) * qtmp*qtmp*qqrd2e;
+      ev_tally_thr(this,i,i,nlocal,0,0.0,e_self,0.0,0.0,0.0,0.0,thr);
+    }
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_coul = special_coul[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j].x;
+      dely = ytmp - x[j].y;
+      delz = ztmp - x[j].z;
+      rsq = delx*delx + dely*dely + delz*delz;
+
+      if (rsq < cut_coulsq) {
+        r2inv = 1.0/rsq;
+
+        r = sqrt(rsq);
+        prefactor = qqrd2e*qtmp*q[j]/r;
+        erfcd = exp(-alpha*alpha*rsq);
+        t = 1.0 / (1.0 + EWALD_P*alpha*r);
+        erfcc = t * (A1+t*(A2+t*(A3+t*(A4+t*A5)))) * erfcd;
+        forcecoul = prefactor * (erfcc/r + 2.0*alpha/MY_PIS * erfcd +
+                                 r*f_shift) * r;
+        if (factor_coul < 1.0) forcecoul -= (1.0-factor_coul)*prefactor;
+        fpair = forcecoul * r2inv;
+
+        fxtmp += delx*fpair;
+        fytmp += dely*fpair;
+        fztmp += delz*fpair;
+        if (NEWTON_PAIR || j < nlocal) {
+          f[j].x -= delx*fpair;
+          f[j].y -= dely*fpair;
+          f[j].z -= delz*fpair;
+        }
+
+        if (EFLAG) {
+          ecoul = prefactor * (erfcc - r*e_shift - rsq*f_shift);
+          if (factor_coul < 1.0) ecoul -= (1.0-factor_coul)*prefactor;
+        } else ecoul = 0.0;
+
+        if (EVFLAG) ev_tally_thr(this, i,j,nlocal,NEWTON_PAIR,
+                                 0.0,ecoul,fpair,delx,dely,delz,thr);
+      }
+    }
+    f[i].x += fxtmp;
+    f[i].y += fytmp;
+    f[i].z += fztmp;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairCoulDSFOMP::memory_usage()
+{
+  double bytes = memory_usage_thr();
+  bytes += PairCoulDSF::memory_usage();
+
+  return bytes;
+}
diff -ruN lammps-stable_2Aug2023/src/pair_coul_dsf_omp.h ../lammps-stable_2Aug2023/src/pair_coul_dsf_omp.h
--- lammps-stable_2Aug2023/src/pair_coul_dsf_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_coul_dsf_omp.h	2023-09-26 15:27:28.781023000 -0400
@@ -0,0 +1,48 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+// clang-format off
+PairStyle(coul/dsf/omp,PairCoulDSFOMP);
+// clang-format on
+#else
+
+#ifndef LMP_PAIR_COUL_DSF_OMP_H
+#define LMP_PAIR_COUL_DSF_OMP_H
+
+#include "pair_coul_dsf.h"
+#include "thr_omp.h"
+
+namespace LAMMPS_NS {
+
+class PairCoulDSFOMP : public PairCoulDSF, public ThrOMP {
+
+ public:
+  PairCoulDSFOMP(class LAMMPS *);
+
+  void compute(int, int) override;
+  double memory_usage() override;
+
+ private:
+  template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+  void eval(int ifrom, int ito, ThrData *const thr);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/pair_coul_wolf_omp.cpp ../lammps-stable_2Aug2023/src/pair_coul_wolf_omp.cpp
--- lammps-stable_2Aug2023/src/pair_coul_wolf_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_coul_wolf_omp.cpp	2023-09-26 15:27:27.813647000 -0400
@@ -0,0 +1,184 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   This software is distributed under the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "omp_compat.h"
+#include "pair_coul_wolf_omp.h"
+#include <cmath>
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "neigh_list.h"
+#include "math_const.h"
+
+
+#include "suffix.h"
+using namespace LAMMPS_NS;
+using namespace MathConst;
+
+/* ---------------------------------------------------------------------- */
+
+PairCoulWolfOMP::PairCoulWolfOMP(LAMMPS *lmp) :
+  PairCoulWolf(lmp), ThrOMP(lmp, THR_PAIR)
+{
+  suffix_flag |= Suffix::OMP;
+  respa_enable = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairCoulWolfOMP::compute(int eflag, int vflag)
+{
+  ev_init(eflag,vflag);
+
+  const int nall = atom->nlocal + atom->nghost;
+  const int nthreads = comm->nthreads;
+  const int inum = list->inum;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(eflag,vflag)
+#endif
+  {
+    int ifrom, ito, tid;
+
+    loop_setup_thr(ifrom, ito, tid, inum, nthreads);
+    ThrData *thr = fix->get_thr(tid);
+    thr->timer(Timer::START);
+    ev_setup_thr(eflag, vflag, nall, eatom, vatom, nullptr, thr);
+
+    if (evflag) {
+      if (eflag) {
+        if (force->newton_pair) eval<1,1,1>(ifrom, ito, thr);
+        else eval<1,1,0>(ifrom, ito, thr);
+      } else {
+        if (force->newton_pair) eval<1,0,1>(ifrom, ito, thr);
+        else eval<1,0,0>(ifrom, ito, thr);
+      }
+    } else {
+      if (force->newton_pair) eval<0,0,1>(ifrom, ito, thr);
+      else eval<0,0,0>(ifrom, ito, thr);
+    }
+
+    thr->timer(Timer::PAIR);
+    reduce_thr(this, eflag, vflag, thr);
+  } // end of omp parallel region
+}
+
+/* ---------------------------------------------------------------------- */
+
+template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+void PairCoulWolfOMP::eval(int iifrom, int iito, ThrData * const thr)
+{
+  int i,j,ii,jj,jnum;
+  double qtmp,xtmp,ytmp,ztmp,delx,dely,delz,ecoul,fpair;
+  double rsq,forcecoul,factor_coul;
+  double prefactor;
+  double r;
+  int *ilist,*jlist,*numneigh,**firstneigh;
+  double erfcc,erfcd,v_sh,dvdrr,e_self,e_shift,f_shift,qisq;
+
+  ecoul = 0.0;
+
+  const auto * _noalias const x = (dbl3_t *) atom->x[0];
+  auto * _noalias const f = (dbl3_t *) thr->get_f()[0];
+  const double * _noalias const q = atom->q;
+  const int nlocal = atom->nlocal;
+  const double * _noalias const special_coul = force->special_coul;
+  const double qqrd2e = force->qqrd2e;
+  double fxtmp,fytmp,fztmp;
+
+  // self and shifted coulombic energy
+
+  e_self = v_sh = 0.0;
+  e_shift = erfc(alf*cut_coul)/cut_coul;
+  f_shift = -(e_shift+ 2.0*alf/MY_PIS * exp(-alf*alf*cut_coul*cut_coul)) /
+    cut_coul;
+
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = iifrom; ii < iito; ++ii) {
+
+    i = ilist[ii];
+    qtmp = q[i];
+    xtmp = x[i].x;
+    ytmp = x[i].y;
+    ztmp = x[i].z;
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+    fxtmp=fytmp=fztmp=0.0;
+
+    qisq = qtmp*qtmp;
+    e_self = -(e_shift/2.0 + alf/MY_PIS) * qisq*qqrd2e;
+    if (EVFLAG) ev_tally_thr(this,i,i,nlocal,0,0.0,e_self,0.0,0.0,0.0,0.0,thr);
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_coul = special_coul[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j].x;
+      dely = ytmp - x[j].y;
+      delz = ztmp - x[j].z;
+      rsq = delx*delx + dely*dely + delz*delz;
+
+      if (rsq < cut_coulsq) {
+        r = sqrt(rsq);
+        prefactor = qqrd2e*qtmp*q[j]/r;
+        erfcc = erfc(alf*r);
+        erfcd = exp(-alf*alf*r*r);
+        v_sh = (erfcc - e_shift*r) * prefactor;
+        dvdrr = (erfcc/rsq + 2.0*alf/MY_PIS * erfcd/r) + f_shift;
+        forcecoul = dvdrr*rsq*prefactor;
+        if (factor_coul < 1.0) forcecoul -= (1.0-factor_coul)*prefactor;
+        fpair = forcecoul / rsq;
+
+        fxtmp += delx*fpair;
+        fytmp += dely*fpair;
+        fztmp += delz*fpair;
+        if (NEWTON_PAIR || j < nlocal) {
+          f[j].x -= delx*fpair;
+          f[j].y -= dely*fpair;
+          f[j].z -= delz*fpair;
+        }
+
+        if (EFLAG) {
+          if (rsq < cut_coulsq) {
+            ecoul = v_sh;
+            if (factor_coul < 1.0) ecoul -= (1.0-factor_coul)*prefactor;
+          } else ecoul = 0.0;
+        }
+
+        if (EVFLAG) ev_tally_thr(this, i,j,nlocal,NEWTON_PAIR,
+                                 0.0,ecoul,fpair,delx,dely,delz,thr);
+      }
+    }
+    f[i].x += fxtmp;
+    f[i].y += fytmp;
+    f[i].z += fztmp;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairCoulWolfOMP::memory_usage()
+{
+  double bytes = memory_usage_thr();
+  bytes += PairCoulWolf::memory_usage();
+
+  return bytes;
+}
diff -ruN lammps-stable_2Aug2023/src/pair_coul_wolf_omp.h ../lammps-stable_2Aug2023/src/pair_coul_wolf_omp.h
--- lammps-stable_2Aug2023/src/pair_coul_wolf_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_coul_wolf_omp.h	2023-09-26 15:27:28.792180000 -0400
@@ -0,0 +1,48 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+// clang-format off
+PairStyle(coul/wolf/omp,PairCoulWolfOMP);
+// clang-format on
+#else
+
+#ifndef LMP_PAIR_COUL_WOLF_OMP_H
+#define LMP_PAIR_COUL_WOLF_OMP_H
+
+#include "pair_coul_wolf.h"
+#include "thr_omp.h"
+
+namespace LAMMPS_NS {
+
+class PairCoulWolfOMP : public PairCoulWolf, public ThrOMP {
+
+ public:
+  PairCoulWolfOMP(class LAMMPS *);
+
+  void compute(int, int) override;
+  double memory_usage() override;
+
+ private:
+  template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+  void eval(int ifrom, int ito, ThrData *const thr);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/pair_lj_cut_coul_cut_omp.cpp ../lammps-stable_2Aug2023/src/pair_lj_cut_coul_cut_omp.cpp
--- lammps-stable_2Aug2023/src/pair_lj_cut_coul_cut_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_lj_cut_coul_cut_omp.cpp	2023-09-26 15:27:27.907389000 -0400
@@ -0,0 +1,184 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   This software is distributed under the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "pair_lj_cut_coul_cut_omp.h"
+
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "neigh_list.h"
+#include "suffix.h"
+
+#include <cmath>
+
+#include "omp_compat.h"
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+PairLJCutCoulCutOMP::PairLJCutCoulCutOMP(LAMMPS *lmp) :
+  PairLJCutCoulCut(lmp), ThrOMP(lmp, THR_PAIR)
+{
+  suffix_flag |= Suffix::OMP;
+  respa_enable = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairLJCutCoulCutOMP::compute(int eflag, int vflag)
+{
+  ev_init(eflag,vflag);
+
+  const int nall = atom->nlocal + atom->nghost;
+  const int nthreads = comm->nthreads;
+  const int inum = list->inum;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(eflag,vflag)
+#endif
+  {
+    int ifrom, ito, tid;
+
+    loop_setup_thr(ifrom, ito, tid, inum, nthreads);
+    ThrData *thr = fix->get_thr(tid);
+    thr->timer(Timer::START);
+    ev_setup_thr(eflag, vflag, nall, eatom, vatom, nullptr, thr);
+
+    if (evflag) {
+      if (eflag) {
+        if (force->newton_pair) eval<1,1,1>(ifrom, ito, thr);
+        else eval<1,1,0>(ifrom, ito, thr);
+      } else {
+        if (force->newton_pair) eval<1,0,1>(ifrom, ito, thr);
+        else eval<1,0,0>(ifrom, ito, thr);
+      }
+    } else {
+      if (force->newton_pair) eval<0,0,1>(ifrom, ito, thr);
+      else eval<0,0,0>(ifrom, ito, thr);
+    }
+
+    thr->timer(Timer::PAIR);
+    reduce_thr(this, eflag, vflag, thr);
+  } // end of omp parallel region
+}
+
+/* ---------------------------------------------------------------------- */
+
+template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+void PairLJCutCoulCutOMP::eval(int iifrom, int iito, ThrData * const thr)
+{
+  int i,j,ii,jj,jnum,itype,jtype;
+  double qtmp,xtmp,ytmp,ztmp,delx,dely,delz,evdwl,ecoul,fpair;
+  double rsq,rinv,r2inv,r6inv,forcecoul,forcelj,factor_coul,factor_lj;
+  int *ilist,*jlist,*numneigh,**firstneigh;
+
+  evdwl = ecoul = 0.0;
+
+  const auto * _noalias const x = (dbl3_t *) atom->x[0];
+  auto * _noalias const f = (dbl3_t *) thr->get_f()[0];
+  const double * _noalias const q = atom->q;
+  const int * _noalias const type = atom->type;
+  const int nlocal = atom->nlocal;
+  const double * _noalias const special_coul = force->special_coul;
+  const double * _noalias const special_lj = force->special_lj;
+  const double qqrd2e = force->qqrd2e;
+  double fxtmp,fytmp,fztmp;
+
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = iifrom; ii < iito; ++ii) {
+
+    i = ilist[ii];
+    qtmp = q[i];
+    xtmp = x[i].x;
+    ytmp = x[i].y;
+    ztmp = x[i].z;
+    itype = type[i];
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+    fxtmp=fytmp=fztmp=0.0;
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_lj = special_lj[sbmask(j)];
+      factor_coul = special_coul[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j].x;
+      dely = ytmp - x[j].y;
+      delz = ztmp - x[j].z;
+      rsq = delx*delx + dely*dely + delz*delz;
+      jtype = type[j];
+
+      if (rsq < cutsq[itype][jtype]) {
+        r2inv = 1.0/rsq;
+
+        if (rsq < cut_coulsq[itype][jtype]) {
+          rinv = sqrt(r2inv);
+          forcecoul = qqrd2e * qtmp*q[j]*rinv;
+          forcecoul *= factor_coul;
+        } else forcecoul = 0.0;
+
+        if (rsq < cut_ljsq[itype][jtype]) {
+          r6inv = r2inv*r2inv*r2inv;
+          forcelj = r6inv * (lj1[itype][jtype]*r6inv - lj2[itype][jtype]);
+          forcelj *= factor_lj;
+        } else forcelj = 0.0;
+
+        fpair = (forcecoul + forcelj) * r2inv;
+
+        fxtmp += delx*fpair;
+        fytmp += dely*fpair;
+        fztmp += delz*fpair;
+        if (NEWTON_PAIR || j < nlocal) {
+          f[j].x -= delx*fpair;
+          f[j].y -= dely*fpair;
+          f[j].z -= delz*fpair;
+        }
+
+        if (EFLAG) {
+          if (rsq < cut_coulsq[itype][jtype])
+            ecoul = factor_coul * qqrd2e * qtmp*q[j]*rinv;
+          else ecoul = 0.0;
+          if (rsq < cut_ljsq[itype][jtype]) {
+            evdwl = r6inv*(lj3[itype][jtype]*r6inv-lj4[itype][jtype]) -
+              offset[itype][jtype];
+            evdwl *= factor_lj;
+          } else evdwl = 0.0;
+        }
+
+        if (EVFLAG) ev_tally_thr(this, i,j,nlocal,NEWTON_PAIR,
+                                 evdwl,ecoul,fpair,delx,dely,delz,thr);
+      }
+    }
+    f[i].x += fxtmp;
+    f[i].y += fytmp;
+    f[i].z += fztmp;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairLJCutCoulCutOMP::memory_usage()
+{
+  double bytes = memory_usage_thr();
+  bytes += PairLJCutCoulCut::memory_usage();
+
+  return bytes;
+}
diff -ruN lammps-stable_2Aug2023/src/pair_lj_cut_coul_cut_omp.h ../lammps-stable_2Aug2023/src/pair_lj_cut_coul_cut_omp.h
--- lammps-stable_2Aug2023/src/pair_lj_cut_coul_cut_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_lj_cut_coul_cut_omp.h	2023-09-26 15:27:28.870470000 -0400
@@ -0,0 +1,48 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+// clang-format off
+PairStyle(lj/cut/coul/cut/omp,PairLJCutCoulCutOMP);
+// clang-format on
+#else
+
+#ifndef LMP_PAIR_LJ_CUT_COUL_CUT_OMP_H
+#define LMP_PAIR_LJ_CUT_COUL_CUT_OMP_H
+
+#include "pair_lj_cut_coul_cut.h"
+#include "thr_omp.h"
+
+namespace LAMMPS_NS {
+
+class PairLJCutCoulCutOMP : public PairLJCutCoulCut, public ThrOMP {
+
+ public:
+  PairLJCutCoulCutOMP(class LAMMPS *);
+
+  void compute(int, int) override;
+  double memory_usage() override;
+
+ private:
+  template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+  void eval(int ifrom, int ito, ThrData *const thr);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/pair_lj_cut.cpp ../lammps-stable_2Aug2023/src/pair_lj_cut.cpp
--- lammps-stable_2Aug2023/src/pair_lj_cut.cpp	2023-08-03 11:33:14.000000000 -0400
+++ ../lammps-stable_2Aug2023/src/pair_lj_cut.cpp	2023-11-29 18:15:36.216844576 -0500
@@ -31,6 +31,7 @@
 #include <cmath>
 #include <cstring>
 
+
 using namespace LAMMPS_NS;
 using namespace MathConst;
 
diff -ruN lammps-stable_2Aug2023/src/pair_lj_cut_omp.cpp ../lammps-stable_2Aug2023/src/pair_lj_cut_omp.cpp
--- lammps-stable_2Aug2023/src/pair_lj_cut_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_lj_cut_omp.cpp	2023-11-29 18:33:34.988147000 -0500
@@ -0,0 +1,174 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   This software is distributed under the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "pair_lj_cut_omp.h"
+
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "neigh_list.h"
+#include "suffix.h"
+
+#include "omp_compat.h"
+using namespace LAMMPS_NS;
+
+#if defined APPEKG
+#include "appekg.h"
+#endif
+
+/* ---------------------------------------------------------------------- */
+
+PairLJCutOMP::PairLJCutOMP(LAMMPS *lmp) :
+  PairLJCut(lmp), ThrOMP(lmp, THR_PAIR)
+{
+  suffix_flag |= Suffix::OMP;
+  respa_enable = 0;
+  cut_respa = nullptr;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairLJCutOMP::compute(int eflag, int vflag)
+{
+  ev_init(eflag,vflag);
+
+  const int nall = atom->nlocal + atom->nghost;
+  const int nthreads = comm->nthreads;
+  const int inum = list->inum;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(eflag,vflag)
+#endif
+  {
+    int ifrom, ito, tid;
+
+    loop_setup_thr(ifrom, ito, tid, inum, nthreads);
+    ThrData *thr = fix->get_thr(tid);
+    thr->timer(Timer::START);
+    ev_setup_thr(eflag, vflag, nall, eatom, vatom, nullptr, thr);
+
+    if (evflag) {
+      if (eflag) {
+        if (force->newton_pair) eval<1,1,1>(ifrom, ito, thr);
+        else eval<1,1,0>(ifrom, ito, thr);
+      } else {
+        if (force->newton_pair) eval<1,0,1>(ifrom, ito, thr);
+        else eval<1,0,0>(ifrom, ito, thr);
+      }
+    } else {
+      if (force->newton_pair) eval<0,0,1>(ifrom, ito, thr);
+      else eval<0,0,0>(ifrom, ito, thr);
+    }
+    thr->timer(Timer::PAIR);
+    reduce_thr(this, eflag, vflag, thr);
+  } // end of omp parallel region
+}
+
+template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+void PairLJCutOMP::eval(int iifrom, int iito, ThrData * const thr)
+{
+  const auto * _noalias const x = (dbl3_t *) atom->x[0];
+  auto * _noalias const f = (dbl3_t *) thr->get_f()[0];
+  const int * _noalias const type = atom->type;
+  const double * _noalias const special_lj = force->special_lj;
+  const int * _noalias const ilist = list->ilist;
+  const int * _noalias const numneigh = list->numneigh;
+  const int * const * const firstneigh = list->firstneigh;
+
+  double xtmp,ytmp,ztmp,delx,dely,delz,fxtmp,fytmp,fztmp;
+  double rsq,r2inv,r6inv,forcelj,factor_lj,evdwl,fpair;
+
+  const int nlocal = atom->nlocal;
+  int j,jj,jnum,jtype;
+
+  evdwl = 0.0;
+
+  // loop over neighbors of my atoms
+
+  for (int ii = iifrom; ii < iito; ++ii) {
+    #if defined APPEKG
+    EKG_BEGIN_HEARTBEAT(2,66000);
+#endif
+
+    const int i = ilist[ii];
+    const int itype = type[i];
+    const int    * _noalias const jlist = firstneigh[i];
+    const double * _noalias const cutsqi = cutsq[itype];
+    const double * _noalias const offseti = offset[itype];
+    const double * _noalias const lj1i = lj1[itype];
+    const double * _noalias const lj2i = lj2[itype];
+    const double * _noalias const lj3i = lj3[itype];
+    const double * _noalias const lj4i = lj4[itype];
+
+    xtmp = x[i].x;
+    ytmp = x[i].y;
+    ztmp = x[i].z;
+    jnum = numneigh[i];
+    fxtmp=fytmp=fztmp=0.0;
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_lj = special_lj[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j].x;
+      dely = ytmp - x[j].y;
+      delz = ztmp - x[j].z;
+      rsq = delx*delx + dely*dely + delz*delz;
+      jtype = type[j];
+
+      if (rsq < cutsqi[jtype]) {
+        r2inv = 1.0/rsq;
+        r6inv = r2inv*r2inv*r2inv;
+        forcelj = r6inv * (lj1i[jtype]*r6inv - lj2i[jtype]);
+        fpair = factor_lj*forcelj*r2inv;
+
+        fxtmp += delx*fpair;
+        fytmp += dely*fpair;
+        fztmp += delz*fpair;
+        if (NEWTON_PAIR || j < nlocal) {
+          f[j].x -= delx*fpair;
+          f[j].y -= dely*fpair;
+          f[j].z -= delz*fpair;
+        }
+
+        if (EFLAG) {
+          evdwl = r6inv*(lj3i[jtype]*r6inv-lj4i[jtype]) - offseti[jtype];
+          evdwl *= factor_lj;
+        }
+
+        if (EVFLAG) ev_tally_thr(this,i,j,nlocal,NEWTON_PAIR,
+                                 evdwl,0.0,fpair,delx,dely,delz,thr);
+      }
+    }
+    f[i].x += fxtmp;
+    f[i].y += fytmp;
+    f[i].z += fztmp;
+  #if defined APPEKG
+  EKG_END_HEARTBEAT(2);
+#endif
+
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairLJCutOMP::memory_usage()
+{
+  double bytes = memory_usage_thr();
+  bytes += PairLJCut::memory_usage();
+
+  return bytes;
+}
diff -ruN lammps-stable_2Aug2023/src/pair_lj_cut_omp.h ../lammps-stable_2Aug2023/src/pair_lj_cut_omp.h
--- lammps-stable_2Aug2023/src/pair_lj_cut_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_lj_cut_omp.h	2023-09-26 15:27:28.897857000 -0400
@@ -0,0 +1,48 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+// clang-format off
+PairStyle(lj/cut/omp,PairLJCutOMP);
+// clang-format on
+#else
+
+#ifndef LMP_PAIR_LJ_CUT_OMP_H
+#define LMP_PAIR_LJ_CUT_OMP_H
+
+#include "pair_lj_cut.h"
+#include "thr_omp.h"
+
+namespace LAMMPS_NS {
+
+class PairLJCutOMP : public PairLJCut, public ThrOMP {
+
+ public:
+  PairLJCutOMP(class LAMMPS *);
+
+  void compute(int, int) override;
+  double memory_usage() override;
+
+ private:
+  template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+  void eval(int ifrom, int ito, ThrData *const thr);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/pair_lj_expand_omp.cpp ../lammps-stable_2Aug2023/src/pair_lj_expand_omp.cpp
--- lammps-stable_2Aug2023/src/pair_lj_expand_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_lj_expand_omp.cpp	2023-09-26 15:27:27.986270000 -0400
@@ -0,0 +1,165 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   This software is distributed under the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "pair_lj_expand_omp.h"
+
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "neigh_list.h"
+#include "suffix.h"
+
+#include <cmath>
+
+#include "omp_compat.h"
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+PairLJExpandOMP::PairLJExpandOMP(LAMMPS *lmp) :
+  PairLJExpand(lmp), ThrOMP(lmp, THR_PAIR)
+{
+  suffix_flag |= Suffix::OMP;
+  respa_enable = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairLJExpandOMP::compute(int eflag, int vflag)
+{
+  ev_init(eflag,vflag);
+
+  const int nall = atom->nlocal + atom->nghost;
+  const int nthreads = comm->nthreads;
+  const int inum = list->inum;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(eflag,vflag)
+#endif
+  {
+    int ifrom, ito, tid;
+
+    loop_setup_thr(ifrom, ito, tid, inum, nthreads);
+    ThrData *thr = fix->get_thr(tid);
+    thr->timer(Timer::START);
+    ev_setup_thr(eflag, vflag, nall, eatom, vatom, nullptr, thr);
+
+    if (evflag) {
+      if (eflag) {
+        if (force->newton_pair) eval<1,1,1>(ifrom, ito, thr);
+        else eval<1,1,0>(ifrom, ito, thr);
+      } else {
+        if (force->newton_pair) eval<1,0,1>(ifrom, ito, thr);
+        else eval<1,0,0>(ifrom, ito, thr);
+      }
+    } else {
+      if (force->newton_pair) eval<0,0,1>(ifrom, ito, thr);
+      else eval<0,0,0>(ifrom, ito, thr);
+    }
+
+    thr->timer(Timer::PAIR);
+    reduce_thr(this, eflag, vflag, thr);
+  } // end of omp parallel region
+}
+
+template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+void PairLJExpandOMP::eval(int iifrom, int iito, ThrData * const thr)
+{
+  int i,j,ii,jj,jnum,itype,jtype;
+  double xtmp,ytmp,ztmp,delx,dely,delz,evdwl,fpair;
+  double rsq,r2inv,r6inv,forcelj,factor_lj;
+  double r,rshift,rshiftsq;
+  int *ilist,*jlist,*numneigh,**firstneigh;
+
+  evdwl = 0.0;
+
+  const auto * _noalias const x = (dbl3_t *) atom->x[0];
+  auto * _noalias const f = (dbl3_t *) thr->get_f()[0];
+  const int * _noalias const type = atom->type;
+  const int nlocal = atom->nlocal;
+  const double * _noalias const special_lj = force->special_lj;
+  double fxtmp,fytmp,fztmp;
+
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = iifrom; ii < iito; ++ii) {
+
+    i = ilist[ii];
+    xtmp = x[i].x;
+    ytmp = x[i].y;
+    ztmp = x[i].z;
+    itype = type[i];
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+    fxtmp=fytmp=fztmp=0.0;
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_lj = special_lj[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j].x;
+      dely = ytmp - x[j].y;
+      delz = ztmp - x[j].z;
+      rsq = delx*delx + dely*dely + delz*delz;
+      jtype = type[j];
+
+      if (rsq < cutsq[itype][jtype]) {
+        r = sqrt(rsq);
+        rshift = r - shift[itype][jtype];
+        rshiftsq = rshift*rshift;
+        r2inv = 1.0/rshiftsq;
+        r6inv = r2inv*r2inv*r2inv;
+        forcelj = r6inv * (lj1[itype][jtype]*r6inv - lj2[itype][jtype]);
+        fpair = factor_lj*forcelj/rshift/r;
+
+        fxtmp += delx*fpair;
+        fytmp += dely*fpair;
+        fztmp += delz*fpair;
+        if (NEWTON_PAIR || j < nlocal) {
+          f[j].x -= delx*fpair;
+          f[j].y -= dely*fpair;
+          f[j].z -= delz*fpair;
+        }
+
+        if (EFLAG) {
+          evdwl = r6inv*(lj3[itype][jtype]*r6inv-lj4[itype][jtype])
+            - offset[itype][jtype];
+          evdwl *= factor_lj;
+        }
+
+        if (EVFLAG) ev_tally_thr(this,i,j,nlocal,NEWTON_PAIR,
+                                 evdwl,0.0,fpair,delx,dely,delz,thr);
+      }
+    }
+    f[i].x += fxtmp;
+    f[i].y += fytmp;
+    f[i].z += fztmp;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairLJExpandOMP::memory_usage()
+{
+  double bytes = memory_usage_thr();
+  bytes += PairLJExpand::memory_usage();
+
+  return bytes;
+}
diff -ruN lammps-stable_2Aug2023/src/pair_lj_expand_omp.h ../lammps-stable_2Aug2023/src/pair_lj_expand_omp.h
--- lammps-stable_2Aug2023/src/pair_lj_expand_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_lj_expand_omp.h	2023-09-26 15:27:28.916209000 -0400
@@ -0,0 +1,48 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+// clang-format off
+PairStyle(lj/expand/omp,PairLJExpandOMP);
+// clang-format on
+#else
+
+#ifndef LMP_PAIR_LJ_EXPAND_OMP_H
+#define LMP_PAIR_LJ_EXPAND_OMP_H
+
+#include "pair_lj_expand.h"
+#include "thr_omp.h"
+
+namespace LAMMPS_NS {
+
+class PairLJExpandOMP : public PairLJExpand, public ThrOMP {
+
+ public:
+  PairLJExpandOMP(class LAMMPS *);
+
+  void compute(int, int) override;
+  double memory_usage() override;
+
+ private:
+  template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+  void eval(int ifrom, int ito, ThrData *const thr);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/pair_morse_omp.cpp ../lammps-stable_2Aug2023/src/pair_morse_omp.cpp
--- lammps-stable_2Aug2023/src/pair_morse_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_morse_omp.cpp	2023-09-26 15:27:28.034316000 -0400
@@ -0,0 +1,161 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   This software is distributed under the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "pair_morse_omp.h"
+
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "neigh_list.h"
+#include "suffix.h"
+
+#include <cmath>
+
+#include "omp_compat.h"
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+PairMorseOMP::PairMorseOMP(LAMMPS *lmp) :
+  PairMorse(lmp), ThrOMP(lmp, THR_PAIR)
+{
+  suffix_flag |= Suffix::OMP;
+  respa_enable = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairMorseOMP::compute(int eflag, int vflag)
+{
+  ev_init(eflag,vflag);
+
+  const int nall = atom->nlocal + atom->nghost;
+  const int nthreads = comm->nthreads;
+  const int inum = list->inum;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(eflag,vflag)
+#endif
+  {
+    int ifrom, ito, tid;
+
+    loop_setup_thr(ifrom, ito, tid, inum, nthreads);
+    ThrData *thr = fix->get_thr(tid);
+    thr->timer(Timer::START);
+    ev_setup_thr(eflag, vflag, nall, eatom, vatom, nullptr, thr);
+
+    if (evflag) {
+      if (eflag) {
+        if (force->newton_pair) eval<1,1,1>(ifrom, ito, thr);
+        else eval<1,1,0>(ifrom, ito, thr);
+      } else {
+        if (force->newton_pair) eval<1,0,1>(ifrom, ito, thr);
+        else eval<1,0,0>(ifrom, ito, thr);
+      }
+    } else {
+      if (force->newton_pair) eval<0,0,1>(ifrom, ito, thr);
+      else eval<0,0,0>(ifrom, ito, thr);
+    }
+
+    thr->timer(Timer::PAIR);
+    reduce_thr(this, eflag, vflag, thr);
+  } // end of omp parallel region
+}
+
+template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+void PairMorseOMP::eval(int iifrom, int iito, ThrData * const thr)
+{
+  int i,j,ii,jj,jnum,itype,jtype;
+  double xtmp,ytmp,ztmp,delx,dely,delz,evdwl,fpair;
+  double rsq,r,dr,dexp,factor_lj;
+  int *ilist,*jlist,*numneigh,**firstneigh;
+
+  evdwl = 0.0;
+
+  const auto * _noalias const x = (dbl3_t *) atom->x[0];
+  auto * _noalias const f = (dbl3_t *) thr->get_f()[0];
+  const int * _noalias const type = atom->type;
+  const int nlocal = atom->nlocal;
+  const double * _noalias const special_lj = force->special_lj;
+  double fxtmp,fytmp,fztmp;
+
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = iifrom; ii < iito; ++ii) {
+
+    i = ilist[ii];
+    xtmp = x[i].x;
+    ytmp = x[i].y;
+    ztmp = x[i].z;
+    itype = type[i];
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+    fxtmp=fytmp=fztmp=0.0;
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_lj = special_lj[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j].x;
+      dely = ytmp - x[j].y;
+      delz = ztmp - x[j].z;
+      rsq = delx*delx + dely*dely + delz*delz;
+      jtype = type[j];
+
+      if (rsq < cutsq[itype][jtype]) {
+        r = sqrt(rsq);
+        dr = r - r0[itype][jtype];
+        dexp = exp(-alpha[itype][jtype] * dr);
+        fpair = factor_lj * morse1[itype][jtype] * (dexp*dexp - dexp) / r;
+
+        fxtmp += delx*fpair;
+        fytmp += dely*fpair;
+        fztmp += delz*fpair;
+        if (NEWTON_PAIR || j < nlocal) {
+          f[j].x -= delx*fpair;
+          f[j].y -= dely*fpair;
+          f[j].z -= delz*fpair;
+        }
+
+        if (EFLAG) {
+          evdwl = d0[itype][jtype] * (dexp*dexp - 2.0*dexp) -
+            offset[itype][jtype];
+          evdwl *= factor_lj;
+        }
+
+        if (EVFLAG) ev_tally_thr(this,i,j,nlocal,NEWTON_PAIR,
+                                 evdwl,0.0,fpair,delx,dely,delz,thr);
+      }
+    }
+    f[i].x += fxtmp;
+    f[i].y += fytmp;
+    f[i].z += fztmp;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairMorseOMP::memory_usage()
+{
+  double bytes = memory_usage_thr();
+  bytes += PairMorse::memory_usage();
+
+  return bytes;
+}
diff -ruN lammps-stable_2Aug2023/src/pair_morse_omp.h ../lammps-stable_2Aug2023/src/pair_morse_omp.h
--- lammps-stable_2Aug2023/src/pair_morse_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_morse_omp.h	2023-09-26 15:27:28.955371000 -0400
@@ -0,0 +1,48 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+// clang-format off
+PairStyle(morse/omp,PairMorseOMP);
+// clang-format on
+#else
+
+#ifndef LMP_PAIR_MORSE_OMP_H
+#define LMP_PAIR_MORSE_OMP_H
+
+#include "pair_morse.h"
+#include "thr_omp.h"
+
+namespace LAMMPS_NS {
+
+class PairMorseOMP : public PairMorse, public ThrOMP {
+
+ public:
+  PairMorseOMP(class LAMMPS *);
+
+  void compute(int, int) override;
+  double memory_usage() override;
+
+ private:
+  template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+  void eval(int ifrom, int ito, ThrData *const thr);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/pair_soft_omp.cpp ../lammps-stable_2Aug2023/src/pair_soft_omp.cpp
--- lammps-stable_2Aug2023/src/pair_soft_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_soft_omp.cpp	2023-09-26 15:27:28.070585000 -0400
@@ -0,0 +1,163 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   This software is distributed under the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "pair_soft_omp.h"
+
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "neigh_list.h"
+#include "math_const.h"
+#include "suffix.h"
+
+#include <cmath>
+
+#include "omp_compat.h"
+using namespace LAMMPS_NS;
+using namespace MathConst;
+
+#define SMALL 1.0e-4
+
+/* ---------------------------------------------------------------------- */
+
+PairSoftOMP::PairSoftOMP(LAMMPS *lmp) :
+  PairSoft(lmp), ThrOMP(lmp, THR_PAIR)
+{
+  suffix_flag |= Suffix::OMP;
+  respa_enable = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairSoftOMP::compute(int eflag, int vflag)
+{
+  ev_init(eflag,vflag);
+
+  const int nall = atom->nlocal + atom->nghost;
+  const int nthreads = comm->nthreads;
+  const int inum = list->inum;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(eflag,vflag)
+#endif
+  {
+    int ifrom, ito, tid;
+
+    loop_setup_thr(ifrom, ito, tid, inum, nthreads);
+    ThrData *thr = fix->get_thr(tid);
+    thr->timer(Timer::START);
+    ev_setup_thr(eflag, vflag, nall, eatom, vatom, nullptr, thr);
+
+    if (evflag) {
+      if (eflag) {
+        if (force->newton_pair) eval<1,1,1>(ifrom, ito, thr);
+        else eval<1,1,0>(ifrom, ito, thr);
+      } else {
+        if (force->newton_pair) eval<1,0,1>(ifrom, ito, thr);
+        else eval<1,0,0>(ifrom, ito, thr);
+      }
+    } else {
+      if (force->newton_pair) eval<0,0,1>(ifrom, ito, thr);
+      else eval<0,0,0>(ifrom, ito, thr);
+    }
+
+    thr->timer(Timer::PAIR);
+    reduce_thr(this, eflag, vflag, thr);
+  } // end of omp parallel region
+}
+
+template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+void PairSoftOMP::eval(int iifrom, int iito, ThrData * const thr)
+{
+  int i,j,ii,jj,jnum,itype,jtype;
+  double xtmp,ytmp,ztmp,delx,dely,delz,evdwl,fpair;
+  double r,rsq,arg,factor_lj;
+  int *ilist,*jlist,*numneigh,**firstneigh;
+
+  evdwl = 0.0;
+
+  const auto * _noalias const x = (dbl3_t *) atom->x[0];
+  auto * _noalias const f = (dbl3_t *) thr->get_f()[0];
+  const int * _noalias const type = atom->type;
+  const int nlocal = atom->nlocal;
+  const double * _noalias const special_lj = force->special_lj;
+  double fxtmp,fytmp,fztmp;
+
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = iifrom; ii < iito; ++ii) {
+
+    i = ilist[ii];
+    xtmp = x[i].x;
+    ytmp = x[i].y;
+    ztmp = x[i].z;
+    itype = type[i];
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+    fxtmp=fytmp=fztmp=0.0;
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_lj = special_lj[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j].x;
+      dely = ytmp - x[j].y;
+      delz = ztmp - x[j].z;
+      rsq = delx*delx + dely*dely + delz*delz;
+      jtype = type[j];
+
+      if (rsq < cutsq[itype][jtype]) {
+        r = sqrt(rsq);
+        arg = MY_PI/cut[itype][jtype];
+        if (r > SMALL) fpair = factor_lj * prefactor[itype][jtype] *
+                       sin(arg*r) * arg/r;
+        else fpair = 0.0;
+
+        fxtmp += delx*fpair;
+        fytmp += dely*fpair;
+        fztmp += delz*fpair;
+        if (NEWTON_PAIR || j < nlocal) {
+          f[j].x -= delx*fpair;
+          f[j].y -= dely*fpair;
+          f[j].z -= delz*fpair;
+        }
+
+        if (EFLAG)
+          evdwl = factor_lj * prefactor[itype][jtype] * (1.0+cos(arg*r));
+
+        if (EVFLAG) ev_tally_thr(this,i,j,nlocal,NEWTON_PAIR,
+                                 evdwl,0.0,fpair,delx,dely,delz,thr);
+      }
+    }
+    f[i].x += fxtmp;
+    f[i].y += fytmp;
+    f[i].z += fztmp;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairSoftOMP::memory_usage()
+{
+  double bytes = memory_usage_thr();
+  bytes += PairSoft::memory_usage();
+
+  return bytes;
+}
diff -ruN lammps-stable_2Aug2023/src/pair_soft_omp.h ../lammps-stable_2Aug2023/src/pair_soft_omp.h
--- lammps-stable_2Aug2023/src/pair_soft_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_soft_omp.h	2023-09-26 15:27:28.980106000 -0400
@@ -0,0 +1,48 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+// clang-format off
+PairStyle(soft/omp,PairSoftOMP);
+// clang-format on
+#else
+
+#ifndef LMP_PAIR_SOFT_OMP_H
+#define LMP_PAIR_SOFT_OMP_H
+
+#include "pair_soft.h"
+#include "thr_omp.h"
+
+namespace LAMMPS_NS {
+
+class PairSoftOMP : public PairSoft, public ThrOMP {
+
+ public:
+  PairSoftOMP(class LAMMPS *);
+
+  void compute(int, int) override;
+  double memory_usage() override;
+
+ private:
+  template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+  void eval(int ifrom, int ito, ThrData *const thr);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/pair_table_omp.cpp ../lammps-stable_2Aug2023/src/pair_table_omp.cpp
--- lammps-stable_2Aug2023/src/pair_table_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_table_omp.cpp	2023-09-26 15:27:28.085765000 -0400
@@ -0,0 +1,212 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   This software is distributed under the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "pair_table_omp.h"
+
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "neigh_list.h"
+#include "suffix.h"
+
+#include "omp_compat.h"
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+PairTableOMP::PairTableOMP(LAMMPS *lmp) :
+  PairTable(lmp), ThrOMP(lmp, THR_PAIR)
+{
+  suffix_flag |= Suffix::OMP;
+  respa_enable = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairTableOMP::compute(int eflag, int vflag)
+{
+  ev_init(eflag,vflag);
+
+  const int nall = atom->nlocal + atom->nghost;
+  const int nthreads = comm->nthreads;
+  const int inum = list->inum;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(eflag,vflag)
+#endif
+  {
+    int ifrom, ito, tid;
+
+    loop_setup_thr(ifrom, ito, tid, inum, nthreads);
+    ThrData *thr = fix->get_thr(tid);
+    thr->timer(Timer::START);
+    ev_setup_thr(eflag, vflag, nall, eatom, vatom, nullptr, thr);
+
+    if (evflag) {
+      if (eflag) {
+        if (force->newton_pair) eval<1,1,1>(ifrom, ito, thr);
+        else eval<1,1,0>(ifrom, ito, thr);
+      } else {
+        if (force->newton_pair) eval<1,0,1>(ifrom, ito, thr);
+        else eval<1,0,0>(ifrom, ito, thr);
+      }
+    } else {
+      if (force->newton_pair) eval<0,0,1>(ifrom, ito, thr);
+      else eval<0,0,0>(ifrom, ito, thr);
+    }
+
+    thr->timer(Timer::PAIR);
+    reduce_thr(this, eflag, vflag, thr);
+  } // end of omp parallel region
+}
+
+template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+void PairTableOMP::eval(int iifrom, int iito, ThrData * const thr)
+{
+  int i,j,ii,jj,jnum,itype,jtype,itable;
+  double xtmp,ytmp,ztmp,delx,dely,delz,evdwl,fpair;
+  double rsq,factor_lj,fraction,value,a,b;
+  int *ilist,*jlist,*numneigh,**firstneigh;
+  const Table *tb;
+
+  union_int_float_t rsq_lookup;
+  int tlm1 = tablength - 1;
+
+  evdwl = 0.0;
+
+  const auto * _noalias const x = (dbl3_t *) atom->x[0];
+  auto * _noalias const f = (dbl3_t *) thr->get_f()[0];
+  const int * _noalias const type = atom->type;
+  const int nlocal = atom->nlocal;
+  const int tid = thr->get_tid();
+  const double * _noalias const special_lj = force->special_lj;
+  double fxtmp,fytmp,fztmp;
+
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = iifrom; ii < iito; ++ii) {
+
+    i = ilist[ii];
+    xtmp = x[i].x;
+    ytmp = x[i].y;
+    ztmp = x[i].z;
+    itype = type[i];
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+    fxtmp=fytmp=fztmp=0.0;
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor_lj = special_lj[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j].x;
+      dely = ytmp - x[j].y;
+      delz = ztmp - x[j].z;
+      rsq = delx*delx + dely*dely + delz*delz;
+      jtype = type[j];
+
+      if (rsq < cutsq[itype][jtype]) {
+        tb = &tables[tabindex[itype][jtype]];
+
+        if (check_error_thr((rsq < tb->innersq),tid,
+                            FLERR,"Pair distance < table inner cutoff"))
+          return;
+
+        if (tabstyle == LOOKUP) {
+          itable = static_cast<int> ((rsq - tb->innersq) * tb->invdelta);
+
+          if (check_error_thr((itable >= tlm1),tid,
+                              FLERR,"Pair distance > table outer cutoff"))
+            return;
+
+          fpair = factor_lj * tb->f[itable];
+        } else if (tabstyle == LINEAR) {
+          itable = static_cast<int> ((rsq - tb->innersq) * tb->invdelta);
+
+          if (check_error_thr((itable >= tlm1),tid,
+                              FLERR,"Pair distance > table outer cutoff"))
+            return;
+
+          fraction = (rsq - tb->rsq[itable]) * tb->invdelta;
+          value = tb->f[itable] + fraction*tb->df[itable];
+          fpair = factor_lj * value;
+        } else if (tabstyle == SPLINE) {
+          itable = static_cast<int> ((rsq - tb->innersq) * tb->invdelta);
+
+          if (check_error_thr((itable >= tlm1),tid,
+                              FLERR,"Pair distance > table outer cutoff"))
+            return;
+
+          b = (rsq - tb->rsq[itable]) * tb->invdelta;
+          a = 1.0 - b;
+          value = a * tb->f[itable] + b * tb->f[itable+1] +
+            ((a*a*a-a)*tb->f2[itable] + (b*b*b-b)*tb->f2[itable+1]) *
+            tb->deltasq6;
+          fpair = factor_lj * value;
+        } else {
+          rsq_lookup.f = rsq;
+          itable = rsq_lookup.i & tb->nmask;
+          itable >>= tb->nshiftbits;
+          fraction = (rsq_lookup.f - tb->rsq[itable]) * tb->drsq[itable];
+          value = tb->f[itable] + fraction*tb->df[itable];
+          fpair = factor_lj * value;
+        }
+
+        fxtmp += delx*fpair;
+        fytmp += dely*fpair;
+        fztmp += delz*fpair;
+        if (NEWTON_PAIR || j < nlocal) {
+          f[j].x -= delx*fpair;
+          f[j].y -= dely*fpair;
+          f[j].z -= delz*fpair;
+        }
+
+        if (EFLAG) {
+          if (tabstyle == LOOKUP)
+            evdwl = tb->e[itable];
+          else if (tabstyle == LINEAR || tabstyle == BITMAP)
+            evdwl = tb->e[itable] + fraction*tb->de[itable];
+          else
+            evdwl = a * tb->e[itable] + b * tb->e[itable+1] +
+              ((a*a*a-a)*tb->e2[itable] + (b*b*b-b)*tb->e2[itable+1]) *
+              tb->deltasq6;
+          evdwl *= factor_lj;
+        }
+
+        if (EVFLAG) ev_tally_thr(this,i,j,nlocal,NEWTON_PAIR,
+                                 evdwl,0.0,fpair,delx,dely,delz,thr);
+      }
+    }
+
+    f[i].x += fxtmp;
+    f[i].y += fytmp;
+    f[i].z += fztmp;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairTableOMP::memory_usage()
+{
+  double bytes = memory_usage_thr();
+  bytes += PairTable::memory_usage();
+
+  return bytes;
+}
diff -ruN lammps-stable_2Aug2023/src/pair_table_omp.h ../lammps-stable_2Aug2023/src/pair_table_omp.h
--- lammps-stable_2Aug2023/src/pair_table_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_table_omp.h	2023-09-26 15:27:28.989257000 -0400
@@ -0,0 +1,48 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+// clang-format off
+PairStyle(table/omp,PairTableOMP);
+// clang-format on
+#else
+
+#ifndef LMP_PAIR_TABLE_OMP_H
+#define LMP_PAIR_TABLE_OMP_H
+
+#include "pair_table.h"
+#include "thr_omp.h"
+
+namespace LAMMPS_NS {
+
+class PairTableOMP : public PairTable, public ThrOMP {
+
+ public:
+  PairTableOMP(class LAMMPS *);
+
+  void compute(int, int) override;
+  double memory_usage() override;
+
+ private:
+  template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+  void eval(int ifrom, int ito, ThrData *const thr);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/pair_yukawa_omp.cpp ../lammps-stable_2Aug2023/src/pair_yukawa_omp.cpp
--- lammps-stable_2Aug2023/src/pair_yukawa_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_yukawa_omp.cpp	2023-09-26 15:27:28.139708000 -0400
@@ -0,0 +1,163 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   This software is distributed under the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "pair_yukawa_omp.h"
+
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "neigh_list.h"
+#include "suffix.h"
+
+#include <cmath>
+
+#include "omp_compat.h"
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+PairYukawaOMP::PairYukawaOMP(LAMMPS *lmp) :
+  PairYukawa(lmp), ThrOMP(lmp, THR_PAIR)
+{
+  suffix_flag |= Suffix::OMP;
+  respa_enable = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairYukawaOMP::compute(int eflag, int vflag)
+{
+  ev_init(eflag,vflag);
+
+  const int nall = atom->nlocal + atom->nghost;
+  const int nthreads = comm->nthreads;
+  const int inum = list->inum;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(eflag,vflag)
+#endif
+  {
+    int ifrom, ito, tid;
+
+    loop_setup_thr(ifrom, ito, tid, inum, nthreads);
+    ThrData *thr = fix->get_thr(tid);
+    thr->timer(Timer::START);
+    ev_setup_thr(eflag, vflag, nall, eatom, vatom, nullptr, thr);
+
+    if (evflag) {
+      if (eflag) {
+        if (force->newton_pair) eval<1,1,1>(ifrom, ito, thr);
+        else eval<1,1,0>(ifrom, ito, thr);
+      } else {
+        if (force->newton_pair) eval<1,0,1>(ifrom, ito, thr);
+        else eval<1,0,0>(ifrom, ito, thr);
+      }
+    } else {
+      if (force->newton_pair) eval<0,0,1>(ifrom, ito, thr);
+      else eval<0,0,0>(ifrom, ito, thr);
+    }
+
+    thr->timer(Timer::PAIR);
+    reduce_thr(this, eflag, vflag, thr);
+  } // end of omp parallel region
+}
+
+template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+void PairYukawaOMP::eval(int iifrom, int iito, ThrData * const thr)
+{
+  int i,j,ii,jj,jnum,itype,jtype;
+  double xtmp,ytmp,ztmp,delx,dely,delz,evdwl,fpair;
+  double rsq,r2inv,r,rinv,screening,forceyukawa,factor;
+  int *ilist,*jlist,*numneigh,**firstneigh;
+
+  evdwl = 0.0;
+
+  const auto * _noalias const x = (dbl3_t *) atom->x[0];
+  auto * _noalias const f = (dbl3_t *) thr->get_f()[0];
+  const int * _noalias const type = atom->type;
+  const int nlocal = atom->nlocal;
+  const double * _noalias const special_lj = force->special_lj;
+  double fxtmp,fytmp,fztmp;
+
+  ilist = list->ilist;
+  numneigh = list->numneigh;
+  firstneigh = list->firstneigh;
+
+  // loop over neighbors of my atoms
+
+  for (ii = iifrom; ii < iito; ++ii) {
+
+    i = ilist[ii];
+    xtmp = x[i].x;
+    ytmp = x[i].y;
+    ztmp = x[i].z;
+    itype = type[i];
+    jlist = firstneigh[i];
+    jnum = numneigh[i];
+    fxtmp=fytmp=fztmp=0.0;
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      factor = special_lj[sbmask(j)];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j].x;
+      dely = ytmp - x[j].y;
+      delz = ztmp - x[j].z;
+      rsq = delx*delx + dely*dely + delz*delz;
+      jtype = type[j];
+
+      if (rsq < cutsq[itype][jtype]) {
+        r2inv = 1.0/rsq;
+        r = sqrt(rsq);
+        rinv = 1.0/r;
+        screening = exp(-kappa*r);
+        forceyukawa = a[itype][jtype] * screening * (kappa + rinv);
+
+        fpair = factor*forceyukawa * r2inv;
+
+        fxtmp += delx*fpair;
+        fytmp += dely*fpair;
+        fztmp += delz*fpair;
+        if (NEWTON_PAIR || j < nlocal) {
+          f[j].x -= delx*fpair;
+          f[j].y -= dely*fpair;
+          f[j].z -= delz*fpair;
+        }
+
+        if (EFLAG) {
+          evdwl = a[itype][jtype] * screening * rinv - offset[itype][jtype];
+          evdwl *= factor;
+        }
+
+        if (EVFLAG) ev_tally_thr(this,i,j,nlocal,NEWTON_PAIR,
+                                 evdwl,0.0,fpair,delx,dely,delz,thr);
+      }
+    }
+    f[i].x += fxtmp;
+    f[i].y += fytmp;
+    f[i].z += fztmp;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairYukawaOMP::memory_usage()
+{
+  double bytes = memory_usage_thr();
+  bytes += PairYukawa::memory_usage();
+
+  return bytes;
+}
diff -ruN lammps-stable_2Aug2023/src/pair_yukawa_omp.h ../lammps-stable_2Aug2023/src/pair_yukawa_omp.h
--- lammps-stable_2Aug2023/src/pair_yukawa_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_yukawa_omp.h	2023-09-26 15:27:29.021353000 -0400
@@ -0,0 +1,48 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+// clang-format off
+PairStyle(yukawa/omp,PairYukawaOMP);
+// clang-format on
+#else
+
+#ifndef LMP_PAIR_YUKAWA_OMP_H
+#define LMP_PAIR_YUKAWA_OMP_H
+
+#include "pair_yukawa.h"
+#include "thr_omp.h"
+
+namespace LAMMPS_NS {
+
+class PairYukawaOMP : public PairYukawa, public ThrOMP {
+
+ public:
+  PairYukawaOMP(class LAMMPS *);
+
+  void compute(int, int) override;
+  double memory_usage() override;
+
+ private:
+  template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+  void eval(int ifrom, int ito, ThrData *const thr);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/pair_zbl_omp.cpp ../lammps-stable_2Aug2023/src/pair_zbl_omp.cpp
--- lammps-stable_2Aug2023/src/pair_zbl_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_zbl_omp.cpp	2023-09-26 15:27:28.154962000 -0400
@@ -0,0 +1,172 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   This software is distributed under the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#include "pair_zbl_omp.h"
+
+#include "atom.h"
+#include "comm.h"
+#include "force.h"
+#include "neigh_list.h"
+#include "suffix.h"
+
+#include <cmath>
+
+#include "omp_compat.h"
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+PairZBLOMP::PairZBLOMP(LAMMPS *lmp) :
+  PairZBL(lmp), ThrOMP(lmp, THR_PAIR)
+{
+  suffix_flag |= Suffix::OMP;
+  respa_enable = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void PairZBLOMP::compute(int eflag, int vflag)
+{
+  ev_init(eflag,vflag);
+
+  const int nall = atom->nlocal + atom->nghost;
+  const int nthreads = comm->nthreads;
+  const int inum = list->inum;
+
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE LMP_SHARED(eflag,vflag)
+#endif
+  {
+    int ifrom, ito, tid;
+
+    loop_setup_thr(ifrom, ito, tid, inum, nthreads);
+    ThrData *thr = fix->get_thr(tid);
+    thr->timer(Timer::START);
+    ev_setup_thr(eflag, vflag, nall, eatom, vatom, nullptr, thr);
+
+    if (evflag) {
+      if (eflag) {
+        if (force->newton_pair) eval<1,1,1>(ifrom, ito, thr);
+        else eval<1,1,0>(ifrom, ito, thr);
+      } else {
+        if (force->newton_pair) eval<1,0,1>(ifrom, ito, thr);
+        else eval<1,0,0>(ifrom, ito, thr);
+      }
+    } else {
+      if (force->newton_pair) eval<0,0,1>(ifrom, ito, thr);
+      else eval<0,0,0>(ifrom, ito, thr);
+    }
+    thr->timer(Timer::PAIR);
+    reduce_thr(this, eflag, vflag, thr);
+  } // end of omp parallel region
+}
+
+template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+void PairZBLOMP::eval(int iifrom, int iito, ThrData * const thr)
+{
+  const auto * _noalias const x = (dbl3_t *) atom->x[0];
+  auto * _noalias const f = (dbl3_t *) thr->get_f()[0];
+  const int * _noalias const type = atom->type;
+  const int * _noalias const ilist = list->ilist;
+  const int * _noalias const numneigh = list->numneigh;
+  const int * const * const firstneigh = list->firstneigh;
+
+  double xtmp,ytmp,ztmp,delx,dely,delz,fxtmp,fytmp,fztmp;
+  double rsq,t,fswitch,eswitch,evdwl,fpair;
+
+  const int nlocal = atom->nlocal;
+  int j,jj,jnum,jtype;
+
+  evdwl = 0.0;
+
+  // loop over neighbors of my atoms
+
+  for (int ii = iifrom; ii < iito; ++ii) {
+    const int i = ilist[ii];
+    const int itype = type[i];
+    const int    * _noalias const jlist = firstneigh[i];
+    const double * _noalias const sw1i = sw1[itype];
+    const double * _noalias const sw2i = sw2[itype];
+    const double * _noalias const sw3i = sw3[itype];
+    const double * _noalias const sw4i = sw4[itype];
+    const double * _noalias const sw5i = sw5[itype];
+
+    xtmp = x[i].x;
+    ytmp = x[i].y;
+    ztmp = x[i].z;
+    jnum = numneigh[i];
+    fxtmp=fytmp=fztmp=0.0;
+
+    for (jj = 0; jj < jnum; jj++) {
+      j = jlist[jj];
+      j &= NEIGHMASK;
+
+      delx = xtmp - x[j].x;
+      dely = ytmp - x[j].y;
+      delz = ztmp - x[j].z;
+      rsq = delx*delx + dely*dely + delz*delz;
+      jtype = type[j];
+
+      if (rsq < cut_globalsq) {
+        const double r = sqrt(rsq);
+        fpair = dzbldr(r, itype, jtype);
+
+        if (r > cut_inner) {
+          t = r - cut_inner;
+          fswitch = t*t *
+            (sw1i[jtype] + sw2i[jtype]*t);
+          fpair += fswitch;
+        }
+
+        fpair *= -1.0/r;
+        fxtmp += delx*fpair;
+        fytmp += dely*fpair;
+        fztmp += delz*fpair;
+
+        if (NEWTON_PAIR || j < nlocal) {
+          f[j].x -= delx*fpair;
+          f[j].y -= dely*fpair;
+          f[j].z -= delz*fpair;
+        }
+
+        if (EFLAG) {
+          evdwl = e_zbl(r, itype, jtype);
+          evdwl += sw5i[jtype];
+          if (r > cut_inner) {
+            eswitch = t*t*t *
+              (sw3i[jtype] + sw4i[jtype]*t);
+            evdwl += eswitch;
+          }
+        }
+
+        if (EVFLAG) ev_tally_thr(this,i,j,nlocal,NEWTON_PAIR,
+                                 evdwl,0.0,fpair,delx,dely,delz,thr);
+      }
+    }
+    f[i].x += fxtmp;
+    f[i].y += fytmp;
+    f[i].z += fztmp;
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double PairZBLOMP::memory_usage()
+{
+  double bytes = memory_usage_thr();
+  bytes += PairZBL::memory_usage();
+
+  return bytes;
+}
diff -ruN lammps-stable_2Aug2023/src/pair_zbl_omp.h ../lammps-stable_2Aug2023/src/pair_zbl_omp.h
--- lammps-stable_2Aug2023/src/pair_zbl_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/pair_zbl_omp.h	2023-09-26 15:27:29.025524000 -0400
@@ -0,0 +1,48 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#ifdef PAIR_CLASS
+// clang-format off
+PairStyle(zbl/omp,PairZBLOMP);
+// clang-format on
+#else
+
+#ifndef LMP_PAIR_ZBL_OMP_H
+#define LMP_PAIR_ZBL_OMP_H
+
+#include "pair_zbl.h"
+#include "thr_omp.h"
+
+namespace LAMMPS_NS {
+
+class PairZBLOMP : public PairZBL, public ThrOMP {
+
+ public:
+  PairZBLOMP(class LAMMPS *);
+
+  void compute(int, int) override;
+  double memory_usage() override;
+
+ private:
+  template <int EVFLAG, int EFLAG, int NEWTON_PAIR>
+  void eval(int ifrom, int ito, ThrData *const thr);
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/respa_omp.cpp ../lammps-stable_2Aug2023/src/respa_omp.cpp
--- lammps-stable_2Aug2023/src/respa_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/respa_omp.cpp	2023-09-26 15:27:28.204720000 -0400
@@ -0,0 +1,430 @@
+// clang-format off
+/* ----------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing authors: Mark Stevens (SNL), Paul Crozier (SNL)
+------------------------------------------------------------------------- */
+
+#include "respa_omp.h"
+
+#include "angle.h"
+#include "atom.h"
+#include "bond.h"
+#include "comm.h"
+#include "dihedral.h"
+#include "domain.h"
+#include "error.h"
+#include "force.h"
+#include "improper.h"
+#include "kspace.h"
+#include "modify.h"
+#include "neighbor.h"
+#include "output.h"
+#include "pair.h"
+#include "update.h"
+
+#include "omp_compat.h"
+#if defined(_OPENMP)
+#include <omp.h>
+#endif
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+RespaOMP::RespaOMP(LAMMPS *lmp, int narg, char **arg)
+  : Respa(lmp, narg, arg),ThrOMP(lmp, THR_INTGR)
+{
+}
+
+/* ----------------------------------------------------------------------
+   initialization before run
+------------------------------------------------------------------------- */
+
+void RespaOMP::init()
+{
+  Respa::init();
+
+  if (atom->torque)
+    error->all(FLERR,"Extended particles are not supported by respa/omp\n");
+}
+
+/* ----------------------------------------------------------------------
+   setup before run
+------------------------------------------------------------------------- */
+
+void RespaOMP::setup(int flag)
+{
+  if (comm->me == 0 && screen) {
+    std::string mesg = "Setting up r-RESPA/omp run ...\n";
+    if (flag) {
+      mesg += fmt::format("  Unit style    : {}\n", update->unit_style);
+      mesg += fmt::format("  Current step  : {}\n", update->ntimestep);
+
+      mesg += "  Time steps    :";
+      for (int ilevel = 0; ilevel < nlevels; ++ilevel)
+        mesg += fmt::format(" {}:{}", ilevel + 1, step[ilevel]);
+
+      mesg += "\n  r-RESPA fixes :";
+      for (int l = 0; l < modify->n_post_force_respa_any; ++l) {
+        Fix *f = modify->get_fix_by_index(modify->list_post_force_respa[l]);
+        if (f->respa_level >= 0)
+          mesg += fmt::format(" {}:{}[{}]", MIN(f->respa_level + 1, nlevels), f->style, f->id);
+      }
+      mesg += "\n";
+      fputs(mesg.c_str(), screen);
+      timer->print_timeout(screen);
+    }
+  }
+
+  update->setupflag = 1;
+
+  // setup domain, communication and neighboring
+  // acquire ghosts
+  // build neighbor lists
+
+  atom->setup();
+  modify->setup_pre_exchange();
+  if (triclinic) domain->x2lamda(atom->nlocal);
+  domain->pbc();
+  domain->reset_box();
+  comm->setup();
+  if (neighbor->style) neighbor->setup_bins();
+  comm->exchange();
+  if (atom->sortfreq > 0) atom->sort();
+  comm->borders();
+  if (triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
+  domain->image_check();
+  domain->box_too_small_check();
+  modify->setup_pre_neighbor();
+  neighbor->build(1);
+  modify->setup_post_neighbor();
+  neighbor->ncalls = 0;
+
+  // compute all forces
+
+  ev_set(update->ntimestep);
+
+  for (int ilevel = 0; ilevel < nlevels; ilevel++) {
+    force_clear();
+    modify->setup_pre_force_respa(vflag,ilevel);
+
+    if (nhybrid_styles > 0) {
+      set_compute_flags(ilevel);
+      force->pair->compute(eflag,vflag);
+    }
+    if (level_pair == ilevel && pair_compute_flag)
+      force->pair->compute(eflag,vflag);
+    if (level_inner == ilevel && pair_compute_flag)
+      force->pair->compute_inner();
+    if (level_middle == ilevel && pair_compute_flag)
+      force->pair->compute_middle();
+    if (level_outer == ilevel && pair_compute_flag)
+      force->pair->compute_outer(eflag,vflag);
+    if (level_bond == ilevel && force->bond)
+      force->bond->compute(eflag,vflag);
+    if (level_angle == ilevel && force->angle)
+      force->angle->compute(eflag,vflag);
+    if (level_dihedral == ilevel && force->dihedral)
+      force->dihedral->compute(eflag,vflag);
+    if (level_improper == ilevel && force->improper)
+      force->improper->compute(eflag,vflag);
+    if (level_kspace == ilevel && force->kspace) {
+      force->kspace->setup();
+      if (kspace_compute_flag) force->kspace->compute(eflag,vflag);
+    }
+
+    // reduce forces from per-thread arrays, if needed
+    if (!fix->get_reduced()) {
+      const int nall = atom->nlocal + atom->nghost;
+      const int nthreads = comm->nthreads;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE
+#endif
+      {
+#if defined(_OPENMP)
+        int tid = omp_get_thread_num();
+#else
+        int tid = 0;
+#endif
+        data_reduce_thr(atom->f[0], nall, nthreads, 3, tid);
+      }
+      fix->did_reduce();
+    }
+
+    modify->pre_reverse(eflag,vflag);
+    if (newton[ilevel]) comm->reverse_comm();
+    copy_f_flevel(ilevel);
+  }
+
+  sum_flevel_f();
+  modify->setup(vflag);
+  output->setup();
+  update->setupflag = 0;
+}
+
+/* ----------------------------------------------------------------------
+   setup without output
+   flag = 0 = just force calculation
+   flag = 1 = reneighbor and force calculation
+------------------------------------------------------------------------- */
+
+void RespaOMP::setup_minimal(int flag)
+{
+  update->setupflag = 1;
+
+  // setup domain, communication and neighboring
+  // acquire ghosts
+  // build neighbor lists
+
+  if (flag) {
+    modify->setup_pre_exchange();
+    if (triclinic) domain->x2lamda(atom->nlocal);
+    domain->pbc();
+    domain->reset_box();
+    comm->setup();
+    if (neighbor->style) neighbor->setup_bins();
+    comm->exchange();
+    comm->borders();
+    if (triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
+    domain->image_check();
+    domain->box_too_small_check();
+    modify->setup_pre_neighbor();
+    neighbor->build(1);
+    modify->setup_post_neighbor();
+    neighbor->ncalls = 0;
+  }
+
+  // compute all forces
+
+  ev_set(update->ntimestep);
+
+  for (int ilevel = 0; ilevel < nlevels; ilevel++) {
+    force_clear();
+    modify->setup_pre_force_respa(vflag,ilevel);
+
+    if (nhybrid_styles > 0) {
+      set_compute_flags(ilevel);
+      force->pair->compute(eflag,vflag);
+    }
+
+    if (level_pair == ilevel && pair_compute_flag)
+      force->pair->compute(eflag,vflag);
+    if (level_inner == ilevel && pair_compute_flag)
+      force->pair->compute_inner();
+    if (level_middle == ilevel && pair_compute_flag)
+      force->pair->compute_middle();
+    if (level_outer == ilevel && pair_compute_flag)
+      force->pair->compute_outer(eflag,vflag);
+    if (level_bond == ilevel && force->bond)
+      force->bond->compute(eflag,vflag);
+    if (level_angle == ilevel && force->angle)
+      force->angle->compute(eflag,vflag);
+    if (level_dihedral == ilevel && force->dihedral)
+      force->dihedral->compute(eflag,vflag);
+    if (level_improper == ilevel && force->improper)
+      force->improper->compute(eflag,vflag);
+    if (level_kspace == ilevel && force->kspace) {
+      force->kspace->setup();
+      if (kspace_compute_flag) force->kspace->compute(eflag,vflag);
+    }
+
+    // reduce forces from per-thread arrays, if needed
+    if (!fix->get_reduced()) {
+      const int nall = atom->nlocal + atom->nghost;
+      const int nthreads = comm->nthreads;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE
+#endif
+      {
+#if defined(_OPENMP)
+        int tid = omp_get_thread_num();
+#else
+        int tid = 0;
+#endif
+        data_reduce_thr(atom->f[0], nall, nthreads, 3, tid);
+      }
+      fix->did_reduce();
+    }
+
+    modify->pre_reverse(eflag,vflag);
+    if (newton[ilevel]) comm->reverse_comm();
+    copy_f_flevel(ilevel);
+  }
+
+  sum_flevel_f();
+  modify->setup(vflag);
+  update->setupflag = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void RespaOMP::recurse(int ilevel)
+{
+  copy_flevel_f(ilevel);
+
+  for (int iloop = 0; iloop < loop[ilevel]; iloop++) {
+
+    timer->stamp();
+    modify->initial_integrate_respa(vflag,ilevel,iloop);
+    if (modify->n_post_integrate_respa)
+      modify->post_integrate_respa(ilevel,iloop);
+    timer->stamp(Timer::MODIFY);
+
+    // at outermost level, check on rebuilding neighbor list
+    // at innermost level, communicate
+    // at middle levels, do nothing
+
+    if (ilevel == nlevels-1) {
+      int nflag = neighbor->decide();
+      if (nflag) {
+        if (modify->n_pre_exchange) {
+          timer->stamp();
+          modify->pre_exchange();
+          timer->stamp(Timer::MODIFY);
+        }
+        if (triclinic) domain->x2lamda(atom->nlocal);
+        domain->pbc();
+        if (domain->box_change) {
+          domain->reset_box();
+          comm->setup();
+          if (neighbor->style) neighbor->setup_bins();
+        }
+        timer->stamp();
+        comm->exchange();
+        if (atom->sortfreq > 0 &&
+            update->ntimestep >= atom->nextsort) atom->sort();
+        comm->borders();
+        if (triclinic) domain->lamda2x(atom->nlocal+atom->nghost);
+        timer->stamp(Timer::COMM);
+        if (modify->n_pre_neighbor) {
+          modify->pre_neighbor();
+          timer->stamp(Timer::MODIFY);
+        }
+        neighbor->build(1);
+        timer->stamp(Timer::NEIGH);
+        if (modify->n_post_neighbor) {
+          modify->post_neighbor();
+          timer->stamp(Timer::MODIFY);
+        }
+      } else if (ilevel == 0) {
+        timer->stamp();
+        comm->forward_comm();
+        timer->stamp(Timer::COMM);
+      }
+
+    } else if (ilevel == 0) {
+      timer->stamp();
+      comm->forward_comm();
+      timer->stamp(Timer::COMM);
+    }
+
+    // rRESPA recursion thru all levels
+    // this used to be before neigh list build,
+    // which prevented per-atom energy/stress being tallied correctly
+    // b/c atoms migrated to new procs between short/long force calls
+    // now they migrate at very start of rRESPA timestep, before all forces
+
+    if (ilevel) recurse(ilevel-1);
+
+    // force computations
+    // important that ordering is same as Verlet
+    // so that any order dependencies are the same
+    // when potentials are invoked at same level
+
+    force_clear();
+    if (modify->n_pre_force_respa) {
+      timer->stamp();
+      modify->pre_force_respa(vflag,ilevel,iloop);
+      timer->stamp(Timer::MODIFY);
+    }
+
+    timer->stamp();
+    if (nhybrid_styles > 0) {
+      set_compute_flags(ilevel);
+      force->pair->compute(eflag,vflag);
+      timer->stamp(Timer::PAIR);
+    }
+    if (level_pair == ilevel && pair_compute_flag) {
+      force->pair->compute(eflag,vflag);
+      timer->stamp(Timer::PAIR);
+    }
+    if (level_inner == ilevel && pair_compute_flag) {
+      force->pair->compute_inner();
+      timer->stamp(Timer::PAIR);
+    }
+    if (level_middle == ilevel && pair_compute_flag) {
+      force->pair->compute_middle();
+      timer->stamp(Timer::PAIR);
+    }
+    if (level_outer == ilevel && pair_compute_flag) {
+      force->pair->compute_outer(eflag,vflag);
+      timer->stamp(Timer::PAIR);
+    }
+    if (level_bond == ilevel && force->bond) {
+      force->bond->compute(eflag,vflag);
+      timer->stamp(Timer::BOND);
+    }
+    if (level_angle == ilevel && force->angle) {
+      force->angle->compute(eflag,vflag);
+      timer->stamp(Timer::BOND);
+    }
+    if (level_dihedral == ilevel && force->dihedral) {
+      force->dihedral->compute(eflag,vflag);
+      timer->stamp(Timer::BOND);
+    }
+    if (level_improper == ilevel && force->improper) {
+      force->improper->compute(eflag,vflag);
+      timer->stamp(Timer::BOND);
+    }
+    if (level_kspace == ilevel && kspace_compute_flag) {
+      force->kspace->compute(eflag,vflag);
+      timer->stamp(Timer::KSPACE);
+    }
+
+    // reduce forces from per-thread arrays, if needed
+    if (!fix->get_reduced()) {
+      const int nall = atom->nlocal + atom->nghost;
+      const int nthreads = comm->nthreads;
+#if defined(_OPENMP)
+#pragma omp parallel LMP_DEFAULT_NONE
+#endif
+      {
+#if defined(_OPENMP)
+        int tid = omp_get_thread_num();
+#else
+        int tid = 0;
+#endif
+        data_reduce_thr(atom->f[0], nall, nthreads, 3, tid);
+      }
+      fix->did_reduce();
+    }
+
+    if (modify->n_pre_reverse) {
+      modify->pre_reverse(eflag,vflag);
+      timer->stamp(Timer::MODIFY);
+    }
+    if (newton[ilevel]) {
+      comm->reverse_comm();
+      timer->stamp(Timer::COMM);
+    }
+    timer->stamp();
+    if (modify->n_post_force_respa_any)
+      modify->post_force_respa(vflag,ilevel,iloop);
+    modify->final_integrate_respa(ilevel,iloop);
+    timer->stamp(Timer::MODIFY);
+  }
+
+  copy_f_flevel(ilevel);
+}
diff -ruN lammps-stable_2Aug2023/src/respa_omp.h ../lammps-stable_2Aug2023/src/respa_omp.h
--- lammps-stable_2Aug2023/src/respa_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/respa_omp.h	2023-09-26 15:27:29.041292000 -0400
@@ -0,0 +1,43 @@
+/* -*- c++ -*- ----------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+#ifdef INTEGRATE_CLASS
+// clang-format off
+IntegrateStyle(respa/omp,RespaOMP);
+// clang-format on
+#else
+
+#ifndef LMP_RESPA_OMP_H
+#define LMP_RESPA_OMP_H
+
+#include "respa.h"
+#include "thr_omp.h"
+
+namespace LAMMPS_NS {
+
+class RespaOMP : public Respa, public ThrOMP {
+ public:
+  RespaOMP(class LAMMPS *, int, char **);
+
+  void init() override;
+  void setup(int) override;
+  void setup_minimal(int) override;
+
+ protected:
+  void recurse(int) override;
+};
+
+}    // namespace LAMMPS_NS
+
+#endif
+#endif
diff -ruN lammps-stable_2Aug2023/src/thr_data.cpp ../lammps-stable_2Aug2023/src/thr_data.cpp
--- lammps-stable_2Aug2023/src/thr_data.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/thr_data.cpp	2023-09-26 15:27:29.150283000 -0400
@@ -0,0 +1,367 @@
+/* -------------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+   per-thread data management for LAMMPS
+------------------------------------------------------------------------- */
+
+#include <cstdio>
+#include <cstring>
+
+#include "thr_data.h"
+
+#include "memory.h"
+#include "timer.h"
+
+using namespace LAMMPS_NS;
+
+/* ---------------------------------------------------------------------- */
+
+ThrData::ThrData(int tid, Timer *t) :
+    _f(nullptr), _torque(nullptr), _erforce(nullptr), _de(nullptr), _drho(nullptr), _mu(nullptr),
+    _lambda(nullptr), _rhoB(nullptr), _D_values(nullptr), _rho(nullptr), _fp(nullptr),
+    _rho1d(nullptr), _drho1d(nullptr), _rho1d_6(nullptr), _drho1d_6(nullptr), _tid(tid), _timer(t)
+{
+  _timer_active = 0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ThrData::check_tid(int tid)
+{
+  if (tid != _tid)
+    fprintf(stderr, "WARNING: external and internal tid mismatch %d != %d\n", tid, _tid);
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ThrData::_stamp(enum Timer::ttype flag)
+{
+  // do nothing until it gets set to 0 in ::setup()
+  if (_timer_active < 0) return;
+
+  if (flag == Timer::START) { _timer_active = 1; }
+
+  if (_timer_active) _timer->stamp(flag);
+}
+
+/* ---------------------------------------------------------------------- */
+
+double ThrData::get_time(enum Timer::ttype flag)
+{
+  if (_timer)
+    return _timer->get_wall(flag);
+  else
+    return 0.0;
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ThrData::init_force(int nall, double **f, double **torque, double *erforce, double *de,
+                         double *drho)
+{
+  eng_vdwl = eng_coul = eng_bond = eng_angle = eng_dihed = eng_imprp = eng_kspce = 0.0;
+  memset(virial_pair, 0, 6 * sizeof(double));
+  memset(virial_bond, 0, 6 * sizeof(double));
+  memset(virial_angle, 0, 6 * sizeof(double));
+  memset(virial_dihed, 0, 6 * sizeof(double));
+  memset(virial_imprp, 0, 6 * sizeof(double));
+  memset(virial_kspce, 0, 6 * sizeof(double));
+
+  eatom_pair = eatom_bond = eatom_angle = eatom_dihed = eatom_imprp = eatom_kspce = nullptr;
+  vatom_pair = vatom_bond = vatom_angle = vatom_dihed = vatom_imprp = vatom_kspce = nullptr;
+
+  if (nall >= 0 && f) {
+    _f = f + _tid * nall;
+    memset(&(_f[0][0]), 0, nall * 3 * sizeof(double));
+  } else
+    _f = nullptr;
+
+  if (nall >= 0 && torque) {
+    _torque = torque + _tid * nall;
+    memset(&(_torque[0][0]), 0, nall * 3 * sizeof(double));
+  } else
+    _torque = nullptr;
+
+  if (nall >= 0 && erforce) {
+    _erforce = erforce + _tid * nall;
+    memset(&(_erforce[0]), 0, nall * sizeof(double));
+  } else
+    _erforce = nullptr;
+
+  if (nall >= 0 && de) {
+    _de = de + _tid * nall;
+    memset(&(_de[0]), 0, nall * sizeof(double));
+  } else
+    _de = nullptr;
+
+  if (nall >= 0 && drho) {
+    _drho = drho + _tid * nall;
+    memset(&(_drho[0]), 0, nall * sizeof(double));
+  } else
+    _drho = nullptr;
+}
+
+/* ----------------------------------------------------------------------
+   set up and clear out locally managed per atom arrays
+------------------------------------------------------------------------- */
+
+void ThrData::init_eam(int nall, double *rho)
+{
+  if (nall >= 0 && rho) {
+    _rho = rho + _tid * nall;
+    memset(_rho, 0, nall * sizeof(double));
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ThrData::init_adp(int nall, double *rho, double **mu, double **lambda)
+{
+  init_eam(nall, rho);
+
+  if (nall >= 0 && mu && lambda) {
+    _mu = mu + _tid * nall;
+    _lambda = lambda + _tid * nall;
+    memset(&(_mu[0][0]), 0, nall * 3 * sizeof(double));
+    memset(&(_lambda[0][0]), 0, nall * 6 * sizeof(double));
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+void ThrData::init_eim(int nall, double *rho, double *fp)
+{
+  init_eam(nall, rho);
+
+  if (nall >= 0 && fp) {
+    _fp = fp + _tid * nall;
+    memset(_fp, 0, nall * sizeof(double));
+  }
+}
+
+/* ----------------------------------------------------------------------
+   if order > 0 : set up per thread storage for PPPM
+   if order < 0 : free per thread storage for PPPM
+------------------------------------------------------------------------- */
+#if defined(FFT_SINGLE)
+typedef float FFT_SCALAR;
+#else
+typedef double FFT_SCALAR;
+#endif
+
+void ThrData::init_pppm(int order, Memory *memory)
+{
+  FFT_SCALAR **rho1d, **drho1d;
+  if (order > 0) {
+    rho1d = static_cast<FFT_SCALAR **>(_rho1d);
+    drho1d = static_cast<FFT_SCALAR **>(_drho1d);
+    if (rho1d) memory->destroy2d_offset(rho1d, -order / 2);
+    if (drho1d) memory->destroy2d_offset(drho1d, -order / 2);
+    memory->create2d_offset(rho1d, 3, -order / 2, order / 2, "thr_data:rho1d");
+    memory->create2d_offset(drho1d, 3, -order / 2, order / 2, "thr_data:drho1d");
+    _rho1d = static_cast<void *>(rho1d);
+    _drho1d = static_cast<void *>(drho1d);
+  } else {
+    order = -order;
+    rho1d = static_cast<FFT_SCALAR **>(_rho1d);
+    drho1d = static_cast<FFT_SCALAR **>(_drho1d);
+    if (rho1d) memory->destroy2d_offset(rho1d, -order / 2);
+    if (drho1d) memory->destroy2d_offset(drho1d, -order / 2);
+    _rho1d = nullptr;
+    _drho1d = nullptr;
+  }
+}
+
+/* ----------------------------------------------------------------------
+   if order > 0 : set up per thread storage for PPPM
+   if order < 0 : free per thread storage for PPPM
+------------------------------------------------------------------------- */
+#if defined(FFT_SINGLE)
+typedef float FFT_SCALAR;
+#else
+typedef double FFT_SCALAR;
+#endif
+
+void ThrData::init_pppm_disp(int order_6, Memory *memory)
+{
+  FFT_SCALAR **rho1d_6, **drho1d_6;
+  if (order_6 > 0) {
+    rho1d_6 = static_cast<FFT_SCALAR **>(_rho1d_6);
+    drho1d_6 = static_cast<FFT_SCALAR **>(_drho1d_6);
+    if (rho1d_6) memory->destroy2d_offset(rho1d_6, -order_6 / 2);
+    if (drho1d_6) memory->destroy2d_offset(drho1d_6, -order_6 / 2);
+    memory->create2d_offset(rho1d_6, 3, -order_6 / 2, order_6 / 2, "thr_data:rho1d_6");
+    memory->create2d_offset(drho1d_6, 3, -order_6 / 2, order_6 / 2, "thr_data:drho1d_6");
+    _rho1d_6 = static_cast<void *>(rho1d_6);
+    _drho1d_6 = static_cast<void *>(drho1d_6);
+  } else {
+    order_6 = -order_6;
+    rho1d_6 = static_cast<FFT_SCALAR **>(_rho1d_6);
+    drho1d_6 = static_cast<FFT_SCALAR **>(_drho1d_6);
+    if (rho1d_6) memory->destroy2d_offset(rho1d_6, -order_6 / 2);
+    if (drho1d_6) memory->destroy2d_offset(drho1d_6, -order_6 / 2);
+  }
+}
+
+/* ----------------------------------------------------------------------
+   compute global pair virial via summing F dot r over own & ghost atoms
+   at this point, only pairwise forces have been accumulated in atom->f
+------------------------------------------------------------------------- */
+
+void ThrData::virial_fdotr_compute(double **x, int nlocal, int nghost, int nfirst)
+{
+
+  // sum over force on all particles including ghosts
+
+  if (nfirst < 0) {
+    int nall = nlocal + nghost;
+    for (int i = 0; i < nall; i++) {
+      virial_pair[0] += _f[i][0] * x[i][0];
+      virial_pair[1] += _f[i][1] * x[i][1];
+      virial_pair[2] += _f[i][2] * x[i][2];
+      virial_pair[3] += _f[i][1] * x[i][0];
+      virial_pair[4] += _f[i][2] * x[i][0];
+      virial_pair[5] += _f[i][2] * x[i][1];
+    }
+
+    // neighbor includegroup flag is set
+    // sum over force on initial nfirst particles and ghosts
+
+  } else {
+    int nall = nfirst;
+    for (int i = 0; i < nall; i++) {
+      virial_pair[0] += _f[i][0] * x[i][0];
+      virial_pair[1] += _f[i][1] * x[i][1];
+      virial_pair[2] += _f[i][2] * x[i][2];
+      virial_pair[3] += _f[i][1] * x[i][0];
+      virial_pair[4] += _f[i][2] * x[i][0];
+      virial_pair[5] += _f[i][2] * x[i][1];
+    }
+    nall = nlocal + nghost;
+    for (int i = nlocal; i < nall; i++) {
+      virial_pair[0] += _f[i][0] * x[i][0];
+      virial_pair[1] += _f[i][1] * x[i][1];
+      virial_pair[2] += _f[i][2] * x[i][2];
+      virial_pair[3] += _f[i][1] * x[i][0];
+      virial_pair[4] += _f[i][2] * x[i][0];
+      virial_pair[5] += _f[i][2] * x[i][1];
+    }
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double ThrData::memory_usage()
+{
+  double bytes = (7 + 6 * 6) * sizeof(double);
+  bytes += (double) 2 * sizeof(double *);
+  bytes += (double) 4 * sizeof(int);
+
+  return bytes;
+}
+
+/* additional helper functions */
+
+// reduce per thread data into the first part of the data
+// array that is used for the non-threaded parts and reset
+// the temporary storage to 0.0. this routine depends on
+// multi-dimensional arrays like force stored in this order
+// x1,y1,z1,x2,y2,z2,...
+// we need to post a barrier to wait until all threads are done
+// with writing to the array .
+void LAMMPS_NS::data_reduce_thr(double *dall, int nall, int nthreads, int ndim, int tid)
+{
+#if defined(_OPENMP)
+  // NOOP in single-threaded execution.
+  if (nthreads == 1) return;
+#pragma omp barrier
+  {
+    const int nvals = ndim * nall;
+    const int idelta = nvals / nthreads + 1;
+    const int ifrom = tid * idelta;
+    const int ito = ((ifrom + idelta) > nvals) ? nvals : (ifrom + idelta);
+
+#if defined(USER_OMP_NO_UNROLL)
+    if (ifrom < nvals) {
+      int m = 0;
+
+      for (m = ifrom; m < ito; ++m) {
+        for (int n = 1; n < nthreads; ++n) {
+          dall[m] += dall[n * nvals + m];
+          dall[n * nvals + m] = 0.0;
+        }
+      }
+    }
+#else
+    // this if protects against having more threads than atoms
+    if (ifrom < nvals) {
+      int m = 0;
+
+      // for architectures that have L1 D-cache line sizes of 64 bytes
+      // (8 doubles) wide, explicitly unroll this loop to  compute 8
+      // contiguous values in the array at a time
+      // -- modify this code based on the size of the cache line
+      double t0, t1, t2, t3, t4, t5, t6, t7;
+      for (m = ifrom; m < (ito - 7); m += 8) {
+        t0 = dall[m];
+        t1 = dall[m + 1];
+        t2 = dall[m + 2];
+        t3 = dall[m + 3];
+        t4 = dall[m + 4];
+        t5 = dall[m + 5];
+        t6 = dall[m + 6];
+        t7 = dall[m + 7];
+        for (int n = 1; n < nthreads; ++n) {
+          t0 += dall[n * nvals + m];
+          t1 += dall[n * nvals + m + 1];
+          t2 += dall[n * nvals + m + 2];
+          t3 += dall[n * nvals + m + 3];
+          t4 += dall[n * nvals + m + 4];
+          t5 += dall[n * nvals + m + 5];
+          t6 += dall[n * nvals + m + 6];
+          t7 += dall[n * nvals + m + 7];
+          dall[n * nvals + m] = 0.0;
+          dall[n * nvals + m + 1] = 0.0;
+          dall[n * nvals + m + 2] = 0.0;
+          dall[n * nvals + m + 3] = 0.0;
+          dall[n * nvals + m + 4] = 0.0;
+          dall[n * nvals + m + 5] = 0.0;
+          dall[n * nvals + m + 6] = 0.0;
+          dall[n * nvals + m + 7] = 0.0;
+        }
+        dall[m] = t0;
+        dall[m + 1] = t1;
+        dall[m + 2] = t2;
+        dall[m + 3] = t3;
+        dall[m + 4] = t4;
+        dall[m + 5] = t5;
+        dall[m + 6] = t6;
+        dall[m + 7] = t7;
+      }
+      // do the last < 8 values
+      for (; m < ito; m++) {
+        for (int n = 1; n < nthreads; ++n) {
+          dall[m] += dall[n * nvals + m];
+          dall[n * nvals + m] = 0.0;
+        }
+      }
+    }
+#endif
+  }
+#else
+  // NOOP in non-threaded execution.
+  return;
+#endif
+}
diff -ruN lammps-stable_2Aug2023/src/thr_data.h ../lammps-stable_2Aug2023/src/thr_data.h
--- lammps-stable_2Aug2023/src/thr_data.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/thr_data.h	2023-09-26 15:27:29.100751000 -0400
@@ -0,0 +1,158 @@
+/* -*- c++ -*- -------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#ifndef LMP_THR_DATA_H
+#define LMP_THR_DATA_H
+
+#include "timer.h"    // IWYU pragma: export
+
+namespace LAMMPS_NS {
+
+// per thread data accumulators
+// there should be one instance
+// of this class for each thread.
+class ThrData {
+  friend class FixOMP;
+  friend class ThrOMP;
+
+ public:
+  ThrData(int tid, class Timer *t);
+  ~ThrData()
+  {
+    delete _timer;
+    _timer = nullptr;
+  };
+
+  void check_tid(int);                     // thread id consistency check
+  int get_tid() const { return _tid; };    // our thread id.
+
+  // inline wrapper, to make this more efficient
+  // when per-thread timers are off
+  void timer(enum Timer::ttype flag)
+  {
+    if (_timer) _stamp(flag);
+  };
+  double get_time(enum Timer::ttype flag);
+
+  // erase accumulator contents and hook up force arrays
+  void init_force(int, double **, double **, double *, double *, double *);
+
+  // give access to per-thread offset arrays
+  double **get_f() const { return _f; };
+  double **get_torque() const { return _torque; };
+  double *get_de() const { return _de; };
+  double *get_drho() const { return _drho; };
+
+  // setup and erase per atom arrays
+  void init_adp(int, double *, double **, double **);    // ADP (+ EAM)
+  void init_eam(int, double *);                          // EAM
+  void init_eim(int, double *, double *);                // EIM (+ EAM)
+
+  void init_pppm(int, class Memory *);
+  void init_pppm_disp(int, class Memory *);
+
+  // access methods for arrays that we handle in this class
+  double **get_lambda() const { return _lambda; };
+  double **get_mu() const { return _mu; };
+  double *get_D_values() const { return _D_values; };
+  double *get_fp() const { return _fp; };
+  double *get_rho() const { return _rho; };
+  double *get_rhoB() const { return _rhoB; };
+  void *get_rho1d() const { return _rho1d; };
+  void *get_drho1d() const { return _drho1d; };
+  void *get_rho1d_6() const { return _rho1d_6; };
+  void *get_drho1d_6() const { return _drho1d_6; };
+
+ private:
+  double eng_vdwl;           // non-bonded non-coulomb energy
+  double eng_coul;           // non-bonded coulomb energy
+  double eng_bond;           // bond energy
+  double eng_angle;          // angle energy
+  double eng_dihed;          // dihedral energy
+  double eng_imprp;          // improper energy
+  double eng_kspce;          // kspace energy
+  double virial_pair[6];     // virial contribution from non-bonded
+  double virial_bond[6];     // virial contribution from bonds
+  double virial_angle[6];    // virial contribution from angles
+  double virial_dihed[6];    // virial contribution from dihedrals
+  double virial_imprp[6];    // virial contribution from impropers
+  double virial_kspce[6];    // virial contribution from kspace
+  double *eatom_pair;
+  double *eatom_bond;
+  double *eatom_angle;
+  double *eatom_dihed;
+  double *eatom_imprp;
+  double *eatom_kspce;
+  double **vatom_pair;
+  double **vatom_bond;
+  double **vatom_angle;
+  double **vatom_dihed;
+  double **vatom_imprp;
+  double **vatom_kspce;
+  double **cvatom_pair;
+  double **cvatom_angle;
+  double **cvatom_dihed;
+  double **cvatom_imprp;
+
+  // per thread segments of various force or similar arrays
+
+  // these are maintained by atom styles
+  double **_f;
+  double **_torque;
+  double *_erforce;
+  double *_de;
+  double *_drho;
+
+  // these are maintained by individual pair styles
+  double **_mu, **_lambda;      // ADP (+ EAM)
+  double *_rhoB, *_D_values;    // CDEAM (+ EAM)
+  double *_rho;                 // EAM
+  double *_fp;                  // EIM (+ EAM)
+
+  // this is for pppm/omp
+  void *_rho1d;
+  void *_drho1d;
+  // this is for pppm/disp/omp
+  void *_rho1d_6;
+  void *_drho1d_6;
+  // my thread id
+  const int _tid;
+  // timer info
+  int _timer_active;
+  class Timer *_timer;
+
+ private:
+  void _stamp(enum Timer::ttype flag);
+
+ public:
+  // compute global per thread virial contribution from global forces and positions
+  void virial_fdotr_compute(double **, int, int, int);
+
+  double memory_usage();
+
+  // disabled default methods
+ private:
+  ThrData() : _tid(-1), _timer(nullptr){};
+};
+
+////////////////////////////////////////////////////////////////////////
+//  helper functions operating on data replicated for thread support  //
+////////////////////////////////////////////////////////////////////////
+// generic per thread data reduction for continuous arrays of nthreads*nmax size
+void data_reduce_thr(double *, int, int, int, int);
+}    // namespace LAMMPS_NS
+#endif
diff -ruN lammps-stable_2Aug2023/src/thr_omp.cpp ../lammps-stable_2Aug2023/src/thr_omp.cpp
--- lammps-stable_2Aug2023/src/thr_omp.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/thr_omp.cpp	2023-09-26 15:27:29.087834000 -0400
@@ -0,0 +1,1620 @@
+/* -------------------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+   OpenMP based threading support for LAMMPS
+------------------------------------------------------------------------- */
+
+#include "thr_omp.h"
+
+#include "angle.h"
+#include "atom.h"
+#include "bond.h"
+#include "comm.h"
+#include "compute.h"
+#include "dihedral.h"
+#include "error.h"
+#include "force.h"
+#include "improper.h"
+#include "math_const.h"
+#include "modify.h"
+#include "neighbor.h"
+#include "pair.h"
+
+#include <cstring>
+
+using namespace LAMMPS_NS;
+using MathConst::THIRD;
+
+/* ---------------------------------------------------------------------- */
+
+ThrOMP::ThrOMP(LAMMPS *ptr, int style) : lmp(ptr), fix(nullptr), thr_style(style), thr_error(0)
+{
+  // register fix omp with this class
+  fix = static_cast<FixOMP *>(lmp->modify->get_fix_by_id("package_omp"));
+  if (!fix) lmp->error->all(FLERR, "The 'package omp' command is required for /omp styles");
+}
+
+// clang-format off
+/* ----------------------------------------------------------------------
+   Hook up per thread per atom arrays into the tally infrastructure
+   ---------------------------------------------------------------------- */
+
+void ThrOMP::ev_setup_thr(int eflag, int vflag, int nall, double *eatom,
+                          double **vatom, double **cvatom, ThrData *thr)
+{
+  const int tid = thr->get_tid();
+  if (tid == 0) thr_error = 0;
+
+  if (thr_style & THR_PAIR) {
+    if (eflag & ENERGY_ATOM) {
+      thr->eatom_pair = eatom + tid*nall;
+      if (nall > 0)
+        memset(&(thr->eatom_pair[0]),0,nall*sizeof(double));
+    }
+    // per-atom virial and per-atom centroid virial are the same for two-body
+    // many-body pair styles not yet implemented
+    if (vflag & (VIRIAL_ATOM | VIRIAL_CENTROID)) {
+      thr->vatom_pair = vatom + tid*nall;
+      if (nall > 0)
+        memset(&(thr->vatom_pair[0][0]),0,nall*6*sizeof(double));
+    }
+    // check cvatom_pair, because can't access centroidstressflag
+    if ((vflag & VIRIAL_CENTROID) && cvatom) {
+      thr->cvatom_pair = cvatom + tid*nall;
+      if (nall > 0)
+        memset(&(thr->cvatom_pair[0][0]),0,nall*9*sizeof(double));
+    } else {
+      thr->cvatom_pair = nullptr;
+    }
+
+  }
+
+  if (thr_style & THR_BOND) {
+    if (eflag & ENERGY_ATOM) {
+      thr->eatom_bond = eatom + tid*nall;
+      if (nall > 0)
+        memset(&(thr->eatom_bond[0]),0,nall*sizeof(double));
+    }
+    // per-atom virial and per-atom centroid virial are the same for bonds
+    if (vflag & (VIRIAL_ATOM | VIRIAL_CENTROID)) {
+      thr->vatom_bond = vatom + tid*nall;
+      if (nall > 0)
+        memset(&(thr->vatom_bond[0][0]),0,nall*6*sizeof(double));
+    }
+  }
+
+  if (thr_style & THR_ANGLE) {
+    if (eflag & ENERGY_ATOM) {
+      thr->eatom_angle = eatom + tid*nall;
+      if (nall > 0)
+        memset(&(thr->eatom_angle[0]),0,nall*sizeof(double));
+    }
+    if (vflag & VIRIAL_ATOM) {
+      thr->vatom_angle = vatom + tid*nall;
+      if (nall > 0)
+        memset(&(thr->vatom_angle[0][0]),0,nall*6*sizeof(double));
+    }
+    if (vflag & VIRIAL_CENTROID) {
+      thr->cvatom_angle = cvatom + tid*nall;
+      if (nall > 0)
+        memset(&(thr->cvatom_angle[0][0]),0,nall*9*sizeof(double));
+    }
+  }
+
+  if (thr_style & THR_DIHEDRAL) {
+    if (eflag & ENERGY_ATOM) {
+      thr->eatom_dihed = eatom + tid*nall;
+      if (nall > 0)
+        memset(&(thr->eatom_dihed[0]),0,nall*sizeof(double));
+    }
+    if (vflag & VIRIAL_ATOM) {
+      thr->vatom_dihed = vatom + tid*nall;
+      if (nall > 0)
+        memset(&(thr->vatom_dihed[0][0]),0,nall*6*sizeof(double));
+    }
+    if (vflag & VIRIAL_CENTROID) {
+      thr->cvatom_dihed = cvatom + tid*nall;
+      if (nall > 0)
+        memset(&(thr->cvatom_dihed[0][0]),0,nall*9*sizeof(double));
+    }
+  }
+
+  if (thr_style & THR_IMPROPER) {
+    if (eflag & ENERGY_ATOM) {
+      thr->eatom_imprp = eatom + tid*nall;
+      if (nall > 0)
+        memset(&(thr->eatom_imprp[0]),0,nall*sizeof(double));
+    }
+    if (vflag & VIRIAL_ATOM) {
+      thr->vatom_imprp = vatom + tid*nall;
+      if (nall > 0)
+        memset(&(thr->vatom_imprp[0][0]),0,nall*6*sizeof(double));
+    }
+    if (vflag & VIRIAL_CENTROID) {
+      thr->cvatom_imprp = cvatom + tid*nall;
+      if (nall > 0)
+        memset(&(thr->cvatom_imprp[0][0]),0,nall*9*sizeof(double));
+    }
+  }
+  // nothing to do for THR_KSPACE
+}
+
+/* ----------------------------------------------------------------------
+   Reduce per thread data into the regular structures
+   Reduction of global properties is serialized with a "critical"
+   directive, so that only one thread at a time will access the
+   global variables. Since we are not synchronized, this should
+   come with little overhead. The reduction of per-atom properties
+   in contrast is parallelized over threads in the same way as forces.
+   ---------------------------------------------------------------------- */
+
+void ThrOMP::reduce_thr(void *style, const int eflag, const int vflag,
+                        ThrData *const thr)
+{
+  const int nlocal = lmp->atom->nlocal;
+  const int nghost = lmp->atom->nghost;
+  const int nall = nlocal + nghost;
+  const int nfirst = lmp->atom->nfirst;
+  const int nthreads = lmp->comm->nthreads;
+  const int evflag = eflag | vflag;
+
+  const int tid = thr->get_tid();
+  double **f = lmp->atom->f;
+  double **x = lmp->atom->x;
+
+  int need_force_reduce = 1;
+
+  if (evflag)
+    sync_threads();
+
+  switch (thr_style) {
+
+  case THR_PAIR: {
+
+    if (lmp->force->pair->vflag_fdotr) {
+
+      // this is a non-hybrid pair style. compute per thread fdotr
+      if (fix->last_pair_hybrid == nullptr) {
+        if (lmp->neighbor->includegroup == 0)
+          thr->virial_fdotr_compute(x, nlocal, nghost, -1);
+        else
+          thr->virial_fdotr_compute(x, nlocal, nghost, nfirst);
+      } else {
+        if (style == fix->last_pair_hybrid) {
+          // pair_style hybrid will compute fdotr for us
+          // but we first need to reduce the forces
+          data_reduce_thr(&(f[0][0]), nall, nthreads, 3, tid);
+          fix->did_reduce();
+          need_force_reduce = 0;
+        }
+      }
+    }
+
+    if (evflag) {
+      auto  const pair = (Pair *)style;
+
+#if defined(_OPENMP)
+#pragma omp critical
+#endif
+      {
+        if (eflag & ENERGY_GLOBAL) {
+          pair->eng_vdwl += thr->eng_vdwl;
+          pair->eng_coul += thr->eng_coul;
+          thr->eng_vdwl = 0.0;
+          thr->eng_coul = 0.0;
+        }
+        if (vflag & (VIRIAL_PAIR | VIRIAL_FDOTR))
+          for (int i=0; i < 6; ++i) {
+            pair->virial[i] += thr->virial_pair[i];
+            thr->virial_pair[i] = 0.0;
+          }
+      }
+
+      if (eflag & ENERGY_ATOM) {
+        data_reduce_thr(&(pair->eatom[0]), nall, nthreads, 1, tid);
+      }
+      // per-atom virial and per-atom centroid virial are the same for two-body
+      // many-body pair styles not yet implemented
+      if (vflag & (VIRIAL_ATOM | VIRIAL_CENTROID)) {
+        data_reduce_thr(&(pair->vatom[0][0]), nall, nthreads, 6, tid);
+      }
+      // check cvatom_pair, because can't access centroidstressflag
+      if ((vflag & VIRIAL_CENTROID) && thr->cvatom_pair) {
+        data_reduce_thr(&(pair->cvatom[0][0]), nall, nthreads, 9, tid);
+      }
+    }
+  }
+    break;
+
+  case THR_BOND:
+
+    if (evflag) {
+      Bond * const bond = lmp->force->bond;
+#if defined(_OPENMP)
+#pragma omp critical
+#endif
+      {
+        if (eflag & ENERGY_GLOBAL) {
+          bond->energy += thr->eng_bond;
+          thr->eng_bond = 0.0;
+        }
+
+        if (vflag & (VIRIAL_PAIR | VIRIAL_FDOTR)) {
+          for (int i=0; i < 6; ++i) {
+            bond->virial[i] += thr->virial_bond[i];
+            thr->virial_bond[i] = 0.0;
+          }
+        }
+      }
+
+      if (eflag & ENERGY_ATOM) {
+        data_reduce_thr(&(bond->eatom[0]), nall, nthreads, 1, tid);
+      }
+      // per-atom virial and per-atom centroid virial are the same for bonds
+      if (vflag & (VIRIAL_ATOM | VIRIAL_CENTROID)) {
+        data_reduce_thr(&(bond->vatom[0][0]), nall, nthreads, 6, tid);
+      }
+
+    }
+    break;
+
+  case THR_ANGLE:
+
+    if (evflag) {
+      Angle * const angle = lmp->force->angle;
+#if defined(_OPENMP)
+#pragma omp critical
+#endif
+      {
+        if (eflag & ENERGY_GLOBAL) {
+          angle->energy += thr->eng_angle;
+          thr->eng_angle = 0.0;
+        }
+
+        if (vflag & (VIRIAL_PAIR | VIRIAL_FDOTR)) {
+          for (int i=0; i < 6; ++i) {
+            angle->virial[i] += thr->virial_angle[i];
+            thr->virial_angle[i] = 0.0;
+          }
+        }
+      }
+
+      if (eflag & ENERGY_ATOM) {
+        data_reduce_thr(&(angle->eatom[0]), nall, nthreads, 1, tid);
+      }
+      if (vflag & VIRIAL_ATOM) {
+        data_reduce_thr(&(angle->vatom[0][0]), nall, nthreads, 6, tid);
+      }
+      if (vflag & VIRIAL_CENTROID) {
+        data_reduce_thr(&(angle->cvatom[0][0]), nall, nthreads, 9, tid);
+      }
+
+    }
+    break;
+
+  case THR_DIHEDRAL:
+
+    if (evflag) {
+      Dihedral * const dihedral = lmp->force->dihedral;
+#if defined(_OPENMP)
+#pragma omp critical
+#endif
+      {
+        if (eflag & ENERGY_GLOBAL) {
+          dihedral->energy += thr->eng_dihed;
+          thr->eng_dihed = 0.0;
+        }
+
+        if (vflag & (VIRIAL_PAIR | VIRIAL_FDOTR)) {
+          for (int i=0; i < 6; ++i) {
+            dihedral->virial[i] += thr->virial_dihed[i];
+            thr->virial_dihed[i] = 0.0;
+          }
+        }
+      }
+
+      if (eflag & ENERGY_ATOM) {
+        data_reduce_thr(&(dihedral->eatom[0]), nall, nthreads, 1, tid);
+      }
+      if (vflag & VIRIAL_ATOM) {
+        data_reduce_thr(&(dihedral->vatom[0][0]), nall, nthreads, 6, tid);
+      }
+      if (vflag & VIRIAL_CENTROID) {
+        data_reduce_thr(&(dihedral->cvatom[0][0]), nall, nthreads, 9, tid);
+      }
+
+    }
+    break;
+
+  case THR_DIHEDRAL|THR_CHARMM: // special case for CHARMM dihedrals
+
+    if (evflag) {
+      Dihedral * const dihedral = lmp->force->dihedral;
+      Pair * const pair = lmp->force->pair;
+#if defined(_OPENMP)
+#pragma omp critical
+#endif
+      {
+        if (eflag & ENERGY_GLOBAL) {
+          dihedral->energy += thr->eng_dihed;
+          pair->eng_vdwl += thr->eng_vdwl;
+          pair->eng_coul += thr->eng_coul;
+          thr->eng_dihed = 0.0;
+          thr->eng_vdwl = 0.0;
+          thr->eng_coul = 0.0;
+        }
+
+        if (vflag & (VIRIAL_PAIR | VIRIAL_FDOTR)) {
+          for (int i=0; i < 6; ++i) {
+            dihedral->virial[i] += thr->virial_dihed[i];
+            pair->virial[i] += thr->virial_pair[i];
+            thr->virial_dihed[i] = 0.0;
+            thr->virial_pair[i] = 0.0;
+          }
+        }
+      }
+
+      if (eflag & ENERGY_ATOM) {
+        data_reduce_thr(&(dihedral->eatom[0]), nall, nthreads, 1, tid);
+        data_reduce_thr(&(pair->eatom[0]), nall, nthreads, 1, tid);
+      }
+      if (vflag & VIRIAL_ATOM) {
+        data_reduce_thr(&(dihedral->vatom[0][0]), nall, nthreads, 6, tid);
+      }
+      if (vflag & VIRIAL_CENTROID) {
+        data_reduce_thr(&(dihedral->cvatom[0][0]), nall, nthreads, 9, tid);
+      }
+      // per-atom virial and per-atom centroid virial are the same for two-body
+      // many-body pair styles not yet implemented
+      if (vflag & (VIRIAL_ATOM | VIRIAL_CENTROID)) {
+        data_reduce_thr(&(pair->vatom[0][0]), nall, nthreads, 6, tid);
+      }
+      // check cvatom_pair, because can't access centroidstressflag
+      if ((vflag & VIRIAL_CENTROID) && thr->cvatom_pair) {
+        data_reduce_thr(&(pair->cvatom[0][0]), nall, nthreads, 9, tid);
+      }
+    }
+    break;
+
+  case THR_IMPROPER:
+
+    if (evflag) {
+      Improper *improper = lmp->force->improper;
+#if defined(_OPENMP)
+#pragma omp critical
+#endif
+      {
+        if (eflag & ENERGY_GLOBAL) {
+          improper->energy += thr->eng_imprp;
+          thr->eng_imprp = 0.0;
+        }
+
+        if (vflag & (VIRIAL_PAIR | VIRIAL_FDOTR)) {
+          for (int i=0; i < 6; ++i) {
+            improper->virial[i] += thr->virial_imprp[i];
+            thr->virial_imprp[i] = 0.0;
+          }
+        }
+      }
+
+      if (eflag & ENERGY_ATOM) {
+        data_reduce_thr(&(improper->eatom[0]), nall, nthreads, 1, tid);
+      }
+      if (vflag & VIRIAL_ATOM) {
+        data_reduce_thr(&(improper->vatom[0][0]), nall, nthreads, 6, tid);
+      }
+      if (vflag & VIRIAL_CENTROID) {
+        data_reduce_thr(&(improper->cvatom[0][0]), nall, nthreads, 9, tid);
+      }
+
+    }
+    break;
+
+  case THR_KSPACE:
+    // nothing to do. XXX may need to add support for per-atom info
+    break;
+
+  case THR_INTGR:
+    // nothing to do
+    break;
+
+  default:
+    printf("tid:%d unhandled thr_style case %d\n", tid, thr_style);
+    break;
+  }
+
+  if (style == fix->last_omp_style) {
+    if (need_force_reduce) {
+      data_reduce_thr(&(f[0][0]), nall, nthreads, 3, tid);
+      fix->did_reduce();
+    }
+
+    if (lmp->atom->torque)
+      data_reduce_thr(&(lmp->atom->torque[0][0]), nall, nthreads, 3, tid);
+  }
+  thr->timer(Timer::COMM);
+}
+
+/* ----------------------------------------------------------------------
+   tally eng_vdwl and eng_coul into per thread global and per-atom accumulators
+------------------------------------------------------------------------- */
+
+void ThrOMP::e_tally_thr(Pair * const pair, const int i, const int j,
+                         const int nlocal, const int newton_pair,
+                         const double evdwl, const double ecoul, ThrData * const thr)
+{
+  if (pair->eflag_global) {
+    if (newton_pair) {
+      thr->eng_vdwl += evdwl;
+      thr->eng_coul += ecoul;
+    } else {
+      const double evdwlhalf = 0.5*evdwl;
+      const double ecoulhalf = 0.5*ecoul;
+      if (i < nlocal) {
+        thr->eng_vdwl += evdwlhalf;
+        thr->eng_coul += ecoulhalf;
+      }
+      if (j < nlocal) {
+        thr->eng_vdwl += evdwlhalf;
+        thr->eng_coul += ecoulhalf;
+      }
+    }
+  }
+  if (pair->eflag_atom && thr->eatom_pair) {
+    const double epairhalf = 0.5 * (evdwl + ecoul);
+    if (newton_pair || i < nlocal) thr->eatom_pair[i] += epairhalf;
+    if (newton_pair || j < nlocal) thr->eatom_pair[j] += epairhalf;
+  }
+}
+
+/* helper functions */
+static void v_tally(double * const vout, const double * const vin)
+{
+  vout[0] += vin[0];
+  vout[1] += vin[1];
+  vout[2] += vin[2];
+  vout[3] += vin[3];
+  vout[4] += vin[4];
+  vout[5] += vin[5];
+}
+
+static void v_tally9(double * const vout, const double * const vin)
+{
+  vout[0] += vin[0];
+  vout[1] += vin[1];
+  vout[2] += vin[2];
+  vout[3] += vin[3];
+  vout[4] += vin[4];
+  vout[5] += vin[5];
+  vout[6] += vin[6];
+  vout[7] += vin[7];
+  vout[8] += vin[8];
+}
+
+static void v_tally(double * const vout, const double scale, const double * const vin)
+{
+  vout[0] += scale*vin[0];
+  vout[1] += scale*vin[1];
+  vout[2] += scale*vin[2];
+  vout[3] += scale*vin[3];
+  vout[4] += scale*vin[4];
+  vout[5] += scale*vin[5];
+}
+
+/* ----------------------------------------------------------------------
+   tally virial into per thread global and per-atom accumulators
+------------------------------------------------------------------------- */
+void ThrOMP::v_tally_thr(Pair * const pair, const int i, const int j,
+                         const int nlocal, const int newton_pair,
+                         const double * const v, ThrData * const thr)
+{
+  if (pair->vflag_global) {
+    double * const va = thr->virial_pair;
+    if (newton_pair) {
+      v_tally(va,v);
+    } else {
+      if (i < nlocal) v_tally(va,0.5,v);
+      if (j < nlocal) v_tally(va,0.5,v);
+    }
+  }
+
+  if (pair->vflag_atom) {
+    if (newton_pair || i < nlocal) {
+      double * const va = thr->vatom_pair[i];
+      v_tally(va,0.5,v);
+    }
+    if (newton_pair || j < nlocal) {
+      double * const va = thr->vatom_pair[j];
+      v_tally(va,0.5,v);
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   tally eng_vdwl and virial into per thread global and per-atom accumulators
+   need i < nlocal test since called by bond_quartic and dihedral_charmm
+------------------------------------------------------------------------- */
+
+void ThrOMP::ev_tally_thr(Pair * const pair, const int i, const int j, const int nlocal,
+                          const int newton_pair, const double evdwl, const double ecoul,
+                          const double fpair, const double delx, const double dely,
+                          const double delz, ThrData * const thr)
+{
+
+  if (pair->eflag_either)
+    e_tally_thr(pair, i, j, nlocal, newton_pair, evdwl, ecoul, thr);
+
+  if (pair->vflag_either) {
+    double v[6];
+    v[0] = delx*delx*fpair;
+    v[1] = dely*dely*fpair;
+    v[2] = delz*delz*fpair;
+    v[3] = delx*dely*fpair;
+    v[4] = delx*delz*fpair;
+    v[5] = dely*delz*fpair;
+
+    v_tally_thr(pair, i, j, nlocal, newton_pair, v, thr);
+  }
+
+  if (pair->num_tally_compute > 0) {
+    // ev_tally callbacks are not thread safe and thus have to be protected
+#if defined(_OPENMP)
+#pragma omp critical
+#endif
+    for (int k=0; k < pair->num_tally_compute; ++k) {
+      Compute *c = pair->list_tally_compute[k];
+      c->pair_tally_callback(i, j, nlocal, newton_pair,
+                             evdwl, ecoul, fpair, delx, dely, delz);
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   tally eng_vdwl and virial into per thread global and per-atom accumulators
+   for full neighbor list. Only tally atom i and also set newton to off.
+------------------------------------------------------------------------- */
+
+void ThrOMP::ev_tally_full_thr(Pair * const pair, const int i, const double evdwl,
+                               const double ecoul, const double fpair, const double delx,
+                               const double dely, const double delz, ThrData * const thr)
+{
+  if (pair->eflag_either)
+    e_tally_thr(pair, i, /*j*/ i+1, /*nlocal*/ i+1, /*newton_pair*/ 0, evdwl, ecoul, thr);
+
+  if (pair->vflag_either) {
+    double v[6];
+    v[0] = delx*delx*fpair;
+    v[1] = dely*dely*fpair;
+    v[2] = delz*delz*fpair;
+    v[3] = delx*dely*fpair;
+    v[4] = delx*delz*fpair;
+    v[5] = dely*delz*fpair;
+
+    v_tally_thr(pair, i, /*j*/ i+1, /*nlocal*/ i+1, /*newton_pair*/ 0, v, thr);
+  }
+
+  if (pair->num_tally_compute > 0) {
+    // ev_tally callbacks are not thread safe and thus have to be protected
+#if defined(_OPENMP)
+#pragma omp critical
+#endif
+    for (int k=0; k < pair->num_tally_compute; ++k) {
+      Compute *c = pair->list_tally_compute[k];
+      c->pair_tally_callback(i, i+1, i, 0, evdwl, ecoul, fpair, delx, dely, delz);
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   tally eng_vdwl and virial into global and per-atom accumulators
+   for virial, have delx,dely,delz and fx,fy,fz
+------------------------------------------------------------------------- */
+
+void ThrOMP::ev_tally_xyz_thr(Pair * const pair, const int i, const int j,
+                              const int nlocal, const int newton_pair,
+                              const double evdwl, const double ecoul,
+                              const double fx, const double fy, const double fz,
+                              const double delx, const double dely, const double delz,
+                              ThrData * const thr)
+{
+
+  if (pair->eflag_either)
+    e_tally_thr(pair, i, j, nlocal, newton_pair, evdwl, ecoul, thr);
+
+  if (pair->vflag_either) {
+    double v[6];
+    v[0] = delx*fx;
+    v[1] = dely*fy;
+    v[2] = delz*fz;
+    v[3] = delx*fy;
+    v[4] = delx*fz;
+    v[5] = dely*fz;
+
+    v_tally_thr(pair, i, j, nlocal, newton_pair, v, thr);
+  }
+}
+
+
+/* ----------------------------------------------------------------------
+   tally eng_vdwl and virial into global and per-atom accumulators
+   for virial, have delx,dely,delz and fx,fy,fz
+   called when using full neighbor lists
+------------------------------------------------------------------------- */
+
+void ThrOMP::ev_tally_xyz_full_thr(Pair * const pair, const int i,
+                                   const double evdwl, const double ecoul,
+                                   const double fx, const double fy,
+                                   const double fz, const double delx,
+                                   const double dely, const double delz,
+                                   ThrData * const thr)
+{
+
+  if (pair->eflag_either)
+    e_tally_thr(pair,i,i,i+1,0,0.5*evdwl,ecoul,thr);
+
+  if (pair->vflag_either) {
+    double v[6];
+    v[0] = 0.5*delx*fx;
+    v[1] = 0.5*dely*fy;
+    v[2] = 0.5*delz*fz;
+    v[3] = 0.5*delx*fy;
+    v[4] = 0.5*delx*fz;
+    v[5] = 0.5*dely*fz;
+
+    v_tally_thr(pair,i,i,i+1,0,v,thr);
+  }
+}
+
+/* ----------------------------------------------------------------------
+   tally eng_vdwl and virial into global and per-atom accumulators
+   called by SW and hbond potentials, newton_pair is always on
+   virial = riFi + rjFj + rkFk = (rj-ri) Fj + (rk-ri) Fk = drji*fj + drki*fk
+ ------------------------------------------------------------------------- */
+
+void ThrOMP::ev_tally3_thr(Pair * const pair, const int i, const int j, const int k,
+                           const double evdwl, const double ecoul,
+                           const double * const fj, const double * const fk,
+                           const double * const drji, const double * const drki,
+                           ThrData * const thr)
+{
+  if (pair->eflag_either) {
+    if (pair->eflag_global) {
+      thr->eng_vdwl += evdwl;
+      thr->eng_coul += ecoul;
+    }
+    if (pair->eflag_atom) {
+      const double epairthird = THIRD * (evdwl + ecoul);
+      thr->eatom_pair[i] += epairthird;
+      thr->eatom_pair[j] += epairthird;
+      thr->eatom_pair[k] += epairthird;
+    }
+  }
+
+  if (pair->vflag_either) {
+    double v[6];
+
+    v[0] = drji[0]*fj[0] + drki[0]*fk[0];
+    v[1] = drji[1]*fj[1] + drki[1]*fk[1];
+    v[2] = drji[2]*fj[2] + drki[2]*fk[2];
+    v[3] = drji[0]*fj[1] + drki[0]*fk[1];
+    v[4] = drji[0]*fj[2] + drki[0]*fk[2];
+    v[5] = drji[1]*fj[2] + drki[1]*fk[2];
+
+    if (pair->vflag_global) v_tally(thr->virial_pair,v);
+
+    if (pair->vflag_atom) {
+      v_tally(thr->vatom_pair[i],THIRD,v);
+      v_tally(thr->vatom_pair[j],THIRD,v);
+      v_tally(thr->vatom_pair[k],THIRD,v);
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   tally eng_vdwl and virial into global and per-atom accumulators
+   called by AIREBO potential, newton_pair is always on
+ ------------------------------------------------------------------------- */
+
+void ThrOMP::ev_tally4_thr(Pair * const pair, const int i, const int j,
+                           const int k, const int m, const double evdwl,
+                           const double * const fi, const double * const fj,
+                           const double * const fk, const double * const drim,
+                           const double * const drjm, const double * const drkm,
+                           ThrData * const thr)
+{
+  double v[6];
+
+  if (pair->eflag_either) {
+    if (pair->eflag_global) thr->eng_vdwl += evdwl;
+    if (pair->eflag_atom) {
+      const double epairfourth = 0.25 * evdwl;
+      thr->eatom_pair[i] += epairfourth;
+      thr->eatom_pair[j] += epairfourth;
+      thr->eatom_pair[k] += epairfourth;
+      thr->eatom_pair[m] += epairfourth;
+    }
+  }
+
+  if (pair->vflag_either) {
+    v[0] = (drim[0]*fi[0] + drjm[0]*fj[0] + drkm[0]*fk[0]);
+    v[1] = (drim[1]*fi[1] + drjm[1]*fj[1] + drkm[1]*fk[1]);
+    v[2] = (drim[2]*fi[2] + drjm[2]*fj[2] + drkm[2]*fk[2]);
+    v[3] = (drim[0]*fi[1] + drjm[0]*fj[1] + drkm[0]*fk[1]);
+    v[4] = (drim[0]*fi[2] + drjm[0]*fj[2] + drkm[0]*fk[2]);
+    v[5] = (drim[1]*fi[2] + drjm[1]*fj[2] + drkm[1]*fk[2]);
+    if (pair->vflag_global) v_tally(thr->virial_pair,v);
+
+    if (pair->vflag_atom) {
+      v[0] *= 0.25;
+      v[1] *= 0.25;
+      v[2] *= 0.25;
+      v[3] *= 0.25;
+      v[4] *= 0.25;
+      v[5] *= 0.25;
+      v_tally(thr->vatom_pair[i],v);
+      v_tally(thr->vatom_pair[j],v);
+      v_tally(thr->vatom_pair[k],v);
+      v_tally(thr->vatom_pair[m],v);
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   tally ecoul and virial into each of n atoms in list
+   called by TIP4P potential, newton_pair is always on
+   changes v values by dividing by n
+ ------------------------------------------------------------------------- */
+
+void ThrOMP::ev_tally_list_thr(Pair * const pair, const int key,
+                               const int * const list, const double * const v,
+                               const double ecoul, const double alpha,
+                               ThrData * const thr)
+{
+  int i;
+  if (pair->eflag_either) {
+    if (pair->eflag_global) thr->eng_coul += ecoul;
+    if (pair->eflag_atom) {
+      if (key == 0) {
+        thr->eatom_pair[list[0]] += 0.5*ecoul;
+        thr->eatom_pair[list[1]] += 0.5*ecoul;
+      } else if (key == 1) {
+        thr->eatom_pair[list[0]] += 0.5*ecoul*(1-alpha);
+        thr->eatom_pair[list[1]] += 0.25*ecoul*alpha;
+        thr->eatom_pair[list[2]] += 0.25*ecoul*alpha;
+        thr->eatom_pair[list[3]] += 0.5*ecoul;
+      } else if (key == 2) {
+        thr->eatom_pair[list[0]] += 0.5*ecoul;
+        thr->eatom_pair[list[1]] += 0.5*ecoul*(1-alpha);
+        thr->eatom_pair[list[2]] += 0.25*ecoul*alpha;
+        thr->eatom_pair[list[3]] += 0.25*ecoul*alpha;
+      } else {
+        thr->eatom_pair[list[0]] += 0.5*ecoul*(1-alpha);
+        thr->eatom_pair[list[1]] += 0.25*ecoul*alpha;
+        thr->eatom_pair[list[2]] += 0.25*ecoul*alpha;
+        thr->eatom_pair[list[3]] += 0.5*ecoul*(1-alpha);
+        thr->eatom_pair[list[4]] += 0.25*ecoul*alpha;
+        thr->eatom_pair[list[5]] += 0.25*ecoul*alpha;
+      }
+    }
+  }
+
+  if (pair->vflag_either) {
+    if (pair->vflag_global)
+      v_tally(thr->virial_pair,v);
+
+    if (pair->vflag_atom) {
+      if (key == 0) {
+        for (i = 0; i <= 5; i++) {
+          thr->vatom_pair[list[0]][i] += 0.5*v[i];
+          thr->vatom_pair[list[1]][i] += 0.5*v[i];
+        }
+      } else if (key == 1) {
+        for (i = 0; i <= 5; i++) {
+          thr->vatom_pair[list[0]][i] += 0.5*v[i]*(1-alpha);
+          thr->vatom_pair[list[1]][i] += 0.25*v[i]*alpha;
+          thr->vatom_pair[list[2]][i] += 0.25*v[i]*alpha;
+          thr->vatom_pair[list[3]][i] += 0.5*v[i];
+        }
+      } else if (key == 2) {
+        for (i = 0; i <= 5; i++) {
+          thr->vatom_pair[list[0]][i] += 0.5*v[i];
+          thr->vatom_pair[list[1]][i] += 0.5*v[i]*(1-alpha);
+          thr->vatom_pair[list[2]][i] += 0.25*v[i]*alpha;
+          thr->vatom_pair[list[3]][i] += 0.25*v[i]*alpha;
+        }
+      } else {
+        for (i = 0; i <= 5; i++) {
+          thr->vatom_pair[list[0]][i] += 0.5*v[i]*(1-alpha);
+          thr->vatom_pair[list[1]][i] += 0.25*v[i]*alpha;
+          thr->vatom_pair[list[2]][i] += 0.25*v[i]*alpha;
+          thr->vatom_pair[list[3]][i] += 0.5*v[i]*(1-alpha);
+          thr->vatom_pair[list[4]][i] += 0.25*v[i]*alpha;
+          thr->vatom_pair[list[5]][i] += 0.25*v[i]*alpha;
+        }
+      }
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   tally energy and virial into global and per-atom accumulators
+------------------------------------------------------------------------- */
+
+void ThrOMP::ev_tally_thr(Bond * const bond, const int i, const int j, const int nlocal,
+                          const int newton_bond, const double ebond, const double fbond,
+                          const double delx, const double dely, const double delz,
+                          ThrData * const thr)
+{
+  if (bond->eflag_either) {
+    const double ebondhalf = 0.5*ebond;
+    if (newton_bond) {
+      if (bond->eflag_global)
+        thr->eng_bond += ebond;
+      if (bond->eflag_atom) {
+        thr->eatom_bond[i] += ebondhalf;
+        thr->eatom_bond[j] += ebondhalf;
+      }
+    } else {
+      if (bond->eflag_global) {
+        if (i < nlocal) thr->eng_bond += ebondhalf;
+        if (j < nlocal) thr->eng_bond += ebondhalf;
+      }
+      if (bond->eflag_atom) {
+        if (i < nlocal) thr->eatom_bond[i] += ebondhalf;
+        if (j < nlocal) thr->eatom_bond[j] += ebondhalf;
+      }
+    }
+  }
+
+  if (bond->vflag_either) {
+    double v[6];
+
+    v[0] = delx*delx*fbond;
+    v[1] = dely*dely*fbond;
+    v[2] = delz*delz*fbond;
+    v[3] = delx*dely*fbond;
+    v[4] = delx*delz*fbond;
+    v[5] = dely*delz*fbond;
+
+    if (bond->vflag_global) {
+      if (newton_bond)
+        v_tally(thr->virial_bond,v);
+      else {
+        if (i < nlocal)
+          v_tally(thr->virial_bond,0.5,v);
+        if (j < nlocal)
+          v_tally(thr->virial_bond,0.5,v);
+      }
+    }
+
+    if (bond->vflag_atom) {
+      v[0] *= 0.5;
+      v[1] *= 0.5;
+      v[2] *= 0.5;
+      v[3] *= 0.5;
+      v[4] *= 0.5;
+      v[5] *= 0.5;
+
+      if (newton_bond) {
+        v_tally(thr->vatom_bond[i],v);
+        v_tally(thr->vatom_bond[j],v);
+      } else {
+        if (i < nlocal)
+          v_tally(thr->vatom_bond[i],v);
+        if (j < nlocal)
+          v_tally(thr->vatom_bond[j],v);
+      }
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   tally energy and virial into global and per-atom accumulators
+   virial = r1F1 + r2F2 + r3F3 = (r1-r2) F1 + (r3-r2) F3 = del1*f1 + del2*f3
+------------------------------------------------------------------------- */
+
+void ThrOMP::ev_tally_thr(Angle * const angle, const int i, const int j, const int k,
+                          const int nlocal, const int newton_bond, const double eangle,
+                          const double * const f1, const double * const f3,
+                          const double delx1, const double dely1, const double delz1,
+                          const double delx2, const double dely2, const double delz2,
+                          ThrData * const thr)
+{
+  if (angle->eflag_either) {
+    const double eanglethird = THIRD*eangle;
+    if (newton_bond) {
+      if (angle->eflag_global)
+        thr->eng_angle += eangle;
+      if (angle->eflag_atom) {
+        thr->eatom_angle[i] += eanglethird;
+        thr->eatom_angle[j] += eanglethird;
+        thr->eatom_angle[k] += eanglethird;
+      }
+    } else {
+      if (angle->eflag_global) {
+        if (i < nlocal) thr->eng_angle += eanglethird;
+        if (j < nlocal) thr->eng_angle += eanglethird;
+        if (k < nlocal) thr->eng_angle += eanglethird;
+      }
+      if (angle->eflag_atom) {
+        if (i < nlocal) thr->eatom_angle[i] += eanglethird;
+        if (j < nlocal) thr->eatom_angle[j] += eanglethird;
+        if (k < nlocal) thr->eatom_angle[k] += eanglethird;
+      }
+    }
+  }
+
+  if (angle->vflag_either) {
+    double v[6];
+
+    v[0] = delx1*f1[0] + delx2*f3[0];
+    v[1] = dely1*f1[1] + dely2*f3[1];
+    v[2] = delz1*f1[2] + delz2*f3[2];
+    v[3] = delx1*f1[1] + delx2*f3[1];
+    v[4] = delx1*f1[2] + delx2*f3[2];
+    v[5] = dely1*f1[2] + dely2*f3[2];
+
+    if (angle->vflag_global) {
+      if (newton_bond) {
+        v_tally(thr->virial_angle,v);
+      } else {
+        int cnt = 0;
+        if (i < nlocal) ++cnt;
+        if (j < nlocal) ++cnt;
+        if (k < nlocal) ++cnt;
+        v_tally(thr->virial_angle,cnt*THIRD,v);
+      }
+    }
+
+    if (angle->vflag_atom) {
+      v[0] *= THIRD;
+      v[1] *= THIRD;
+      v[2] *= THIRD;
+      v[3] *= THIRD;
+      v[4] *= THIRD;
+      v[5] *= THIRD;
+
+      if (newton_bond) {
+        v_tally(thr->vatom_angle[i],v);
+        v_tally(thr->vatom_angle[j],v);
+        v_tally(thr->vatom_angle[k],v);
+      } else {
+        if (i < nlocal) v_tally(thr->vatom_angle[i],v);
+        if (j < nlocal) v_tally(thr->vatom_angle[j],v);
+        if (k < nlocal) v_tally(thr->vatom_angle[k],v);
+      }
+    }
+  }
+
+  // per-atom centroid virial
+  if (angle->cvflag_atom) {
+    double f2[3], v1[9], v2[9], v3[9];
+    double a1[3], a2[3], a3[3];
+
+    // r0 = (r1+r2+r3)/3
+    // rij = ri-rj
+    // total virial = r10*f1 + r20*f2 + r30*f3
+    // del1: r12
+    // del2: r32
+
+    // a1 = r10 = (2*r12 -   r32)/3
+    a1[0] = THIRD*(2*delx1-delx2);
+    a1[1] = THIRD*(2*dely1-dely2);
+    a1[2] = THIRD*(2*delz1-delz2);
+
+    // a2 = r20 = ( -r12 -   r32)/3
+    a2[0] = THIRD*(-delx1-delx2);
+    a2[1] = THIRD*(-dely1-dely2);
+    a2[2] = THIRD*(-delz1-delz2);
+
+    // a3 = r30 = ( -r12 + 2*r32)/3
+    a3[0] = THIRD*(-delx1+2*delx2);
+    a3[1] = THIRD*(-dely1+2*dely2);
+    a3[2] = THIRD*(-delz1+2*delz2);
+
+    f2[0] = - f1[0] - f3[0];
+    f2[1] = - f1[1] - f3[1];
+    f2[2] = - f1[2] - f3[2];
+
+    v1[0] = a1[0]*f1[0];
+    v1[1] = a1[1]*f1[1];
+    v1[2] = a1[2]*f1[2];
+    v1[3] = a1[0]*f1[1];
+    v1[4] = a1[0]*f1[2];
+    v1[5] = a1[1]*f1[2];
+    v1[6] = a1[1]*f1[0];
+    v1[7] = a1[2]*f1[0];
+    v1[8] = a1[2]*f1[1];
+
+    v2[0] = a2[0]*f2[0];
+    v2[1] = a2[1]*f2[1];
+    v2[2] = a2[2]*f2[2];
+    v2[3] = a2[0]*f2[1];
+    v2[4] = a2[0]*f2[2];
+    v2[5] = a2[1]*f2[2];
+    v2[6] = a2[1]*f2[0];
+    v2[7] = a2[2]*f2[0];
+    v2[8] = a2[2]*f2[1];
+
+    v3[0] = a3[0]*f3[0];
+    v3[1] = a3[1]*f3[1];
+    v3[2] = a3[2]*f3[2];
+    v3[3] = a3[0]*f3[1];
+    v3[4] = a3[0]*f3[2];
+    v3[5] = a3[1]*f3[2];
+    v3[6] = a3[1]*f3[0];
+    v3[7] = a3[2]*f3[0];
+    v3[8] = a3[2]*f3[1];
+
+    if (newton_bond) {
+      v_tally9(thr->cvatom_angle[i],v1);
+      v_tally9(thr->cvatom_angle[j],v2);
+      v_tally9(thr->cvatom_angle[k],v3);
+    } else {
+      if (i < nlocal) v_tally9(thr->cvatom_angle[i],v1);
+      if (j < nlocal) v_tally9(thr->cvatom_angle[j],v2);
+      if (k < nlocal) v_tally9(thr->cvatom_angle[k],v3);
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   tally energy and virial from 1-3 repulsion of SPICA angle into accumulators
+------------------------------------------------------------------------- */
+
+void ThrOMP::ev_tally13_thr(Angle * const angle, const int i1, const int i3,
+                            const int nlocal, const int newton_bond,
+                            const double epair, const double fpair,
+                            const double delx, const double dely,
+                            const double delz, ThrData * const thr)
+{
+
+  if (angle->eflag_either) {
+    const double epairhalf = 0.5 * epair;
+
+    if (angle->eflag_global) {
+      if (newton_bond || i1 < nlocal)
+        thr->eng_angle += epairhalf;
+      if (newton_bond || i3 < nlocal)
+        thr->eng_angle += epairhalf;
+    }
+
+    if (angle->eflag_atom) {
+      if (newton_bond || i1 < nlocal) thr->eatom_angle[i1] += epairhalf;
+      if (newton_bond || i3 < nlocal) thr->eatom_angle[i3] += epairhalf;
+    }
+  }
+
+  if (angle->vflag_either) {
+    double v[6];
+    v[0] = delx*delx*fpair;
+    v[1] = dely*dely*fpair;
+    v[2] = delz*delz*fpair;
+    v[3] = delx*dely*fpair;
+    v[4] = delx*delz*fpair;
+    v[5] = dely*delz*fpair;
+
+    if (angle->vflag_global) {
+      double * const va = thr->virial_angle;
+      if (newton_bond || i1 < nlocal) v_tally(va,0.5,v);
+      if (newton_bond || i3 < nlocal) v_tally(va,0.5,v);
+    }
+
+    if (angle->vflag_atom) {
+      if (newton_bond || i1 < nlocal) {
+        double * const va = thr->vatom_angle[i1];
+        v_tally(va,0.5,v);
+      }
+      if (newton_bond || i3 < nlocal) {
+        double * const va = thr->vatom_angle[i3];
+        v_tally(va,0.5,v);
+      }
+    }
+  }
+}
+
+
+/* ----------------------------------------------------------------------
+   tally energy and virial into global and per-atom accumulators
+   virial = r1F1 + r2F2 + r3F3 + r4F4 = (r1-r2) F1 + (r3-r2) F3 + (r4-r2) F4
+          = (r1-r2) F1 + (r3-r2) F3 + (r4-r3 + r3-r2) F4
+          = vb1*f1 + vb2*f3 + (vb3+vb2)*f4
+------------------------------------------------------------------------- */
+
+void ThrOMP::ev_tally_thr(Dihedral * const dihed, const int i1, const int i2,
+                          const int i3, const int i4, const int nlocal,
+                          const int newton_bond, const double edihedral,
+                          const double * const f1, const double * const f3,
+                          const double * const f4, const double vb1x,
+                          const double vb1y, const double vb1z, const double vb2x,
+                          const double vb2y, const double vb2z, const double vb3x,
+                          const double vb3y, const double vb3z, ThrData * const thr)
+{
+
+  if (dihed->eflag_either) {
+    if (dihed->eflag_global) {
+      if (newton_bond) {
+        thr->eng_dihed += edihedral;
+      } else {
+        const double edihedralquarter = 0.25*edihedral;
+        int cnt = 0;
+        if (i1 < nlocal) ++cnt;
+        if (i2 < nlocal) ++cnt;
+        if (i3 < nlocal) ++cnt;
+        if (i4 < nlocal) ++cnt;
+        thr->eng_dihed += static_cast<double>(cnt)*edihedralquarter;
+      }
+    }
+    if (dihed->eflag_atom) {
+      const double edihedralquarter = 0.25*edihedral;
+      if (newton_bond) {
+        thr->eatom_dihed[i1] += edihedralquarter;
+        thr->eatom_dihed[i2] += edihedralquarter;
+        thr->eatom_dihed[i3] += edihedralquarter;
+        thr->eatom_dihed[i4] += edihedralquarter;
+      } else {
+        if (i1 < nlocal) thr->eatom_dihed[i1] +=  edihedralquarter;
+        if (i2 < nlocal) thr->eatom_dihed[i2] +=  edihedralquarter;
+        if (i3 < nlocal) thr->eatom_dihed[i3] +=  edihedralquarter;
+        if (i4 < nlocal) thr->eatom_dihed[i4] +=  edihedralquarter;
+      }
+    }
+  }
+
+  if (dihed->vflag_either) {
+    double v[6];
+    v[0] = vb1x*f1[0] + vb2x*f3[0] + (vb3x+vb2x)*f4[0];
+    v[1] = vb1y*f1[1] + vb2y*f3[1] + (vb3y+vb2y)*f4[1];
+    v[2] = vb1z*f1[2] + vb2z*f3[2] + (vb3z+vb2z)*f4[2];
+    v[3] = vb1x*f1[1] + vb2x*f3[1] + (vb3x+vb2x)*f4[1];
+    v[4] = vb1x*f1[2] + vb2x*f3[2] + (vb3x+vb2x)*f4[2];
+    v[5] = vb1y*f1[2] + vb2y*f3[2] + (vb3y+vb2y)*f4[2];
+
+    if (dihed->vflag_global) {
+      if (newton_bond) {
+        v_tally(thr->virial_dihed,v);
+      } else {
+        int cnt = 0;
+        if (i1 < nlocal) ++cnt;
+        if (i2 < nlocal) ++cnt;
+        if (i3 < nlocal) ++cnt;
+        if (i4 < nlocal) ++cnt;
+        v_tally(thr->virial_dihed,0.25*static_cast<double>(cnt),v);
+      }
+    }
+
+    v[0] *= 0.25;
+    v[1] *= 0.25;
+    v[2] *= 0.25;
+    v[3] *= 0.25;
+    v[4] *= 0.25;
+    v[5] *= 0.25;
+
+    if (dihed->vflag_atom) {
+      if (newton_bond) {
+        v_tally(thr->vatom_dihed[i1],v);
+        v_tally(thr->vatom_dihed[i2],v);
+        v_tally(thr->vatom_dihed[i3],v);
+        v_tally(thr->vatom_dihed[i4],v);
+      } else {
+        if (i1 < nlocal) v_tally(thr->vatom_dihed[i1],v);
+        if (i2 < nlocal) v_tally(thr->vatom_dihed[i2],v);
+        if (i3 < nlocal) v_tally(thr->vatom_dihed[i3],v);
+        if (i4 < nlocal) v_tally(thr->vatom_dihed[i4],v);
+      }
+    }
+  }
+
+  // per-atom centroid virial
+  if (dihed->cvflag_atom) {
+    double f2[3], v1[9], v2[9], v3[9], v4[9];
+    double a1[3], a2[3], a3[3], a4[3];
+
+    // r0 = (r1+r2+r3+r4)/4
+    // rij = ri-rj
+    // total virial = r10*f1 + r20*f2 + r30*f3 + r40*f4
+    // vb1: r12
+    // vb2: r32
+    // vb3: r43
+
+    // a1 = r10 = (3*r12 - 2*r32 -   r43)/4
+    a1[0] = 0.25*(3*vb1x - 2*vb2x - vb3x);
+    a1[1] = 0.25*(3*vb1y - 2*vb2y - vb3y);
+    a1[2] = 0.25*(3*vb1z - 2*vb2z - vb3z);
+
+    // a2 = r20 = ( -r12 - 2*r32 -   r43)/4
+    a2[0] = 0.25*(-vb1x - 2*vb2x - vb3x);
+    a2[1] = 0.25*(-vb1y - 2*vb2y - vb3y);
+    a2[2] = 0.25*(-vb1z - 2*vb2z - vb3z);
+
+    // a3 = r30 = ( -r12 + 2*r32 -   r43)/4
+    a3[0] = 0.25*(-vb1x + 2*vb2x - vb3x);
+    a3[1] = 0.25*(-vb1y + 2*vb2y - vb3y);
+    a3[2] = 0.25*(-vb1z + 2*vb2z - vb3z);
+
+    // a4 = r40 = ( -r12 + 2*r32 + 3*r43)/4
+    a4[0] = 0.25*(-vb1x + 2*vb2x + 3*vb3x);
+    a4[1] = 0.25*(-vb1y + 2*vb2y + 3*vb3y);
+    a4[2] = 0.25*(-vb1z + 2*vb2z + 3*vb3z);
+
+    f2[0] = - f1[0] - f3[0] - f4[0];
+    f2[1] = - f1[1] - f3[1] - f4[1];
+    f2[2] = - f1[2] - f3[2] - f4[2];
+
+    v1[0] = a1[0]*f1[0];
+    v1[1] = a1[1]*f1[1];
+    v1[2] = a1[2]*f1[2];
+    v1[3] = a1[0]*f1[1];
+    v1[4] = a1[0]*f1[2];
+    v1[5] = a1[1]*f1[2];
+    v1[6] = a1[1]*f1[0];
+    v1[7] = a1[2]*f1[0];
+    v1[8] = a1[2]*f1[1];
+
+    v2[0] = a2[0]*f2[0];
+    v2[1] = a2[1]*f2[1];
+    v2[2] = a2[2]*f2[2];
+    v2[3] = a2[0]*f2[1];
+    v2[4] = a2[0]*f2[2];
+    v2[5] = a2[1]*f2[2];
+    v2[6] = a2[1]*f2[0];
+    v2[7] = a2[2]*f2[0];
+    v2[8] = a2[2]*f2[1];
+
+    v3[0] = a3[0]*f3[0];
+    v3[1] = a3[1]*f3[1];
+    v3[2] = a3[2]*f3[2];
+    v3[3] = a3[0]*f3[1];
+    v3[4] = a3[0]*f3[2];
+    v3[5] = a3[1]*f3[2];
+    v3[6] = a3[1]*f3[0];
+    v3[7] = a3[2]*f3[0];
+    v3[8] = a3[2]*f3[1];
+
+    v4[0] = a4[0]*f4[0];
+    v4[1] = a4[1]*f4[1];
+    v4[2] = a4[2]*f4[2];
+    v4[3] = a4[0]*f4[1];
+    v4[4] = a4[0]*f4[2];
+    v4[5] = a4[1]*f4[2];
+    v4[6] = a4[1]*f4[0];
+    v4[7] = a4[2]*f4[0];
+    v4[8] = a4[2]*f4[1];
+
+    if (newton_bond) {
+      v_tally9(thr->cvatom_dihed[i1],v1);
+      v_tally9(thr->cvatom_dihed[i2],v2);
+      v_tally9(thr->cvatom_dihed[i3],v3);
+      v_tally9(thr->cvatom_dihed[i4],v4);
+    } else {
+      if (i1 < nlocal) v_tally9(thr->cvatom_dihed[i1],v1);
+      if (i2 < nlocal) v_tally9(thr->cvatom_dihed[i2],v2);
+      if (i3 < nlocal) v_tally9(thr->cvatom_dihed[i3],v3);
+      if (i4 < nlocal) v_tally9(thr->cvatom_dihed[i4],v4);
+    }
+  }
+}
+
+/* ----------------------------------------------------------------------
+   tally energy and virial into global and per-atom accumulators
+   virial = r1F1 + r2F2 + r3F3 + r4F4 = (r1-r2) F1 + (r3-r2) F3 + (r4-r2) F4
+          = (r1-r2) F1 + (r3-r2) F3 + (r4-r3 + r3-r2) F4
+          = vb1*f1 + vb2*f3 + (vb3+vb2)*f4
+------------------------------------------------------------------------- */
+
+void ThrOMP::ev_tally_thr(Improper * const imprp, const int i1, const int i2,
+                          const int i3, const int i4, const int nlocal,
+                          const int newton_bond, const double eimproper,
+                          const double * const f1, const double * const f3,
+                          const double * const f4, const double vb1x,
+                          const double vb1y, const double vb1z, const double vb2x,
+                          const double vb2y, const double vb2z, const double vb3x,
+                          const double vb3y, const double vb3z, ThrData * const thr)
+{
+
+  if (imprp->eflag_either) {
+    if (imprp->eflag_global) {
+      if (newton_bond) {
+        thr->eng_imprp += eimproper;
+      } else {
+        const double eimproperquarter = 0.25*eimproper;
+        int cnt = 0;
+        if (i1 < nlocal) ++cnt;
+        if (i2 < nlocal) ++cnt;
+        if (i3 < nlocal) ++cnt;
+        if (i4 < nlocal) ++cnt;
+        thr->eng_imprp += static_cast<double>(cnt)*eimproperquarter;
+      }
+    }
+    if (imprp->eflag_atom) {
+      const double eimproperquarter = 0.25*eimproper;
+      if (newton_bond) {
+        thr->eatom_imprp[i1] += eimproperquarter;
+        thr->eatom_imprp[i2] += eimproperquarter;
+        thr->eatom_imprp[i3] += eimproperquarter;
+        thr->eatom_imprp[i4] += eimproperquarter;
+      } else {
+        if (i1 < nlocal) thr->eatom_imprp[i1] +=  eimproperquarter;
+        if (i2 < nlocal) thr->eatom_imprp[i2] +=  eimproperquarter;
+        if (i3 < nlocal) thr->eatom_imprp[i3] +=  eimproperquarter;
+        if (i4 < nlocal) thr->eatom_imprp[i4] +=  eimproperquarter;
+      }
+    }
+  }
+
+  if (imprp->vflag_either) {
+    double v[6];
+    v[0] = vb1x*f1[0] + vb2x*f3[0] + (vb3x+vb2x)*f4[0];
+    v[1] = vb1y*f1[1] + vb2y*f3[1] + (vb3y+vb2y)*f4[1];
+    v[2] = vb1z*f1[2] + vb2z*f3[2] + (vb3z+vb2z)*f4[2];
+    v[3] = vb1x*f1[1] + vb2x*f3[1] + (vb3x+vb2x)*f4[1];
+    v[4] = vb1x*f1[2] + vb2x*f3[2] + (vb3x+vb2x)*f4[2];
+    v[5] = vb1y*f1[2] + vb2y*f3[2] + (vb3y+vb2y)*f4[2];
+
+    if (imprp->vflag_global) {
+      if (newton_bond) {
+        v_tally(thr->virial_imprp,v);
+      } else {
+        int cnt = 0;
+        if (i1 < nlocal) ++cnt;
+        if (i2 < nlocal) ++cnt;
+        if (i3 < nlocal) ++cnt;
+        if (i4 < nlocal) ++cnt;
+        v_tally(thr->virial_imprp,0.25*static_cast<double>(cnt),v);
+      }
+    }
+
+    v[0] *= 0.25;
+    v[1] *= 0.25;
+    v[2] *= 0.25;
+    v[3] *= 0.25;
+    v[4] *= 0.25;
+    v[5] *= 0.25;
+
+    if (imprp->vflag_atom) {
+      if (newton_bond) {
+        v_tally(thr->vatom_imprp[i1],v);
+        v_tally(thr->vatom_imprp[i2],v);
+        v_tally(thr->vatom_imprp[i3],v);
+        v_tally(thr->vatom_imprp[i4],v);
+      } else {
+        if (i1 < nlocal) v_tally(thr->vatom_imprp[i1],v);
+        if (i2 < nlocal) v_tally(thr->vatom_imprp[i2],v);
+        if (i3 < nlocal) v_tally(thr->vatom_imprp[i3],v);
+        if (i4 < nlocal) v_tally(thr->vatom_imprp[i4],v);
+      }
+    }
+  }
+
+  // per-atom centroid virial
+  if (imprp->cvflag_atom) {
+    double f2[3], v1[9], v2[9], v3[9], v4[9];
+    double a1[3], a2[3], a3[3], a4[3];
+
+    // r0 = (r1+r2+r3+r4)/4
+    // rij = ri-rj
+    // total virial = r10*f1 + r20*f2 + r30*f3 + r40*f4
+    // vb1: r12
+    // vb2: r32
+    // vb3: r43
+
+    // a1 = r10 = (3*r12 - 2*r32 -   r43)/4
+    a1[0] = 0.25*(3*vb1x - 2*vb2x - vb3x);
+    a1[1] = 0.25*(3*vb1y - 2*vb2y - vb3y);
+    a1[2] = 0.25*(3*vb1z - 2*vb2z - vb3z);
+
+    // a2 = r20 = ( -r12 - 2*r32 -   r43)/4
+    a2[0] = 0.25*(-vb1x - 2*vb2x - vb3x);
+    a2[1] = 0.25*(-vb1y - 2*vb2y - vb3y);
+    a2[2] = 0.25*(-vb1z - 2*vb2z - vb3z);
+
+    // a3 = r30 = ( -r12 + 2*r32 -   r43)/4
+    a3[0] = 0.25*(-vb1x + 2*vb2x - vb3x);
+    a3[1] = 0.25*(-vb1y + 2*vb2y - vb3y);
+    a3[2] = 0.25*(-vb1z + 2*vb2z - vb3z);
+
+    // a4 = r40 = ( -r12 + 2*r32 + 3*r43)/4
+    a4[0] = 0.25*(-vb1x + 2*vb2x + 3*vb3x);
+    a4[1] = 0.25*(-vb1y + 2*vb2y + 3*vb3y);
+    a4[2] = 0.25*(-vb1z + 2*vb2z + 3*vb3z);
+
+    f2[0] = - f1[0] - f3[0] - f4[0];
+    f2[1] = - f1[1] - f3[1] - f4[1];
+    f2[2] = - f1[2] - f3[2] - f4[2];
+
+    v1[0] = a1[0]*f1[0];
+    v1[1] = a1[1]*f1[1];
+    v1[2] = a1[2]*f1[2];
+    v1[3] = a1[0]*f1[1];
+    v1[4] = a1[0]*f1[2];
+    v1[5] = a1[1]*f1[2];
+    v1[6] = a1[1]*f1[0];
+    v1[7] = a1[2]*f1[0];
+    v1[8] = a1[2]*f1[1];
+
+    v2[0] = a2[0]*f2[0];
+    v2[1] = a2[1]*f2[1];
+    v2[2] = a2[2]*f2[2];
+    v2[3] = a2[0]*f2[1];
+    v2[4] = a2[0]*f2[2];
+    v2[5] = a2[1]*f2[2];
+    v2[6] = a2[1]*f2[0];
+    v2[7] = a2[2]*f2[0];
+    v2[8] = a2[2]*f2[1];
+
+    v3[0] = a3[0]*f3[0];
+    v3[1] = a3[1]*f3[1];
+    v3[2] = a3[2]*f3[2];
+    v3[3] = a3[0]*f3[1];
+    v3[4] = a3[0]*f3[2];
+    v3[5] = a3[1]*f3[2];
+    v3[6] = a3[1]*f3[0];
+    v3[7] = a3[2]*f3[0];
+    v3[8] = a3[2]*f3[1];
+
+    v4[0] = a4[0]*f4[0];
+    v4[1] = a4[1]*f4[1];
+    v4[2] = a4[2]*f4[2];
+    v4[3] = a4[0]*f4[1];
+    v4[4] = a4[0]*f4[2];
+    v4[5] = a4[1]*f4[2];
+    v4[6] = a4[1]*f4[0];
+    v4[7] = a4[2]*f4[0];
+    v4[8] = a4[2]*f4[1];
+
+    if (newton_bond) {
+      v_tally9(thr->cvatom_imprp[i1],v1);
+      v_tally9(thr->cvatom_imprp[i2],v2);
+      v_tally9(thr->cvatom_imprp[i3],v3);
+      v_tally9(thr->cvatom_imprp[i4],v4);
+    } else {
+      if (i1 < nlocal) v_tally9(thr->cvatom_imprp[i1],v1);
+      if (i2 < nlocal) v_tally9(thr->cvatom_imprp[i2],v2);
+      if (i3 < nlocal) v_tally9(thr->cvatom_imprp[i3],v3);
+      if (i4 < nlocal) v_tally9(thr->cvatom_imprp[i4],v4);
+    }
+  }
+
+}
+
+/* ----------------------------------------------------------------------
+   tally virial into per-atom accumulators
+   called by AIREBO potential, newton_pair is always on
+   fpair is magnitude of force on atom I
+------------------------------------------------------------------------- */
+
+void ThrOMP::v_tally2_thr(Pair *const pair, const int i, const int j, const double fpair,
+                          const double * const drij, ThrData * const thr)
+{
+  double v[6];
+
+  v[0] = drij[0]*drij[0]*fpair;
+  v[1] = drij[1]*drij[1]*fpair;
+  v[2] = drij[2]*drij[2]*fpair;
+  v[3] = drij[0]*drij[1]*fpair;
+  v[4] = drij[0]*drij[2]*fpair;
+  v[5] = drij[1]*drij[2]*fpair;
+  if (pair->vflag_global) v_tally(thr->virial_pair,v);
+
+  if (pair->vflag_atom) {
+    v[0] *= 0.5;
+    v[1] *= 0.5;
+    v[2] *= 0.5;
+    v[3] *= 0.5;
+    v[4] *= 0.5;
+    v[5] *= 0.5;
+    v_tally(thr->vatom_pair[i],v);
+    v_tally(thr->vatom_pair[j],v);
+  }
+}
+
+/* ----------------------------------------------------------------------
+   tally virial into per-atom accumulators
+   called by RexaFF potential, newton_pair is always on
+   fi is magnitude of force on atom i, deli is the direction
+   note that the other atom (j) is not updated, due to newton on
+------------------------------------------------------------------------- */
+
+void ThrOMP::v_tally2_newton_thr(Pair *const pair, const int i, const double * const fi,
+                                 const double * const deli, ThrData * const thr)
+{
+  double v[6];
+
+  v[0] = deli[0]*fi[0];
+  v[1] = deli[1]*fi[1];
+  v[2] = deli[2]*fi[2];
+  v[3] = deli[0]*fi[1];
+  v[4] = deli[0]*fi[2];
+  v[5] = deli[1]*fi[2];
+  if (pair->vflag_global) v_tally(thr->virial_pair,v);
+  if (pair->vflag_atom) v_tally(thr->vatom_pair[i],v);
+}
+
+/* ----------------------------------------------------------------------
+   tally virial into per-atom accumulators
+   called by AIREBO and Tersoff potential, newton_pair is always on
+------------------------------------------------------------------------- */
+
+void ThrOMP::v_tally3_thr(Pair *const pair, const int i, const int j, const int k,
+                          const double * const fi, const double * const fj,
+                          const double * const drik, const double * const drjk,
+                          ThrData * const thr)
+{
+  double v[6];
+
+  v[0] = (drik[0]*fi[0] + drjk[0]*fj[0]);
+  v[1] = (drik[1]*fi[1] + drjk[1]*fj[1]);
+  v[2] = (drik[2]*fi[2] + drjk[2]*fj[2]);
+  v[3] = (drik[0]*fi[1] + drjk[0]*fj[1]);
+  v[4] = (drik[0]*fi[2] + drjk[0]*fj[2]);
+  v[5] = (drik[1]*fi[2] + drjk[1]*fj[2]);
+  if (pair->vflag_global) v_tally(thr->virial_pair,v);
+
+  if (pair->vflag_atom) {
+    v[0] *= THIRD;
+    v[1] *= THIRD;
+    v[2] *= THIRD;
+    v[3] *= THIRD;
+    v[4] *= THIRD;
+    v[5] *= THIRD;
+    v_tally(thr->vatom_pair[i],v);
+    v_tally(thr->vatom_pair[j],v);
+    v_tally(thr->vatom_pair[k],v);
+  }
+}
+
+/* ----------------------------------------------------------------------
+   tally virial into per-atom accumulators
+   called by AIREBO potential, newton_pair is always on
+------------------------------------------------------------------------- */
+
+void ThrOMP::v_tally4_thr(Pair *const pair, const int i, const int j, const int k, const int m,
+                          const double * const fi, const double * const fj,
+                          const double * const fk, const double * const drim,
+                          const double * const drjm, const double * const drkm,
+                          ThrData * const thr)
+{
+  double v[6];
+
+  v[0] = (drim[0]*fi[0] + drjm[0]*fj[0] + drkm[0]*fk[0]);
+  v[1] = (drim[1]*fi[1] + drjm[1]*fj[1] + drkm[1]*fk[1]);
+  v[2] = (drim[2]*fi[2] + drjm[2]*fj[2] + drkm[2]*fk[2]);
+  v[3] = (drim[0]*fi[1] + drjm[0]*fj[1] + drkm[0]*fk[1]);
+  v[4] = (drim[0]*fi[2] + drjm[0]*fj[2] + drkm[0]*fk[2]);
+  v[5] = (drim[1]*fi[2] + drjm[1]*fj[2] + drkm[1]*fk[2]);
+  if (pair->vflag_global) v_tally(thr->virial_pair,v);
+
+  if (pair->vflag_atom) {
+    v[0] *= 0.25;
+    v[1] *= 0.25;
+    v[2] *= 0.25;
+    v[3] *= 0.25;
+    v[4] *= 0.25;
+    v[5] *= 0.25;
+    v_tally(thr->vatom_pair[i],v);
+    v_tally(thr->vatom_pair[j],v);
+    v_tally(thr->vatom_pair[k],v);
+    v_tally(thr->vatom_pair[m],v);
+  }
+}
+
+/* ---------------------------------------------------------------------- */
+
+double ThrOMP::memory_usage_thr()
+{
+  double bytes=0.0;
+
+  return bytes;
+}
diff -ruN lammps-stable_2Aug2023/src/thr_omp.h ../lammps-stable_2Aug2023/src/thr_omp.h
--- lammps-stable_2Aug2023/src/thr_omp.h	1969-12-31 19:00:00.000000000 -0500
+++ ../lammps-stable_2Aug2023/src/thr_omp.h	2023-09-26 15:27:29.059979000 -0400
@@ -0,0 +1,225 @@
+/* -*- c++ -*- -------------------------------------------------------------
+   LAMMPS - Large-scale Atomic/Molecular Massively Parallel Simulator
+   https://www.lammps.org/, Sandia National Laboratories
+   LAMMPS development team: developers@lammps.org
+
+   Copyright (2003) Sandia Corporation.  Under the terms of Contract
+   DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government retains
+   certain rights in this software.  This software is distributed under
+   the GNU General Public License.
+
+   See the README file in the top-level LAMMPS directory.
+------------------------------------------------------------------------- */
+
+/* ----------------------------------------------------------------------
+   Contributing author: Axel Kohlmeyer (Temple U)
+------------------------------------------------------------------------- */
+
+#ifndef LMP_THR_OMP_H
+#define LMP_THR_OMP_H
+
+#if defined(_OPENMP)
+#include <omp.h>
+#endif
+#include "error.h"
+#include "fix_omp.h"    // IWYU pragma: export
+#include "pointers.h"
+#include "thr_data.h"    // IWYU pragma: export
+
+namespace LAMMPS_NS {
+
+// forward declarations
+class Pair;
+class Bond;
+class Angle;
+class Dihedral;
+class Improper;
+
+class ThrOMP {
+
+ protected:
+  LAMMPS *lmp;    // reference to base lammps object.
+  FixOMP *fix;    // pointer to fix_omp;
+
+  const int thr_style;
+  int thr_error;
+
+ public:
+  ThrOMP(LAMMPS *, int);
+  virtual ~ThrOMP() = default;
+
+  double memory_usage_thr();
+
+  inline void sync_threads()
+  {
+#if defined(_OPENMP)
+#pragma omp barrier
+#endif
+    {
+      ;
+    }
+  };
+
+  enum {
+    THR_NONE = 0,
+    THR_PAIR = 1,
+    THR_BOND = 1 << 1,
+    THR_ANGLE = 1 << 2,
+    THR_DIHEDRAL = 1 << 3,
+    THR_IMPROPER = 1 << 4,
+    THR_KSPACE = 1 << 5,
+    THR_CHARMM = 1 << 6, /*THR_PROXY=1<<7,THR_HYBRID=1<<8, */
+    THR_FIX = 1 << 9,
+    THR_INTGR = 1 << 10
+  };
+
+ protected:
+  // extra ev_tally setup work for threaded styles
+  void ev_setup_thr(int, int, int, double *, double **, double **, ThrData *);
+
+  // compute global per thread virial contribution from per-thread force
+  void virial_fdotr_compute_thr(double *const, const double *const *const,
+                                const double *const *const, const int, const int, const int);
+
+  // reduce per thread data as needed
+  void reduce_thr(void *const style, const int eflag, const int vflag, ThrData *const thr);
+
+  // thread safe variant error abort support.
+  // signals an error condition in any thread by making
+  // thr_error > 0, if condition "cond" is true.
+  // will abort from thread 0 if thr_error is > 0
+  // otherwise return true.
+  // returns false if no error found on any thread.
+  // use return value to jump/return to end of threaded region.
+
+  bool check_error_thr(const bool cond, const int tid, const char *fname, const int line,
+                       const char *errmsg)
+  {
+    if (cond) {
+#if defined(_OPENMP)
+#pragma omp atomic
+      ++thr_error;
+#endif
+      if (tid > 0)
+        return true;
+      else
+        lmp->error->one(fname, line, errmsg);
+    } else {
+      if (thr_error > 0) {
+        if (tid == 0)
+          lmp->error->one(fname, line, errmsg);
+        else
+          return true;
+      } else
+        return false;
+    }
+    return false;
+  };
+
+ protected:
+  // threading adapted versions of the ev_tally infrastructure
+  // style specific versions (need access to style class flags)
+
+  // Pair
+  void e_tally_thr(Pair *const, const int, const int, const int, const int, const double,
+                   const double, ThrData *const);
+  void v_tally_thr(Pair *const, const int, const int, const int, const int, const double *const,
+                   ThrData *const);
+
+  void ev_tally_thr(Pair *const, const int, const int, const int, const int, const double,
+                    const double, const double, const double, const double, const double,
+                    ThrData *const);
+  void ev_tally_full_thr(Pair *const, const int, const double, const double, const double,
+                         const double, const double, const double, ThrData *const);
+  void ev_tally_xyz_thr(Pair *const, const int, const int, const int, const int, const double,
+                        const double, const double, const double, const double, const double,
+                        const double, const double, ThrData *const);
+  void ev_tally_xyz_full_thr(Pair *const, const int, const double, const double, const double,
+                             const double, const double, const double, const double, const double,
+                             ThrData *const);
+  void v_tally2_thr(Pair *const, const int, const int, const double, const double *const,
+                    ThrData *const);
+  void v_tally2_newton_thr(Pair *const, const int, const double *const, const double *const,
+                           ThrData *const);
+  void ev_tally3_thr(Pair *const, const int, const int, const int, const double, const double,
+                     const double *const, const double *const, const double *const,
+                     const double *const, ThrData *const);
+  void v_tally3_thr(Pair *const, const int, const int, const int, const double *const,
+                    const double *const, const double *const, const double *const, ThrData *const);
+  void ev_tally4_thr(Pair *const, const int, const int, const int, const int, const double,
+                     const double *const, const double *const, const double *const,
+                     const double *const, const double *const, const double *const, ThrData *const);
+  void v_tally4_thr(Pair *const, const int, const int, const int, const int, const double *const,
+                    const double *const, const double *const, const double *const,
+                    const double *const, const double *const, ThrData *const);
+
+  // Bond
+  void ev_tally_thr(Bond *const, const int, const int, const int, const int, const double,
+                    const double, const double, const double, const double, ThrData *const);
+
+  // Angle
+  void ev_tally_thr(Angle *const, const int, const int, const int, const int, const int,
+                    const double, const double *const, const double *const, const double,
+                    const double, const double, const double, const double, const double,
+                    ThrData *const thr);
+  void ev_tally13_thr(Angle *const, const int, const int, const int, const int, const double,
+                      const double, const double, const double, const double, ThrData *const thr);
+
+  // Dihedral
+  void ev_tally_thr(Dihedral *const, const int, const int, const int, const int, const int,
+                    const int, const double, const double *const, const double *const,
+                    const double *const, const double, const double, const double, const double,
+                    const double, const double, const double, const double, const double,
+                    ThrData *const);
+
+  // Improper
+  void ev_tally_thr(Improper *const, const int, const int, const int, const int, const int,
+                    const int, const double, const double *const, const double *const,
+                    const double *const, const double, const double, const double, const double,
+                    const double, const double, const double, const double, const double,
+                    ThrData *const);
+
+  // style independent versions
+  void ev_tally_list_thr(Pair *const, const int, const int *const, const double *const,
+                         const double, const double, ThrData *const);
+};
+
+// set loop range thread id, and force array offset for threaded runs.
+static inline void loop_setup_thr(int &ifrom, int &ito, int &tid, int inum, int nthreads)
+{
+#if defined(_OPENMP)
+  tid = omp_get_thread_num();
+
+  // each thread works on a fixed chunk of atoms.
+  const int idelta = 1 + inum / nthreads;
+  ifrom = tid * idelta;
+  ito = ((ifrom + idelta) > inum) ? inum : ifrom + idelta;
+#else
+  tid = 0;
+  ifrom = 0;
+  ito = inum;
+  nthreads = 1;
+#endif
+}
+
+// helpful definitions to help compilers optimizing code better
+
+typedef struct {
+  double x, y, z;
+} dbl3_t;
+typedef struct {
+  double x, y, z, w;
+} dbl4_t;
+typedef struct {
+  int a, b, t;
+} int3_t;
+typedef struct {
+  int a, b, c, t;
+} int4_t;
+typedef struct {
+  int a, b, c, d, t;
+} int5_t;
+
+}    // namespace LAMMPS_NS
+
+#endif
diff -ruN lammps-stable_2Aug2023/src/velocity.cpp ../lammps-stable_2Aug2023/src/velocity.cpp
--- lammps-stable_2Aug2023/src/velocity.cpp	2023-08-03 11:33:14.000000000 -0400
+++ ../lammps-stable_2Aug2023/src/velocity.cpp	2024-04-04 15:47:28.693905362 -0400
@@ -31,6 +31,7 @@
 #include <cmath>
 #include <cstring>
 
+
 using namespace LAMMPS_NS;
 
 enum{CREATE,SET,SCALE,RAMP,ZERO};
