diff -ruN ../miniAMR-1.7.0/newversion/miniAMR.clean/.git/FETCH_HEAD ../miniAMR-1.7.0/newversion/miniAMR.ekg/.git/FETCH_HEAD
--- ../miniAMR-1.7.0/newversion/miniAMR.clean/.git/FETCH_HEAD	2023-10-18 12:50:00.085963000 -0400
+++ ../miniAMR-1.7.0/newversion/miniAMR.ekg/.git/FETCH_HEAD	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-5bf66c0f9a66dba30a8861d48c9b8f8ac446a040		branch 'master' of https://github.com/Mantevo/miniAMR
Binary files ../miniAMR-1.7.0/newversion/miniAMR.clean/.git/index and ../miniAMR-1.7.0/newversion/miniAMR.ekg/.git/index differ
diff -ruN ../miniAMR-1.7.0/newversion/miniAMR.clean/.git/logs/HEAD ../miniAMR-1.7.0/newversion/miniAMR.ekg/.git/logs/HEAD
--- ../miniAMR-1.7.0/newversion/miniAMR.clean/.git/logs/HEAD	2023-10-11 13:14:35.578763000 -0400
+++ ../miniAMR-1.7.0/newversion/miniAMR.ekg/.git/logs/HEAD	2023-10-11 13:15:29.112306000 -0400
@@ -1 +1 @@
-0000000000000000000000000000000000000000 5bf66c0f9a66dba30a8861d48c9b8f8ac446a040 x-joncook <x-joncook@login04.anvil.rcac.purdue.edu> 1697044475 -0400	clone: from https://github.com/Mantevo/miniAMR.git
+0000000000000000000000000000000000000000 5bf66c0f9a66dba30a8861d48c9b8f8ac446a040 x-joncook <x-joncook@login04.anvil.rcac.purdue.edu> 1697044529 -0400	clone: from https://github.com/Mantevo/miniAMR.git
diff -ruN ../miniAMR-1.7.0/newversion/miniAMR.clean/.git/logs/refs/heads/master ../miniAMR-1.7.0/newversion/miniAMR.ekg/.git/logs/refs/heads/master
--- ../miniAMR-1.7.0/newversion/miniAMR.clean/.git/logs/refs/heads/master	2023-10-11 13:14:35.579977000 -0400
+++ ../miniAMR-1.7.0/newversion/miniAMR.ekg/.git/logs/refs/heads/master	2023-10-11 13:15:29.128759000 -0400
@@ -1 +1 @@
-0000000000000000000000000000000000000000 5bf66c0f9a66dba30a8861d48c9b8f8ac446a040 x-joncook <x-joncook@login04.anvil.rcac.purdue.edu> 1697044475 -0400	clone: from https://github.com/Mantevo/miniAMR.git
+0000000000000000000000000000000000000000 5bf66c0f9a66dba30a8861d48c9b8f8ac446a040 x-joncook <x-joncook@login04.anvil.rcac.purdue.edu> 1697044529 -0400	clone: from https://github.com/Mantevo/miniAMR.git
diff -ruN ../miniAMR-1.7.0/newversion/miniAMR.clean/.git/logs/refs/remotes/origin/HEAD ../miniAMR-1.7.0/newversion/miniAMR.ekg/.git/logs/refs/remotes/origin/HEAD
--- ../miniAMR-1.7.0/newversion/miniAMR.clean/.git/logs/refs/remotes/origin/HEAD	2023-10-11 13:14:35.576234000 -0400
+++ ../miniAMR-1.7.0/newversion/miniAMR.ekg/.git/logs/refs/remotes/origin/HEAD	2023-10-11 13:15:29.106598000 -0400
@@ -1 +1 @@
-0000000000000000000000000000000000000000 5bf66c0f9a66dba30a8861d48c9b8f8ac446a040 x-joncook <x-joncook@login04.anvil.rcac.purdue.edu> 1697044475 -0400	clone: from https://github.com/Mantevo/miniAMR.git
+0000000000000000000000000000000000000000 5bf66c0f9a66dba30a8861d48c9b8f8ac446a040 x-joncook <x-joncook@login04.anvil.rcac.purdue.edu> 1697044529 -0400	clone: from https://github.com/Mantevo/miniAMR.git
diff -ruN ../miniAMR-1.7.0/newversion/miniAMR.clean/.git/ORIG_HEAD ../miniAMR-1.7.0/newversion/miniAMR.ekg/.git/ORIG_HEAD
--- ../miniAMR-1.7.0/newversion/miniAMR.clean/.git/ORIG_HEAD	2023-10-18 12:50:00.093120254 -0400
+++ ../miniAMR-1.7.0/newversion/miniAMR.ekg/.git/ORIG_HEAD	1969-12-31 19:00:00.000000000 -0500
@@ -1 +0,0 @@
-5bf66c0f9a66dba30a8861d48c9b8f8ac446a040
diff -ruN ../miniAMR-1.7.0/newversion/miniAMR.clean/openmp/main.c ../miniAMR-1.7.0/newversion/miniAMR.ekg/openmp/main.c
--- ../miniAMR-1.7.0/newversion/miniAMR.clean/openmp/main.c	2023-10-11 13:14:35.602324483 -0400
+++ ../miniAMR-1.7.0/newversion/miniAMR.ekg/openmp/main.c	2023-10-11 13:20:53.233516000 -0400
@@ -35,6 +35,10 @@
 #include "timer.h"
 #include "proto.h"
 
+#if defined APPEKG
+#include <appekg.h>
+#endif
+
 int main(int argc, char** argv)
 {
    int i, ierr, object_num;
@@ -48,6 +52,17 @@
    ierr = MPI_Comm_rank(MPI_COMM_WORLD, &my_pe);
    ierr = MPI_Comm_size(MPI_COMM_WORLD, &num_pes);
 
+#if defined APPEKG
+   int appekg_myrank;
+   MPI_Comm_rank(MPI_COMM_WORLD, &appekg_myrank);
+   EKG_INITIALIZE(5, 1, 2, 0, appekg_myrank, 1);
+   EKG_NAME_HEARTBEAT(1,"AllocateBlock");
+   EKG_NAME_HEARTBEAT(2,"TimestepStage");
+   EKG_NAME_HEARTBEAT(3,"RefineStep");
+   EKG_NAME_HEARTBEAT(4,"DeallocateBlock");
+   EKG_NAME_HEARTBEAT(5,"CheckObjects");
+#endif
+
    t1 = timer();
    counter_malloc = 0;
    size_malloc = 0.0;
@@ -365,6 +380,9 @@
    MPI_Barrier(MPI_COMM_WORLD);
 
    MPI_Finalize();
+#if defined APPEKG
+   EKG_FINALIZE();
+#endif
 
    exit(0);
 }
@@ -438,6 +456,9 @@
                                 __FILE__, __LINE__);
 
    for (n = 0; n < max_num_blocks; n++) {
+#ifdef APPEKG
+      EKG_BEGIN_HEARTBEAT(1,100);
+#endif
       blocks[n].number = -1;
       blocks[n].array = (double ****) ma_malloc(num_vars*sizeof(double ***),
                                                 __FILE__, __LINE__);
@@ -455,6 +476,9 @@
                                                __FILE__, __LINE__);
          }
       }
+#ifdef APPEKG
+      EKG_END_HEARTBEAT(1);
+#endif
    }
 
    sorted_list = (sorted_block *)ma_malloc(max_num_blocks*sizeof(sorted_block),
@@ -619,6 +643,9 @@
    int i, j, m, n;
 
    for (n = 0; n < max_num_blocks; n++) {
+#ifdef APPEKG
+      EKG_BEGIN_HEARTBEAT(4,25);
+#endif
       for (m = 0; m < num_vars; m++) {
          for (i = 0; i < x_block_size+2; i++) {
             for (j = 0; j < y_block_size+2; j++)
@@ -628,6 +655,9 @@
          free(blocks[n].array[m]);
       }
       free(blocks[n].array);
+#ifdef APPEKG
+      EKG_END_HEARTBEAT(4);
+#endif
    }
    free(blocks);
 
diff -ruN ../miniAMR-1.7.0/newversion/miniAMR.clean/openmp/Makefile ../miniAMR-1.7.0/newversion/miniAMR.ekg/openmp/Makefile
--- ../miniAMR-1.7.0/newversion/miniAMR.clean/openmp/Makefile	2023-10-11 13:14:35.584297000 -0400
+++ ../miniAMR-1.7.0/newversion/miniAMR.ekg/openmp/Makefile	2023-10-11 13:53:01.283851000 -0400
@@ -5,20 +5,35 @@
 LDFLAGS =
 LDLIBS = -lm -lgomp
 
-EXEC = miniAMR.x
+#-----------------------------------------------------------------------
+# APPEKG Section
+# JEC: choose to build with APPEKG or not, and specify where
+#      to find APPEKG stuff
+APPEKGDIR = /anvil/projects/x-cis230165/tools/ghappekg/
+DO_APPEKG = ON
+
+ifeq ($(DO_APPEKG),ON)
+APPEKGCFLAGS = -DAPPEKG -I${APPEKGDIR}
+APPEKGLDOBJ = -L${APPEKGDIR} -lappekg -lpthread -lrt
+else
+APPEKGCFLAGS =
+APPEKGLDOBJ =
+endif
+
+EXEC = miniAMRomp.x
 
 OBJS = block.o check_sum.o comm_block.o comm.o comm_parent.o comm_refine.o \
        comm_util.o driver.o init.o main.o move.o pack.o plot.o profile.o \
        rcb.o refine.o sfc.o stencil.o util.o
 
 $(EXEC): $(OBJS)
-	$(LD) $(LDFLAGS) -o $@ $(OBJS) $(LDLIBS)
+	$(LD) $(LDFLAGS) -o $@ $(OBJS) $(LDLIBS) $(APPEKGLDOBJ)
 
 .c.o:
-	$(CC) $(CPPFLAGS) $(CFLAGS) -c $<
+	$(CC) $(CPPFLAGS) $(CFLAGS) $(APPEKGCFLAGS) -c $<
 
 clean:
-	rm *.o miniAMR.x
+	rm *.o *.x
 
 # need dependencies
 
diff -ruN ../miniAMR-1.7.0/newversion/miniAMR.clean/openmp/move.c ../miniAMR-1.7.0/newversion/miniAMR.ekg/openmp/move.c
--- ../miniAMR-1.7.0/newversion/miniAMR.clean/openmp/move.c	2023-10-11 13:14:35.603088307 -0400
+++ ../miniAMR-1.7.0/newversion/miniAMR.ekg/openmp/move.c	2023-10-11 13:21:17.325502000 -0400
@@ -32,6 +32,10 @@
 #include "comm.h"
 #include "proto.h"
 
+#if defined APPEKG
+#include <appekg.h>
+#endif
+
 // This routine moves the objects that determine the refinement and checks
 // the blocks against those objects to determine which blocks will refine.
 void move(double delta)
@@ -76,6 +80,9 @@
    #pragma omp parallel for shared(sorted_index, num_refine, blocks, sorted_list, p2, mesh_size, refine_ghost, x_block_size, y_block_size, z_block_size, my_pe, parents)
    for(int in = 0; in < sorted_index[num_refine+1]; in++) {
       double cor[3][2]; /* extent of block */
+#ifdef APPEKG
+      EKG_BEGIN_HEARTBEAT(5,20);
+#endif
       block* bp = &blocks[sorted_list[in].n];
       int sz = p2[num_refine - bp->level]; /* half size of block */
       cor[0][0] = ((double) (bp->cen[0] - sz))/((double) mesh_size[0]);
@@ -135,6 +142,9 @@
       /* if 0 level, we can not unrefine */
       if (!bp->level && bp->refine == -1)
          bp->refine = 0;
+#ifdef APPEKG
+      EKG_END_HEARTBEAT(5);
+#endif
    }
 }
 
diff -ruN ../miniAMR-1.7.0/newversion/miniAMR.clean/openmp/refine.c ../miniAMR-1.7.0/newversion/miniAMR.ekg/openmp/refine.c
--- ../miniAMR-1.7.0/newversion/miniAMR.clean/openmp/refine.c	2023-10-11 13:14:35.607503648 -0400
+++ ../miniAMR-1.7.0/newversion/miniAMR.ekg/openmp/refine.c	2023-10-11 13:21:34.287576000 -0400
@@ -33,6 +33,10 @@
 #include "proto.h"
 #include "timer.h"
 
+#if defined APPEKG
+#include <appekg.h>
+#endif
+
 // This file contains routines that determine which blocks are going to
 // be refined and which are going to be coarsened.
 void refine(int ts)
@@ -59,6 +63,9 @@
       num_refine_step = num_refine;
 
    for (i = 0; i < num_refine_step; i++) {
+#ifdef APPEKG
+      EKG_BEGIN_HEARTBEAT(3,100);
+#endif
       for (j = num_refine; j >= 0; j--)
          if (num_blocks[j]) {
             cur_max_level = j;
@@ -165,6 +172,9 @@
             t4 += timer() - t2;
          }
       }
+#ifdef APPEKG
+      EKG_END_HEARTBEAT(3);
+#endif
    }
    timer_rs_pa += tp1;
    timer_rs_mv += tm1;
diff -ruN ../miniAMR-1.7.0/newversion/miniAMR.clean/openmp/st.c ../miniAMR-1.7.0/newversion/miniAMR.ekg/openmp/st.c
--- ../miniAMR-1.7.0/newversion/miniAMR.clean/openmp/st.c	1969-12-31 19:00:00.000000000 -0500
+++ ../miniAMR-1.7.0/newversion/miniAMR.ekg/openmp/st.c	2023-10-11 13:22:16.674704000 -0400
@@ -0,0 +1,1020 @@
+// ************************************************************************
+//
+// miniAMR: stencil computations with boundary exchange and AMR.
+//
+// Copyright (2014) Sandia Corporation. Under the terms of Contract
+// DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government 
+// retains certain rights in this software.
+//
+// This library is free software; you can redistribute it and/or modify
+// it under the terms of the GNU Lesser General Public License as
+// published by the Free Software Foundation; either version 2.1 of the
+// License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful, but
+// WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA
+// Questions? Contact Courtenay T. Vaughan (ctvaugh@sandia.gov)
+//                    Richard F. Barrett (rfbarre@sandia.gov)
+//
+// ************************************************************************
+
+#include <mpi.h>
+#include <math.h>
+
+#include "block.h"
+#include "comm.h"
+#include "proto.h"
+
+void stencil_calc(int, int);
+void stencil_0(int);
+void stencil_x(int);
+void stencil_y(int);
+void stencil_z(int);
+void stencil_7(int);
+void stencil_27(int);
+void stencil_check(int);
+
+// This routine does the stencil calculations.
+void stencil_driver(int var, int cacl_stage)
+{
+   if (stencil)
+      stencil_calc(var, stencil);
+   else {
+      if (!var)
+         stencil_calc(var, 7);
+      else if (var < 4*mat) {
+         switch (cacl_stage%6) {
+         case 0:
+            stencil_0(var);
+            break;
+         case 1:
+            stencil_x(var);
+            break;
+         case 2:
+            stencil_y(var);
+            break;
+         case 3:
+            stencil_z(var);
+            break;
+         case 4:
+            stencil_7(var);
+            break;
+         case 5:
+            stencil_27(var);
+            break;
+         }
+         stencil_check(var);
+      } else
+         stencil_calc(var, 7);
+   }
+}
+
+void stencil_calc(int var, int stencil_in)
+{
+   int i, j, k;
+
+   if (stencil_in == 7) {
+      // Parallelize
+      #pragma omp parallel for shared(sorted_index, num_refine, blocks, sorted_list, x_block_size, y_block_size, z_block_size)
+      for(int in = 0; in < sorted_index[num_refine+1]; in++) {
+         block* bp = &blocks[sorted_list[in].n];
+         double work[x_block_size+2][y_block_size+2][z_block_size+2];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  work[i][j][k] = (bp->array[var][i-1][j  ][k  ] +
+                                   bp->array[var][i  ][j-1][k  ] +
+                                   bp->array[var][i  ][j  ][k-1] +
+                                   bp->array[var][i  ][j  ][k  ] +
+                                   bp->array[var][i  ][j  ][k+1] +
+                                   bp->array[var][i  ][j+1][k  ] +
+                                   bp->array[var][i+1][j  ][k  ])/7.0;
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  bp->array[var][i][j][k] = work[i][j][k];
+      }
+      total_fp_divs += (double) num_active*num_cells;
+      total_fp_adds += (double) 6*num_active*num_cells;
+   } else {
+      // Parallelize
+      #pragma omp parallel for shared(sorted_index, num_refine, blocks, sorted_list, x_block_size, y_block_size, z_block_size)
+      for(int in = 0; in < sorted_index[num_refine+1]; in++) {
+         block* bp = &blocks[sorted_list[in].n];
+         double sb, sm, sf, work[x_block_size+2][y_block_size+2][z_block_size+2];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++) {
+                  sb = bp->array[var][i-1][j-1][k-1] +
+                       bp->array[var][i-1][j-1][k  ] +
+                       bp->array[var][i-1][j-1][k+1] +
+                       bp->array[var][i-1][j  ][k-1] +
+                       bp->array[var][i-1][j  ][k  ] +
+                       bp->array[var][i-1][j  ][k+1] +
+                       bp->array[var][i-1][j+1][k-1] +
+                       bp->array[var][i-1][j+1][k  ] +
+                       bp->array[var][i-1][j+1][k+1];
+                  sm = bp->array[var][i  ][j-1][k-1] +
+                       bp->array[var][i  ][j-1][k  ] +
+                       bp->array[var][i  ][j-1][k+1] +
+                       bp->array[var][i  ][j  ][k-1] +
+                       bp->array[var][i  ][j  ][k  ] +
+                       bp->array[var][i  ][j  ][k+1] +
+                       bp->array[var][i  ][j+1][k-1] +
+                       bp->array[var][i  ][j+1][k  ] +
+                       bp->array[var][i  ][j+1][k+1];
+                  sf = bp->array[var][i+1][j-1][k-1] +
+                       bp->array[var][i+1][j-1][k  ] +
+                       bp->array[var][i+1][j-1][k+1] +
+                       bp->array[var][i+1][j  ][k-1] +
+                       bp->array[var][i+1][j  ][k  ] +
+                       bp->array[var][i+1][j  ][k+1] +
+                       bp->array[var][i+1][j+1][k-1] +
+                       bp->array[var][i+1][j+1][k  ] +
+                       bp->array[var][i+1][j+1][k+1];
+                  work[i][j][k] = (sb + sm + sf)/27.0;
+               }
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  bp->array[var][i][j][k] = work[i][j][k];
+      }
+      total_fp_divs += (double) num_active*num_cells;
+      total_fp_adds += (double) 26*num_active*num_cells;
+   }
+}
+
+void stencil_0(int var)
+{
+   int in, i, j, k, v;
+   block *bp;
+
+   if (var == 1) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  for (v = mat; v < 2*mat; v++)
+                     bp->array[var][i][j][k] += bp->array[v][i][j][k]*
+                                                bp->array[0][i][j][k];
+      }
+      total_fp_adds += (double) mat*num_active*num_cells;
+      total_fp_muls += (double) mat*num_active*num_cells;
+    } else if (var < mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  bp->array[var][i][j][k] += bp->array[var][i][j][k]*
+                                             (bp->array[0][i][j][k] +
+                                              bp->array[1][i][j][k] -
+                                              a1*bp->array[var][i][j][k]);
+      }
+      total_fp_adds += (double) 3*num_active*num_cells;
+      total_fp_muls += (double) 2*num_active*num_cells;
+   } else if (var < 2*mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  bp->array[var][i][j][k] = bp->array[var][i][j][k]*
+                                            (bp->array[0][i][j][k] +
+                                             bp->array[var][i][j][k] +
+                                             a1*bp->array[var+mat][i][j][k] +
+                                       (1.0-a1)*bp->array[var+2*mat][i][j][k])/
+                                            bp->array[1][i][j][k];
+      }
+      total_fp_adds += (double) 3*num_active*num_cells;
+      total_fp_muls += (double) 3*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else if (var < 3*mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  bp->array[var][i][j][k] += bp->array[var-mat][i][j][k]*
+                                             (a1*bp->array[0][i][j][k] +
+                                        a0[var-2*mat]*bp->array[var][i][j][k] +
+                                         (1.0-a1)*bp->array[var+mat][i][j][k])/
+                                             bp->array[1][i][j][k];
+         }
+      total_fp_adds += (double) 4*num_active*num_cells;
+      total_fp_muls += (double) 3*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  bp->array[var][i][j][k] += bp->array[var-2*mat][i][j][k]*
+                                             (a1*bp->array[0][i][j][k] +
+                                        a0[var-3*mat]*bp->array[var][i][j][k] +
+                              (1.0-a0[var-3*mat])*bp->array[var-mat][i][j][k] +
+                                       (1.0-a1)*bp->array[var-2*mat][i][j][k])/
+                                             (bp->array[1][i][j][k]*
+                                              bp->array[1][i][j][k]);
+         }
+      total_fp_adds += (double) 6*num_active*num_cells;
+      total_fp_muls += (double) 6*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   }
+}
+
+void stencil_x(int var)
+{
+   int in, i, j, k, v;
+   double tmp1, tmp2;
+   block *bp;
+
+   if (var == 1) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++) {
+                  for (v = 2; v < mat+2; v++)
+                     bp->array[1][i][j][k] += bp->array[v][i][j][k]*
+                                              bp->array[0][i][j][k];
+                  bp->array[1][i][j][k] /= (a1 + bp->array[1][i][j][k]);
+               }
+      }
+      total_fp_adds += (double) (mat+1)*num_active*num_cells;
+      total_fp_muls += (double) mat*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else if (var < mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  bp->array[var][i][j][k] += bp->array[var][i][j][k]*
+                                             (bp->array[0][i][j][k] +
+                                              bp->array[1][i][j][k] -
+                                              a1*bp->array[var][i][j][k])/
+                                             (a0[var] + bp->array[1][i][j][k]);
+      }
+      total_fp_adds += (double) 4*num_active*num_cells;
+      total_fp_muls += (double) 2*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else if (var < 2*mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v, tmp1, tmp2)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  if ((tmp1 = fabs(bp->array[var][i][j][k] -
+                                   bp->array[var][i-1][j][k])) >
+                      (tmp2 = fabs(bp->array[var][i][j][k] -
+                                   bp->array[var][i+1][j][k])))
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i-1][j][k] +
+                                         (tmp1-tmp2)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i+1][j][k])/
+                                              (a1 + a0[var-mat] +
+                                               bp->array[var][i-1][j][k] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i+1][j][k] +
+                                               bp->array[0][i][j][k] +
+                                               bp->array[1][i][j][k]);
+                  else
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i-1][j][k] +
+                                         (tmp2-tmp1)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i+1][j][k])/
+                                              (a1 + a0[var-mat] +
+                                               bp->array[var][i-1][j][k] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i+1][j][k] +
+                                               bp->array[0][i][j][k] +
+                                               bp->array[1][i][j][k]);
+      }
+      total_fp_adds += (double) 12*num_active*num_cells;
+      total_fp_muls += (double) 3*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else if (var < 3*mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v, tmp1, tmp2)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  if ((tmp1 = fabs(bp->array[var-mat][i][j][k] -
+                                   bp->array[var-mat][i-1][j][k])) >
+                      (tmp2 = fabs(bp->array[var-mat][i][j][k] -
+                                   bp->array[var-mat][i+1][j][k])))
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i-1][j][k] +
+                                         (tmp1-tmp2)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i+1][j][k])/
+                                              (a1 + a0[var-2*mat] +
+                                               bp->array[var-mat][i][j][k] +
+                                               bp->array[var+mat][i][j][k] +
+                                               bp->array[var][i-1][j][k] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i+1][j][k]);
+                  else
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i-1][j][k] +
+                                         (tmp2-tmp1)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i+1][j][k])/
+                                              (a1 + a0[var-2*mat] +
+                                               bp->array[var-mat][i][j][k] +
+                                               bp->array[var+mat][i][j][k] +
+                                               bp->array[var][i-1][j][k] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i+1][j][k]);
+      }
+      total_fp_adds += (double) 12*num_active*num_cells;
+      total_fp_muls += (double) 3*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v, tmp1, tmp2)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  if ((tmp1 = fabs(bp->array[var-2*mat][i][j][k] -
+                                   bp->array[var-2*mat][i-1][j][k])) >
+                      (tmp2 = fabs(bp->array[var-2*mat][i][j][k] -
+                                   bp->array[var-2*mat][i+1][j][k])))
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i-1][j][k] +
+                                         (tmp1-tmp2)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i+1][j][k])/
+                                              (a1 + a0[var-3*mat] +
+                                               bp->array[var-mat][i][j][k] +
+                                               bp->array[var-2*mat][i][j][k] +
+                                               bp->array[var][i-1][j][k] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i+1][j][k]);
+                  else
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i-1][j][k] +
+                                         (tmp2-tmp1)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i+1][j][k])/
+                                              (a1 + a0[var-3*mat] +
+                                               bp->array[var-mat][i][j][k] +
+                                               bp->array[var-2*mat][i][j][k] +
+                                               bp->array[var][i-1][j][k] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i+1][j][k]);
+      }
+      total_fp_adds += (double) 12*num_active*num_cells;
+      total_fp_muls += (double) 3*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   }
+}
+
+void stencil_y(int var)
+{
+   int in, i, j, k, v;
+   double tmp1, tmp2;
+   block *bp;
+
+   if (var == 1) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v, tmp1, tmp2)
+      {
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++) {
+                  for (v = 2; v < mat+2; v++)
+                     bp->array[1][i][j][k] += bp->array[v][i][j][k]*
+                                              bp->array[0][i][j][k];
+                  bp->array[1][i][j][k] /= (a1 + bp->array[1][i][j][k]);
+               }
+      }
+      }
+      total_fp_adds += (double) (mat+1)*num_active*num_cells;
+      total_fp_muls += (double) mat*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else if (var < mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v, tmp1, tmp2)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  bp->array[var][i][j][k] += bp->array[var][i][j][k]*
+                                             (bp->array[0][i][j][k] +
+                                              bp->array[1][i][j][k] -
+                                              a1*bp->array[var][i][j][k])/
+                                             (a0[var] + bp->array[1][i][j][k]);
+      }
+      total_fp_adds += (double) 4*num_active*num_cells;
+      total_fp_muls += (double) 2*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else if (var < 2*mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v, tmp1, tmp2)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  if ((tmp1 = fabs(bp->array[var][i][j][k] -
+                                   bp->array[var][i][j-1][k])) >
+                      (tmp2 = fabs(bp->array[var][i][j][k] -
+                                   bp->array[var][i][j+1][k])))
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i][j-1][k] +
+                                         (tmp1-tmp2)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i][j+1][k])/
+                                              (a1 + a0[var-mat] +
+                                               bp->array[var][i][j-1][k] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i][j+1][k] +
+                                               bp->array[0][i][j][k] +
+                                               bp->array[1][i][j][k]);
+                  else
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i][j-1][k] +
+                                         (tmp2-tmp1)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i][j+1][k])/
+                                              (a1 + a0[var-mat] +
+                                               bp->array[var][i][j-1][k] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i][j+1][k] +
+                                               bp->array[0][i][j][k] +
+                                               bp->array[1][i][j][k]);
+      }
+      total_fp_adds += (double) 12*num_active*num_cells;
+      total_fp_muls += (double) 3*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else if (var < 3*mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v, tmp1, tmp2)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  if ((tmp1 = fabs(bp->array[var-mat][i][j][k] -
+                                   bp->array[var-mat][i][j-1][k])) >
+                      (tmp2 = fabs(bp->array[var-mat][i][j][k] -
+                                   bp->array[var-mat][i][j+1][k])))
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i][j-1][k] +
+                                         (tmp1-tmp2)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i][j+1][k])/
+                                              (a1 + a0[var-2*mat] +
+                                               bp->array[var-mat][i][j][k] +
+                                               bp->array[var+mat][i][j][k] +
+                                               bp->array[var][i][j-1][k] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i][j+1][k]);
+                  else
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i][j-1][k] +
+                                         (tmp2-tmp1)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i][j+1][k])/
+                                              (a1 + a0[var-2*mat] +
+                                               bp->array[var-mat][i][j][k] +
+                                               bp->array[var+mat][i][j][k] +
+                                               bp->array[var][i][j-1][k] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i][j+1][k]);
+      }
+      total_fp_adds += (double) 12*num_active*num_cells;
+      total_fp_muls += (double) 3*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v, tmp1, tmp2)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  if ((tmp1 = fabs(bp->array[var-2*mat][i][j][k] -
+                                   bp->array[var-2*mat][i][j-1][k])) >
+                      (tmp2 = fabs(bp->array[var-2*mat][i][j][k] -
+                                   bp->array[var-2*mat][i][j+1][k])))
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i][j-1][k] +
+                                         (tmp1-tmp2)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i][j+1][k])/
+                                              (a1 + a0[var-3*mat] +
+                                               bp->array[var-mat][i][j][k] +
+                                               bp->array[var-2*mat][i][j][k] +
+                                               bp->array[var][i][j-1][k] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i][j+1][k]);
+                  else
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i][j-1][k] +
+                                         (tmp2-tmp1)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i][j+1][k])/
+                                              (a1 + a0[var-3*mat] +
+                                               bp->array[var-mat][i][j][k] +
+                                               bp->array[var-2*mat][i][j][k] +
+                                               bp->array[var][i][j-1][k] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i][j+1][k]);
+      }
+      total_fp_adds += (double) 12*num_active*num_cells;
+      total_fp_muls += (double) 3*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   }
+}
+
+void stencil_z(int var)
+{
+   int in, i, j, k, v;
+   double tmp1, tmp2;
+   block *bp;
+
+
+   if (var == 1) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v, tmp1, tmp2)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++) {
+                  for (v = 2; v < mat+2; v++)
+                     bp->array[1][i][j][k] += bp->array[v][i][j][k]*
+                                              bp->array[0][i][j][k];
+                  bp->array[1][i][j][k] /= (a1 + bp->array[1][i][j][k]);
+               }
+      }
+      total_fp_adds += (double) (mat+1)*num_active*num_cells;
+      total_fp_muls += (double) mat*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else if (var < mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v, tmp1, tmp2)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  bp->array[var][i][j][k] += bp->array[var][i][j][k]*
+                                             (bp->array[0][i][j][k] +
+                                              bp->array[1][i][j][k] -
+                                              a1*bp->array[var][i][j][k])/
+                                             (a0[var] + bp->array[1][i][j][k]);
+      }
+      total_fp_adds += (double) 4*num_active*num_cells;
+      total_fp_muls += (double) 2*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else if (var < 2*mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v, tmp1, tmp2)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  if ((tmp1 = fabs(bp->array[var][i][j][k] -
+                                   bp->array[var][i][j][k-1])) >
+                      (tmp2 = fabs(bp->array[var][i][j][k] -
+                                   bp->array[var][i][j][k+1])))
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i][j][k-1] +
+                                         (tmp1-tmp2)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i][j][k+1])/
+                                              (a1 + a0[var-mat] +
+                                               bp->array[var][i][j][k-1] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i][j][k+1] +
+                                               bp->array[0][i][j][k] +
+                                               bp->array[1][i][j][k]);
+                  else
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i][j][k-1] +
+                                         (tmp2-tmp1)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i][j][k+1])/
+                                              (a1 + a0[var-mat] +
+                                               bp->array[var][i][j][k-1] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i][j][k+1] +
+                                               bp->array[0][i][j][k] +
+                                               bp->array[1][i][j][k]);
+      }
+      total_fp_adds += (double) 12*num_active*num_cells;
+      total_fp_muls += (double) 3*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else if (var < 3*mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v, tmp1, tmp2)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  if ((tmp1 = fabs(bp->array[var-mat][i][j][k] -
+                                   bp->array[var-mat][i][j][k-1])) >
+                      (tmp2 = fabs(bp->array[var-mat][i][j][k] -
+                                   bp->array[var-mat][i][j][k+1])))
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i][j][k-1] +
+                                         (tmp1-tmp2)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i][j][k+1])/
+                                              (a1 + a0[var-2*mat] +
+                                               bp->array[var-mat][i][j][k] +
+                                               bp->array[var+mat][i][j][k] +
+                                               bp->array[var][i][j][k-1] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i][j][k+1]);
+                  else
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i][j][k-1] +
+                                         (tmp2-tmp1)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i][j][k+1])/
+                                              (a1 + a0[var-2*mat] +
+                                               bp->array[var-mat][i][j][k] +
+                                               bp->array[var+mat][i][j][k] +
+                                               bp->array[var][i][j][k-1] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i][j][k+1]);
+      }
+      total_fp_adds += (double) 12*num_active*num_cells;
+      total_fp_muls += (double) 3*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v, tmp1, tmp2)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  if ((tmp1 = fabs(bp->array[var-2*mat][i][j][k] -
+                                   bp->array[var-2*mat][i][j][k-1])) >
+                      (tmp2 = fabs(bp->array[var-2*mat][i][j][k] -
+                                   bp->array[var-2*mat][i][j][k+1])))
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i][j][k-1] +
+                                         (tmp1-tmp2)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i][j][k+1])/
+                                              (a1 + a0[var-3*mat] +
+                                               bp->array[var-mat][i][j][k] +
+                                               bp->array[var-2*mat][i][j][k] +
+                                               bp->array[var][i][j][k-1] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i][j][k+1]);
+                  else
+                    bp->array[var][i][j][k] = (tmp1*bp->array[var][i][j][k-1] +
+                                         (tmp2-tmp1)*(bp->array[var][i][j][k] +
+                                                       bp->array[1][i][j][k]) +
+                                               tmp2*bp->array[var][i][j][k+1])/
+                                              (a1 + a0[var-3*mat] +
+                                               bp->array[var-mat][i][j][k] +
+                                               bp->array[var-2*mat][i][j][k] +
+                                               bp->array[var][i][j][k-1] +
+                                               bp->array[var][i][j][k] +
+                                               bp->array[var][i][j][k+1]);
+      }
+      total_fp_adds += (double) 12*num_active*num_cells;
+      total_fp_muls += (double) 3*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   }
+}
+
+void stencil_7(int var)
+{
+   int in, i, j, k, v;
+   double work[x_block_size+2][y_block_size+2][z_block_size+2];
+   block *bp;
+
+   if (var < mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  work[i][j][k] = (bp->array[var      ][i-1][j  ][k  ]*
+                                   bp->array[var+  mat][i-1][j  ][k  ] +
+                                   bp->array[var      ][i  ][j-1][k  ]*
+                                   bp->array[var+2*mat][i  ][j-1][k  ] +
+                                   bp->array[var      ][i  ][j  ][k-1]*
+                                   bp->array[var+3*mat][i  ][j  ][k-1] +
+                                   bp->array[var      ][i  ][j  ][k  ]*
+                                   bp->array[var      ][i  ][j  ][k  ] +
+                                   bp->array[var      ][i  ][j  ][k+1]*
+                                   bp->array[var+3*mat][i  ][j  ][k+1] +
+                                   bp->array[var      ][i  ][j+1][k  ]*
+                                   bp->array[var+2*mat][i  ][j+1][k  ] +
+                                   bp->array[var      ][i+1][j  ][k  ]*
+                                   bp->array[var+  mat][i+1][j  ][k  ])/
+                                   7.0*(a1 + bp->array[var][i][j][k]);
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  bp->array[var][i][j][k] = work[i][j][k];
+      }
+      total_fp_adds += (double) 7*num_active*num_cells;
+      total_fp_muls += (double) 8*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else if (var < 2*mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  work[i][j][k] = (bp->array[var      ][i-1][j  ][k  ]*
+                                   bp->array[var+  mat][i-1][j  ][k  ] +
+                                   bp->array[var      ][i  ][j-1][k  ]*
+                                   bp->array[var+2*mat][i  ][j-1][k  ] +
+                                   bp->array[var      ][i  ][j  ][k-1]*
+                                   bp->array[var-  mat][i  ][j  ][k-1] +
+                                   bp->array[var      ][i  ][j  ][k  ]*
+                                   bp->array[var      ][i  ][j  ][k  ] +
+                                   bp->array[var      ][i  ][j  ][k+1]*
+                                   bp->array[var-  mat][i  ][j  ][k+1] +
+                                   bp->array[var      ][i  ][j+1][k  ]*
+                                   bp->array[var+2*mat][i  ][j+1][k  ] +
+                                   bp->array[var      ][i+1][j  ][k  ]*
+                                   bp->array[var+  mat][i+1][j  ][k  ])/
+                                   7.0*(a1 + bp->array[var][i][j][k]);
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  bp->array[var][i][j][k] = work[i][j][k];
+      }
+      total_fp_adds += (double) 7*num_active*num_cells;
+      total_fp_muls += (double) 8*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else if (var < 3*mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  work[i][j][k] = (bp->array[var      ][i-1][j  ][k  ]*
+                                   bp->array[var+  mat][i-1][j  ][k  ] +
+                                   bp->array[var      ][i  ][j-1][k  ]*
+                                   bp->array[var-2*mat][i  ][j-1][k  ] +
+                                   bp->array[var      ][i  ][j  ][k-1]*
+                                   bp->array[var-  mat][i  ][j  ][k-1] +
+                                   bp->array[var      ][i  ][j  ][k  ]*
+                                   bp->array[var      ][i  ][j  ][k  ] +
+                                   bp->array[var      ][i  ][j  ][k+1]*
+                                   bp->array[var-  mat][i  ][j  ][k+1] +
+                                   bp->array[var      ][i  ][j+1][k  ]*
+                                   bp->array[var-2*mat][i  ][j+1][k  ] +
+                                   bp->array[var      ][i+1][j  ][k  ]*
+                                   bp->array[var+  mat][i+1][j  ][k  ])/
+                                   7.0*(a1 + bp->array[var][i][j][k]);
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  bp->array[var][i][j][k] = work[i][j][k];
+      }
+      total_fp_adds += (double) 7*num_active*num_cells;
+      total_fp_muls += (double) 8*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  work[i][j][k] = (bp->array[var      ][i-1][j  ][k  ]*
+                                   bp->array[var-3*mat][i-1][j  ][k  ] +
+                                   bp->array[var      ][i  ][j-1][k  ]*
+                                   bp->array[var-2*mat][i  ][j-1][k  ] +
+                                   bp->array[var      ][i  ][j  ][k-1]*
+                                   bp->array[var-  mat][i  ][j  ][k-1] +
+                                   bp->array[var      ][i  ][j  ][k  ]*
+                                   bp->array[var      ][i  ][j  ][k  ] +
+                                   bp->array[var      ][i  ][j  ][k+1]*
+                                   bp->array[var-  mat][i  ][j  ][k+1] +
+                                   bp->array[var      ][i  ][j+1][k  ]*
+                                   bp->array[var-2*mat][i  ][j+1][k  ] +
+                                   bp->array[var      ][i+1][j  ][k  ]*
+                                   bp->array[var-3*mat][i+1][j  ][k  ])/
+                                   7.0*(a1 + bp->array[var][i][j][k]);
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  bp->array[var][i][j][k] = work[i][j][k];
+      }
+      total_fp_adds += (double) 7*num_active*num_cells;
+      total_fp_muls += (double) 8*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   }
+}
+
+void stencil_27(int var)
+{
+   int in, i, j, k, v;
+   double work[x_block_size+2][y_block_size+2][z_block_size+2];
+   block *bp;
+
+   if (var < mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  work[i][j][k] = (bp->array[var+3*mat][i-1][j-1][k-1] +
+                                   bp->array[var+2*mat][i-1][j-1][k  ] +
+                                   bp->array[var+3*mat][i-1][j-1][k+1] +
+                                   bp->array[var+2*mat][i-1][j  ][k-1] +
+                                   bp->array[var+  mat][i-1][j  ][k  ] +
+                                   bp->array[var+2*mat][i-1][j  ][k+1] +
+                                   bp->array[var+3*mat][i-1][j+1][k-1] +
+                                   bp->array[var+2*mat][i-1][j+1][k  ] +
+                                   bp->array[var+3*mat][i-1][j+1][k+1] +
+                                   bp->array[var+2*mat][i  ][j-1][k-1] +
+                                   bp->array[var+  mat][i  ][j-1][k  ] +
+                                   bp->array[var+2*mat][i  ][j-1][k+1] +
+                                   bp->array[var+  mat][i  ][j  ][k-1] +
+                                   bp->array[var      ][i  ][j  ][k  ] +
+                                   bp->array[var+  mat][i  ][j  ][k+1] +
+                                   bp->array[var+2*mat][i  ][j+1][k-1] +
+                                   bp->array[var+  mat][i  ][j+1][k  ] +
+                                   bp->array[var+2*mat][i  ][j+1][k+1] +
+                                   bp->array[var+3*mat][i+1][j-1][k-1] +
+                                   bp->array[var+2*mat][i+1][j-1][k  ] +
+                                   bp->array[var+3*mat][i+1][j-1][k+1] +
+                                   bp->array[var+2*mat][i+1][j  ][k-1] +
+                                   bp->array[var+  mat][i+1][j  ][k  ] +
+                                   bp->array[var+2*mat][i+1][j  ][k+1] +
+                                   bp->array[var+3*mat][i+1][j+1][k-1] +
+                                   bp->array[var+2*mat][i+1][j+1][k  ] +
+                                   bp->array[var+3*mat][i+1][j+1][k+1])/
+                                  (a1+27.0);
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  bp->array[var][i][j][k] = work[i][j][k];
+      }
+      total_fp_adds += (double) 27*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else if (var < 2*mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  work[i][j][k] = (bp->array[var-  mat][i-1][j-1][k-1] +
+                                   bp->array[var+2*mat][i-1][j-1][k  ] +
+                                   bp->array[var-  mat][i-1][j-1][k+1] +
+                                   bp->array[var+2*mat][i-1][j  ][k-1] +
+                                   bp->array[var+  mat][i-1][j  ][k  ] +
+                                   bp->array[var+2*mat][i-1][j  ][k+1] +
+                                   bp->array[var-  mat][i-1][j+1][k-1] +
+                                   bp->array[var+2*mat][i-1][j+1][k  ] +
+                                   bp->array[var-  mat][i-1][j+1][k+1] +
+                                   bp->array[var+2*mat][i  ][j-1][k-1] +
+                                   bp->array[var+  mat][i  ][j-1][k  ] +
+                                   bp->array[var+2*mat][i  ][j-1][k+1] +
+                                   bp->array[var+  mat][i  ][j  ][k-1] +
+                                   bp->array[var      ][i  ][j  ][k  ] +
+                                   bp->array[var+  mat][i  ][j  ][k+1] +
+                                   bp->array[var+2*mat][i  ][j+1][k-1] +
+                                   bp->array[var+  mat][i  ][j+1][k  ] +
+                                   bp->array[var+2*mat][i  ][j+1][k+1] +
+                                   bp->array[var-  mat][i+1][j-1][k-1] +
+                                   bp->array[var+2*mat][i+1][j-1][k  ] +
+                                   bp->array[var-  mat][i+1][j-1][k+1] +
+                                   bp->array[var+2*mat][i+1][j  ][k-1] +
+                                   bp->array[var+  mat][i+1][j  ][k  ] +
+                                   bp->array[var+2*mat][i+1][j  ][k+1] +
+                                   bp->array[var-  mat][i+1][j+1][k-1] +
+                                   bp->array[var+2*mat][i+1][j+1][k  ] +
+                                   bp->array[var-  mat][i+1][j+1][k+1])/
+                                  (a1+27.0);
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  bp->array[var][i][j][k] = work[i][j][k];
+      }
+      total_fp_adds += (double) 27*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else if (var < 3*mat) {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  work[i][j][k] = (bp->array[var-  mat][i-1][j-1][k-1] +
+                                   bp->array[var-2*mat][i-1][j-1][k  ] +
+                                   bp->array[var-  mat][i-1][j-1][k+1] +
+                                   bp->array[var-2*mat][i-1][j  ][k-1] +
+                                   bp->array[var+  mat][i-1][j  ][k  ] +
+                                   bp->array[var-2*mat][i-1][j  ][k+1] +
+                                   bp->array[var-  mat][i-1][j+1][k-1] +
+                                   bp->array[var-2*mat][i-1][j+1][k  ] +
+                                   bp->array[var-  mat][i-1][j+1][k+1] +
+                                   bp->array[var-2*mat][i  ][j-1][k-1] +
+                                   bp->array[var+  mat][i  ][j-1][k  ] +
+                                   bp->array[var-2*mat][i  ][j-1][k+1] +
+                                   bp->array[var+  mat][i  ][j  ][k-1] +
+                                   bp->array[var      ][i  ][j  ][k  ] +
+                                   bp->array[var+  mat][i  ][j  ][k+1] +
+                                   bp->array[var-2*mat][i  ][j+1][k-1] +
+                                   bp->array[var+  mat][i  ][j+1][k  ] +
+                                   bp->array[var-2*mat][i  ][j+1][k+1] +
+                                   bp->array[var-  mat][i+1][j-1][k-1] +
+                                   bp->array[var-2*mat][i+1][j-1][k  ] +
+                                   bp->array[var-  mat][i+1][j-1][k+1] +
+                                   bp->array[var-2*mat][i+1][j  ][k-1] +
+                                   bp->array[var+  mat][i+1][j  ][k  ] +
+                                   bp->array[var-2*mat][i+1][j  ][k+1] +
+                                   bp->array[var-  mat][i+1][j+1][k-1] +
+                                   bp->array[var-2*mat][i+1][j+1][k  ] +
+                                   bp->array[var-  mat][i+1][j+1][k+1])/
+                                  (a1+27.0);
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  bp->array[var][i][j][k] = work[i][j][k];
+      }
+      total_fp_adds += (double) 27*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   } else {
+      //#pragma omp parallel for default(shared) private(i, j, k, bp, v)
+      for (in = 0; in < sorted_index[num_refine+1]; in++) {
+         bp = &blocks[sorted_list[in].n];
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  work[i][j][k] = (bp->array[var-  mat][i-1][j-1][k-1] +
+                                   bp->array[var-2*mat][i-1][j-1][k  ] +
+                                   bp->array[var-  mat][i-1][j-1][k+1] +
+                                   bp->array[var-2*mat][i-1][j  ][k-1] +
+                                   bp->array[var-3*mat][i-1][j  ][k  ] +
+                                   bp->array[var-2*mat][i-1][j  ][k+1] +
+                                   bp->array[var-  mat][i-1][j+1][k-1] +
+                                   bp->array[var-2*mat][i-1][j+1][k  ] +
+                                   bp->array[var-  mat][i-1][j+1][k+1] +
+                                   bp->array[var-2*mat][i  ][j-1][k-1] +
+                                   bp->array[var-3*mat][i  ][j-1][k  ] +
+                                   bp->array[var-2*mat][i  ][j-1][k+1] +
+                                   bp->array[var-3*mat][i  ][j  ][k-1] +
+                                   bp->array[var      ][i  ][j  ][k  ] +
+                                   bp->array[var-3*mat][i  ][j  ][k+1] +
+                                   bp->array[var-2*mat][i  ][j+1][k-1] +
+                                   bp->array[var-3*mat][i  ][j+1][k  ] +
+                                   bp->array[var-2*mat][i  ][j+1][k+1] +
+                                   bp->array[var-  mat][i+1][j-1][k-1] +
+                                   bp->array[var-2*mat][i+1][j-1][k  ] +
+                                   bp->array[var-  mat][i+1][j-1][k+1] +
+                                   bp->array[var-2*mat][i+1][j  ][k-1] +
+                                   bp->array[var-3*mat][i+1][j  ][k  ] +
+                                   bp->array[var-2*mat][i+1][j  ][k+1] +
+                                   bp->array[var-  mat][i+1][j+1][k-1] +
+                                   bp->array[var-2*mat][i+1][j+1][k  ] +
+                                   bp->array[var-  mat][i+1][j+1][k+1])/
+                                  (a1+27.0);
+         for (i = 1; i <= x_block_size; i++)
+            for (j = 1; j <= y_block_size; j++)
+               for (k = 1; k <= z_block_size; k++)
+                  bp->array[var][i][j][k] = work[i][j][k];
+      }
+      total_fp_adds += (double) 27*num_active*num_cells;
+      total_fp_divs += (double) num_active*num_cells;
+   }
+}
+
+void stencil_check(int var)
+{
+   int in, i, j, k, v;
+   block *bp;
+
+   //#pragma omp parallel for default(shared) private(i, j, k, bp, v)
+   for (in = 0; in < sorted_index[num_refine+1]; in++) {
+      bp = &blocks[sorted_list[in].n];
+      for (i = 1; i <= x_block_size; i++)
+         for (j = 1; j <= y_block_size; j++)
+            for (k = 1; k <= z_block_size; k++) {
+               bp->array[var][i][j][k] = fabs(bp->array[var][i][j][k]);
+               if (bp->array[var][i][j][k] >= 1.0) {
+                  bp->array[var][i][j][k] /= (a1 + a0[0] +
+                                              bp->array[var][i][j][k]);
+                  total_fp_divs += (double) 1;
+                  total_fp_adds += (double) 2;
+               }
+               else if (bp->array[var][i][j][k] < 0.1) {
+                  bp->array[var][i][j][k] *= 10.0 - a1;
+                  total_fp_muls += (double) 1;
+                  total_fp_adds += (double) 1;
+               }
+            }
+   }
+}
diff -ruN ../miniAMR-1.7.0/newversion/miniAMR.clean/openmp/stencil.c ../miniAMR-1.7.0/newversion/miniAMR.ekg/openmp/stencil.c
--- ../miniAMR-1.7.0/newversion/miniAMR.clean/openmp/stencil.c	2023-10-11 13:14:35.608915910 -0400
+++ ../miniAMR-1.7.0/newversion/miniAMR.ekg/openmp/stencil.c	2023-10-11 13:27:30.263201086 -0400
@@ -31,6 +31,10 @@
 #include "comm.h"
 #include "proto.h"
 
+#if defined APPEKG
+#include <appekg.h>
+#endif
+
 void stencil_calc(int, int);
 void stencil_0(int);
 void stencil_x(int);
@@ -78,11 +82,13 @@
 void stencil_calc(int var, int stencil_in)
 {
    int i, j, k;
-
    if (stencil_in == 7) {
       // Parallelize
       #pragma omp parallel for shared(sorted_index, num_refine, blocks, sorted_list, x_block_size, y_block_size, z_block_size)
       for(int in = 0; in < sorted_index[num_refine+1]; in++) {
+#if defined APPEKG
+         EKG_BEGIN_HEARTBEAT(2,1000);
+#endif
          block* bp = &blocks[sorted_list[in].n];
          double work[x_block_size+2][y_block_size+2][z_block_size+2];
          for (i = 1; i <= x_block_size; i++)
@@ -99,6 +105,9 @@
             for (j = 1; j <= y_block_size; j++)
                for (k = 1; k <= z_block_size; k++)
                   bp->array[var][i][j][k] = work[i][j][k];
+#if defined APPEKG
+         EKG_END_HEARTBEAT(2);
+#endif
       }
       total_fp_divs += (double) num_active*num_cells;
       total_fp_adds += (double) 6*num_active*num_cells;
@@ -106,6 +115,9 @@
       // Parallelize
       #pragma omp parallel for shared(sorted_index, num_refine, blocks, sorted_list, x_block_size, y_block_size, z_block_size)
       for(int in = 0; in < sorted_index[num_refine+1]; in++) {
+#if defined APPEKG 
+         EKG_BEGIN_HEARTBEAT(2,1000);
+#endif
          block* bp = &blocks[sorted_list[in].n];
          double sb, sm, sf, work[x_block_size+2][y_block_size+2][z_block_size+2];
          for (i = 1; i <= x_block_size; i++)
@@ -144,6 +156,9 @@
             for (j = 1; j <= y_block_size; j++)
                for (k = 1; k <= z_block_size; k++)
                   bp->array[var][i][j][k] = work[i][j][k];
+#if defined APPEKG
+         EKG_END_HEARTBEAT(2);
+#endif
       }
       total_fp_divs += (double) num_active*num_cells;
       total_fp_adds += (double) 26*num_active*num_cells;
diff -ruN ../miniAMR-1.7.0/newversion/miniAMR.clean/patchref.txt ../miniAMR-1.7.0/newversion/miniAMR.ekg/patchref.txt
--- ../miniAMR-1.7.0/newversion/miniAMR.clean/patchref.txt	2023-10-18 15:27:04.009142000 -0400
+++ ../miniAMR-1.7.0/newversion/miniAMR.ekg/patchref.txt	1969-12-31 19:00:00.000000000 -0500
@@ -1,198 +0,0 @@
-diff -Naru -x '*.[oxa]' -x 'READ*' -x 'profile*' ./main.c ../../../ref/main.c
---- ./main.c	2023-10-11 13:14:35.618311582 -0400
-+++ ../../../ref/main.c	2023-09-20 00:28:19.766158686 -0400
-@@ -35,6 +35,10 @@
- #include "timer.h"
- #include "proto.h"
- 
-+#if defined APPEKG
-+#include <appekg.h>
-+#endif
-+
- int main(int argc, char** argv)
- {
-    int i, ierr, object_num;
-@@ -46,7 +50,15 @@
-    ierr = MPI_Comm_set_errhandler(MPI_COMM_WORLD, MPI_ERRORS_ARE_FATAL);
-    ierr = MPI_Comm_rank(MPI_COMM_WORLD, &my_pe);
-    ierr = MPI_Comm_size(MPI_COMM_WORLD, &num_pes);
--
-+ #if defined APPEKG
-+   int appekg_myrank;
-+   MPI_Comm_rank(MPI_COMM_WORLD, &appekg_myrank);
-+   EKG_INITIALIZE(4, 1, 2, 0, appekg_myrank, 1);
-+   EKG_NAME_HEARTBEAT(1,"AllocateBlock");
-+   EKG_NAME_HEARTBEAT(2,"TimestepStage");
-+   EKG_NAME_HEARTBEAT(3,"RefineStep");
-+   EKG_NAME_HEARTBEAT(4,"DeallocateBlock");
-+#endif
-    t1 = timer();
-    counter_malloc = 0;
-    size_malloc = 0.0;
-@@ -357,7 +369,9 @@
-    MPI_Barrier(MPI_COMM_WORLD);
- 
-    MPI_Finalize();
--
-+#if defined APPEKG
-+   EKG_FINALIZE();
-+#endif
-    exit(0);
- }
- 
-@@ -430,6 +444,11 @@
-                                 __FILE__, __LINE__);
- 
-    for (n = 0; n < max_num_blocks; n++) {
-+ 
-+ #ifdef APPEKG
-+      EKG_BEGIN_HEARTBEAT(1,70);
-+#endif     	   
-+
-       blocks[n].number = -1;
-       blocks[n].array = (double ****) ma_malloc(num_vars*sizeof(double ***),
-                                                 __FILE__, __LINE__);
-@@ -447,6 +466,11 @@
-                                                __FILE__, __LINE__);
-          }
-       }
-+
-+ #ifdef APPEKG
-+    EKG_END_HEARTBEAT(1);
-+#endif      
-+
-    }
- 
-    sorted_list = (sorted_block *)ma_malloc(max_num_blocks*sizeof(sorted_block),
-@@ -611,6 +635,9 @@
-    int i, j, m, n;
- 
-    for (n = 0; n < max_num_blocks; n++) {
-+#ifdef APPEKG
-+       EKG_BEGIN_HEARTBEAT(4,25);
-+#endif
-       for (m = 0; m < num_vars; m++) {
-          for (i = 0; i < x_block_size+2; i++) {
-             for (j = 0; j < y_block_size+2; j++)
-@@ -620,6 +647,10 @@
-          free(blocks[n].array[m]);
-       }
-       free(blocks[n].array);
-+#ifdef APPEKG
-+      EKG_END_HEARTBEAT(4);
-+#endif   
-+   
-    }
-    free(blocks);
- 
-diff -Naru -x '*.[oxa]' -x 'READ*' -x 'profile*' ./Makefile ../../../ref/Makefile
---- ./Makefile	2023-10-11 13:14:35.610920000 -0400
-+++ ../../../ref/Makefile	2023-09-04 01:37:19.939619000 -0400
-@@ -5,6 +5,21 @@
- LDFLAGS =
- LDLIBS = -lm
- 
-+#-----------------------------------------------------------------------
-+# APPEKG Section
-+# JEC: choose to build with APPEKG or not, and specify where
-+#      to find APPEKG stuff
-+APPEKGDIR = /anvil/projects/x-cis230165/tools/AppEKG/
-+DO_APPEKG = ON
-+
-+ifeq ($(DO_APPEKG),ON)
-+APPEKGCFLAGS = -DAPPEKG -I${APPEKGDIR}
-+APPEKGLDOBJ = -L${APPEKGDIR} -lappekg -lpthread -lrt
-+else
-+APPEKGCFLAGS =
-+APPEKGLDOBJ =
-+endif
-+
- EXEC = miniAMR.x
- 
- OBJS = block.o check_sum.o comm_block.o comm.o comm_parent.o comm_refine.o \
-@@ -12,10 +27,10 @@
-        rcb.o refine.o sfc.o stencil.o util.o
- 
- $(EXEC): $(OBJS)
--	$(LD) $(LDFLAGS) -o $@ $(OBJS) $(LDLIBS)
-+	$(LD) $(LDFLAGS) -o $@ $(OBJS) $(LDLIBS) $(APPEKGLDOBJ)
- 
- .c.o:
--	$(CC) $(CPPFLAGS) $(CFLAGS) -c $<
-+	$(CC) $(CPPFLAGS) $(CFLAGS) $(APPEKGCFLAGS) -c $<
- 
- clean:
- 	rm *.o miniAMR.x
-diff -Naru -x '*.[oxa]' -x 'READ*' -x 'profile*' ./refine.c ../../../ref/refine.c
---- ./refine.c	2023-10-11 13:14:35.627205301 -0400
-+++ ../../../ref/refine.c	2023-09-04 01:31:42.664915358 -0400
-@@ -33,6 +33,10 @@
- #include "proto.h"
- #include "timer.h"
- 
-+#if defined APPEKG
-+#include <appekg.h>
-+#endif
-+
- // This file contains routines that determine which blocks are going to
- // be refined and which are going to be coarsened.
- void refine(int ts)
-@@ -59,6 +63,9 @@
-       num_refine_step = num_refine;
- 
-    for (i = 0; i < num_refine_step; i++) {
-+#ifdef APPEKG
-+      EKG_BEGIN_HEARTBEAT(3,1);
-+#endif
-       for (j = num_refine; j >= 0; j--)
-          if (num_blocks[j]) {
-             cur_max_level = j;
-@@ -165,6 +172,10 @@
-             t4 += timer() - t2;
-          }
-       }
-+#ifdef APPEKG
-+      EKG_END_HEARTBEAT(3);
-+#endif   
-+   
-    }
-    timer_rs_pa += tp1;
-    timer_rs_mv += tm1;
-diff -Naru -x '*.[oxa]' -x 'READ*' -x 'profile*' ./stencil.c ../../../ref/stencil.c
---- ./stencil.c	2023-10-11 13:14:35.628246206 -0400
-+++ ../../../ref/stencil.c	2023-09-06 01:56:31.917879196 -0400
-@@ -30,6 +30,11 @@
- #include "block.h"
- #include "comm.h"
- #include "proto.h"
-+
-+#if defined APPEKG
-+#include <appekg.h>
-+#endif
-+
- void stencil_calc(int, int);
- void stencil_0(int);
- void stencil_x(int);
-@@ -75,6 +80,11 @@
- 
- void stencil_calc(int var, int stencil_in)
- {
-+
-+#if defined APPEKG
-+    EKG_BEGIN_HEARTBEAT(2,40);
-+#endif
-+	 
-    int i, j, k, in;
-    double sb, sm, sf, work[x_block_size+2][y_block_size+2][z_block_size+2];
-    block *bp;
-@@ -142,6 +152,10 @@
-       total_fp_divs += (double) num_active*num_cells;
-       total_fp_adds += (double) 26*num_active*num_cells;
-    }
-+
-+#if defined APPEKG
-+   EKG_END_HEARTBEAT(2);
-+#endif
- }
- 
- void stencil_0(int var)
